var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import require$$1 from "stream";
import require$$0 from "util";
import { parse } from "regexparam";
import { Slot } from "@radix-ui/react-slot";
import { cva } from "class-variance-authority";
import { isCSSVariableName, transformProps, transformPropOrder, getValueAsType, numberValueTypes, isMotionValue, px, mixNumber, motionValue, KeyframeResolver, time, frame, cancelFrame, findValueType, complex, getAnimatableNone, microtask, DOMKeyframesResolver, defaultTransformValue, readTransformValue, getDefaultValueType, getValueTransition, makeAnimationInstant, JSAnimation, AsyncMotionValueAnimation, positionalKeys, isPrimaryPointer, frameData, setDragLock, percent, statsBuffer, isSVGElement, isSVGSVGElement, frameSteps, activeAnimations, hover, press } from "motion-dom";
import { warning, invariant, warnOnce, isNumericalString, isZeroValueString, SubscriptionManager, MotionGlobalConfig, secondsToMilliseconds, pipe, millisecondsToSeconds, progress, clamp as clamp$1, noop, addUniqueItem, removeItem, circOut } from "motion-utils";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l2 = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
  function A(a) {
    if (null === a || "object" !== typeof a) return null;
    a = z && a[z] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, D = {};
  function E(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  E.prototype.isReactComponent = {};
  E.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b, "setState");
  };
  E.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E.prototype;
  function G(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  var H = G.prototype = new F();
  H.constructor = G;
  C(H, E.prototype);
  H.isPureReactComponent = true;
  var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M(a, b, e) {
    var d, c = {}, k = null, h = null;
    if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
    var g = arguments.length - 2;
    if (1 === g) c.children = e;
    else if (1 < g) {
      for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
      c.children = f;
    }
    if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
    return { $$typeof: l2, type: a, key: k, ref: h, props: c, _owner: K.current };
  }
  function N(a, b) {
    return { $$typeof: l2, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
  }
  function O(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l2;
  }
  function escape(a) {
    var b = { "=": "=0", ":": "=2" };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b[a2];
    });
  }
  var P = /\/+/g;
  function Q(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
  }
  function R(a, b, e, d, c) {
    var k = typeof a;
    if ("undefined" === k || "boolean" === k) a = null;
    var h = false;
    if (null === a) h = true;
    else switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l2:
          case n:
            h = true;
        }
    }
    if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
      return a2;
    })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
    h = 0;
    d = "" === d ? "." : d + ":";
    if (I(a)) for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = d + Q(k, g);
      h += R(k, b, e, f, c);
    }
    else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
    else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h;
  }
  function S(a, b, e) {
    if (null == a) return a;
    var d = [], c = 0;
    R(a, d, "", "", function(a2) {
      return b.call(e, a2, c++);
    });
    return d;
  }
  function T(a) {
    if (-1 === a._status) {
      var b = a._result;
      b = b();
      b.then(function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
      }, function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
      });
      -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
  }
  var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
  function X() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S, forEach: function(a, b, e) {
    S(a, function() {
      b.apply(this, arguments);
    }, e);
  }, count: function(a) {
    var b = 0;
    S(a, function() {
      b++;
    });
    return b;
  }, toArray: function(a) {
    return S(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  } };
  react_production_min.Component = E;
  react_production_min.Fragment = p;
  react_production_min.Profiler = r2;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X;
  react_production_min.cloneElement = function(a, b, e) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
    if (null != b) {
      void 0 !== b.ref && (k = b.ref, h = K.current);
      void 0 !== b.key && (c = "" + b.key);
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
      for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
    var f = arguments.length - 2;
    if (1 === f) d.children = e;
    else if (1 < f) {
      g = Array(f);
      for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
      d.children = g;
    }
    return { $$typeof: l2, type: a.type, key: c, ref: k, props: d, _owner: h };
  };
  react_production_min.createContext = function(a) {
    a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a.Provider = { $$typeof: t, _context: a };
    return a.Consumer = a;
  };
  react_production_min.createElement = M;
  react_production_min.createFactory = function(a) {
    var b = M.bind(null, a);
    b.type = a;
    return b;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a) {
    return { $$typeof: v, render: a };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a) {
    return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
  };
  react_production_min.memo = function(a, b) {
    return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
  };
  react_production_min.startTransition = function(a) {
    var b = V.transition;
    V.transition = {};
    try {
      a();
    } finally {
      V.transition = b;
    }
  };
  react_production_min.unstable_act = X;
  react_production_min.useCallback = function(a, b) {
    return U.current.useCallback(a, b);
  };
  react_production_min.useContext = function(a) {
    return U.current.useContext(a);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a) {
    return U.current.useDeferredValue(a);
  };
  react_production_min.useEffect = function(a, b) {
    return U.current.useEffect(a, b);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a, b, e) {
    return U.current.useImperativeHandle(a, b, e);
  };
  react_production_min.useInsertionEffect = function(a, b) {
    return U.current.useInsertionEffect(a, b);
  };
  react_production_min.useLayoutEffect = function(a, b) {
    return U.current.useLayoutEffect(a, b);
  };
  react_production_min.useMemo = function(a, b) {
    return U.current.useMemo(a, b);
  };
  react_production_min.useReducer = function(a, b, e) {
    return U.current.useReducer(a, b, e);
  };
  react_production_min.useRef = function(a) {
    return U.current.useRef(a);
  };
  react_production_min.useState = function(a) {
    return U.current.useState(a);
  };
  react_production_min.useSyncExternalStore = function(a, b, e) {
    return U.current.useSyncExternalStore(a, b, e);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var react_development = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
react_development.exports;
var hasRequiredReact_development;
function requireReact_development() {
  if (hasRequiredReact_development) return react_development.exports;
  hasRequiredReact_development = 1;
  (function(module2, exports) {
    if (process.env.NODE_ENV !== "production") {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.3.1";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!render.name && !render.displayName) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!type.name && !type.displayName) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect2(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame2 = componentFrameCache.get(fn);
            if (frame2 !== void 0) {
              return frame2;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s2 = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]) {
                c--;
              }
              for (; s2 >= 1 && c >= 0; s2--, c--) {
                if (sampleLines[s2] !== controlLines[c]) {
                  if (s2 !== 1 || c !== 1) {
                    do {
                      s2--;
                      c--;
                      if (c < 0 || sampleLines[s2] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s2 >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module2 && module2[requireString];
              enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth);
              throw error2;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error2) {
                    popActScope(prevActScopeDepth);
                    reject(error2);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error2) {
                reject(error2);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i = 0;
              try {
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error2) {
                queue = queue.slice(i + 1);
                throw error2;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.act = act;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect2;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  })(react_development, react_development.exports);
  return react_development.exports;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  if (process.env.NODE_ENV === "production") {
    react.exports = requireReact_production_min();
  } else {
    react.exports = requireReact_development();
  }
  return react.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = requireReact(), k = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l2;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var React2 = requireReact();
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame2 = componentFrameCache.get(fn);
          if (frame2 !== void 0) {
            return frame2;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s2 = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]) {
              c--;
            }
            for (; s2 >= 1 && c >= 0; s2--, c--) {
              if (sampleLines[s2] !== controlLines[c]) {
                if (s2 !== 1 || c !== 1) {
                  do {
                    s2--;
                    c--;
                    if (c < 0 || sampleLines[s2] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s2 >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2) ;
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === void 0 || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum();
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          {
            if (hasOwnProperty.call(props, "key")) {
              var componentName = getComponentNameFromType(type);
              var keys = Object.keys(props).filter(function(k) {
                return k !== "key";
              });
              var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_development.jsx = jsx;
      reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  return reactJsxRuntime_development;
}
if (process.env.NODE_ENV === "production") {
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
} else {
  jsxRuntime.exports = requireReactJsxRuntime_development();
}
var jsxRuntimeExports = jsxRuntime.exports;
var server_node = {};
var reactDomServerLegacy_node_production_min = {};
/**
 * @license React
 * react-dom-server-legacy.node.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDomServerLegacy_node_production_min;
function requireReactDomServerLegacy_node_production_min() {
  if (hasRequiredReactDomServerLegacy_node_production_min) return reactDomServerLegacy_node_production_min;
  hasRequiredReactDomServerLegacy_node_production_min = 1;
  var ea = requireReact(), fa = require$$1, n = Object.prototype.hasOwnProperty, ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = {}, ja = {};
  function ka(a) {
    if (n.call(ja, a)) return true;
    if (n.call(ia, a)) return false;
    if (ha.test(a)) return ja[a] = true;
    ia[a] = true;
    return false;
  }
  function q(a, b, c, d, f, e, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = f;
    this.mustUseProperty = c;
    this.propertyName = a;
    this.type = b;
    this.sanitizeURL = e;
    this.removeEmptyString = g;
  }
  var r2 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    r2[a] = new q(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b = a[0];
    r2[b] = new q(b, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    r2[a] = new q(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    r2[a] = new q(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    r2[a] = new q(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    r2[a] = new q(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    r2[a] = new q(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    r2[a] = new q(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    r2[a] = new q(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var la = /[\-:]([a-z])/g;
  function ma(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b = a.replace(
      la,
      ma
    );
    r2[b] = new q(b, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b = a.replace(la, ma);
    r2[b] = new q(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b = a.replace(la, ma);
    r2[b] = new q(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    r2[a] = new q(a, 1, false, a.toLowerCase(), null, false, false);
  });
  r2.xlinkHref = new q("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    r2[a] = new q(a, 1, false, a.toLowerCase(), null, true, true);
  });
  var t = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, na = ["Webkit", "ms", "Moz", "O"];
  Object.keys(t).forEach(function(a) {
    na.forEach(function(b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1);
      t[b] = t[a];
    });
  });
  var oa = /["'&<>]/;
  function u(a) {
    if ("boolean" === typeof a || "number" === typeof a) return "" + a;
    a = "" + a;
    var b = oa.exec(a);
    if (b) {
      var c = "", d, f = 0;
      for (d = b.index; d < a.length; d++) {
        switch (a.charCodeAt(d)) {
          case 34:
            b = "&quot;";
            break;
          case 38:
            b = "&amp;";
            break;
          case 39:
            b = "&#x27;";
            break;
          case 60:
            b = "&lt;";
            break;
          case 62:
            b = "&gt;";
            break;
          default:
            continue;
        }
        f !== d && (c += a.substring(f, d));
        f = d + 1;
        c += b;
      }
      a = f !== d ? c + a.substring(f, d) : c;
    }
    return a;
  }
  var pa = /([A-Z])/g, qa = /^ms-/, ra = Array.isArray;
  function v(a, b) {
    return { insertionMode: a, selectedValue: b };
  }
  function sa(a, b, c) {
    switch (b) {
      case "select":
        return v(1, null != c.value ? c.value : c.defaultValue);
      case "svg":
        return v(2, null);
      case "math":
        return v(3, null);
      case "foreignObject":
        return v(1, null);
      case "table":
        return v(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return v(5, null);
      case "colgroup":
        return v(7, null);
      case "tr":
        return v(6, null);
    }
    return 4 <= a.insertionMode || 0 === a.insertionMode ? v(1, null) : a;
  }
  var ta = /* @__PURE__ */ new Map();
  function ua(a, b, c) {
    if ("object" !== typeof c) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
    b = true;
    for (var d in c) if (n.call(c, d)) {
      var f = c[d];
      if (null != f && "boolean" !== typeof f && "" !== f) {
        if (0 === d.indexOf("--")) {
          var e = u(d);
          f = u(("" + f).trim());
        } else {
          e = d;
          var g = ta.get(e);
          void 0 !== g ? e = g : (g = u(e.replace(pa, "-$1").toLowerCase().replace(qa, "-ms-")), ta.set(e, g), e = g);
          f = "number" === typeof f ? 0 === f || n.call(
            t,
            d
          ) ? "" + f : f + "px" : u(("" + f).trim());
        }
        b ? (b = false, a.push(' style="', e, ":", f)) : a.push(";", e, ":", f);
      }
    }
    b || a.push('"');
  }
  function w(a, b, c, d) {
    switch (c) {
      case "style":
        ua(a, b, d);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < c.length) || "o" !== c[0] && "O" !== c[0] || "n" !== c[1] && "N" !== c[1]) {
      if (b = r2.hasOwnProperty(c) ? r2[c] : null, null !== b) {
        switch (typeof d) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!b.acceptsBooleans) return;
        }
        c = b.attributeName;
        switch (b.type) {
          case 3:
            d && a.push(" ", c, '=""');
            break;
          case 4:
            true === d ? a.push(" ", c, '=""') : false !== d && a.push(" ", c, '="', u(d), '"');
            break;
          case 5:
            isNaN(d) || a.push(" ", c, '="', u(d), '"');
            break;
          case 6:
            !isNaN(d) && 1 <= d && a.push(" ", c, '="', u(d), '"');
            break;
          default:
            b.sanitizeURL && (d = "" + d), a.push(" ", c, '="', u(d), '"');
        }
      } else if (ka(c)) {
        switch (typeof d) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (b = c.toLowerCase().slice(0, 5), "data-" !== b && "aria-" !== b) return;
        }
        a.push(" ", c, '="', u(d), '"');
      }
    }
  }
  function x(a, b, c) {
    if (null != b) {
      if (null != c) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
      if ("object" !== typeof b || !("__html" in b)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
      b = b.__html;
      null !== b && void 0 !== b && a.push("" + b);
    }
  }
  function va(a) {
    var b = "";
    ea.Children.forEach(a, function(a2) {
      null != a2 && (b += a2);
    });
    return b;
  }
  function wa(a, b, c, d) {
    a.push(z(c));
    var f = c = null, e;
    for (e in b) if (n.call(b, e)) {
      var g = b[e];
      if (null != g) switch (e) {
        case "children":
          c = g;
          break;
        case "dangerouslySetInnerHTML":
          f = g;
          break;
        default:
          w(a, d, e, g);
      }
    }
    a.push(">");
    x(a, f, c);
    return "string" === typeof c ? (a.push(u(c)), null) : c;
  }
  var xa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, ya = /* @__PURE__ */ new Map();
  function z(a) {
    var b = ya.get(a);
    if (void 0 === b) {
      if (!xa.test(a)) throw Error("Invalid tag: " + a);
      b = "<" + a;
      ya.set(a, b);
    }
    return b;
  }
  function za(a, b, c, d, f) {
    switch (b) {
      case "select":
        a.push(z("select"));
        var e = null, g = null;
        for (l2 in c) if (n.call(c, l2)) {
          var h = c[l2];
          if (null != h) switch (l2) {
            case "children":
              e = h;
              break;
            case "dangerouslySetInnerHTML":
              g = h;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              w(a, d, l2, h);
          }
        }
        a.push(">");
        x(a, g, e);
        return e;
      case "option":
        g = f.selectedValue;
        a.push(z("option"));
        var k = h = null, m = null;
        var l2 = null;
        for (e in c) if (n.call(c, e)) {
          var p = c[e];
          if (null != p) switch (e) {
            case "children":
              h = p;
              break;
            case "selected":
              m = p;
              break;
            case "dangerouslySetInnerHTML":
              l2 = p;
              break;
            case "value":
              k = p;
            default:
              w(a, d, e, p);
          }
        }
        if (null != g) if (c = null !== k ? "" + k : va(h), ra(g)) for (d = 0; d < g.length; d++) {
          if ("" + g[d] === c) {
            a.push(' selected=""');
            break;
          }
        }
        else "" + g === c && a.push(' selected=""');
        else m && a.push(' selected=""');
        a.push(">");
        x(a, l2, h);
        return h;
      case "textarea":
        a.push(z("textarea"));
        l2 = g = e = null;
        for (h in c) if (n.call(c, h) && (k = c[h], null != k)) switch (h) {
          case "children":
            l2 = k;
            break;
          case "value":
            e = k;
            break;
          case "defaultValue":
            g = k;
            break;
          case "dangerouslySetInnerHTML":
            throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
          default:
            w(a, d, h, k);
        }
        null === e && null !== g && (e = g);
        a.push(">");
        if (null != l2) {
          if (null != e) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (ra(l2) && 1 < l2.length) throw Error("<textarea> can only have at most one child.");
          e = "" + l2;
        }
        "string" === typeof e && "\n" === e[0] && a.push("\n");
        null !== e && a.push(u("" + e));
        return null;
      case "input":
        a.push(z("input"));
        k = l2 = h = e = null;
        for (g in c) if (n.call(c, g) && (m = c[g], null != m)) switch (g) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          case "defaultChecked":
            k = m;
            break;
          case "defaultValue":
            h = m;
            break;
          case "checked":
            l2 = m;
            break;
          case "value":
            e = m;
            break;
          default:
            w(a, d, g, m);
        }
        null !== l2 ? w(a, d, "checked", l2) : null !== k && w(a, d, "checked", k);
        null !== e ? w(a, d, "value", e) : null !== h && w(a, d, "value", h);
        a.push("/>");
        return null;
      case "menuitem":
        a.push(z("menuitem"));
        for (var B in c) if (n.call(c, B) && (e = c[B], null != e)) switch (B) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
          default:
            w(
              a,
              d,
              B,
              e
            );
        }
        a.push(">");
        return null;
      case "title":
        a.push(z("title"));
        e = null;
        for (p in c) if (n.call(c, p) && (g = c[p], null != g)) switch (p) {
          case "children":
            e = g;
            break;
          case "dangerouslySetInnerHTML":
            throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
          default:
            w(a, d, p, g);
        }
        a.push(">");
        return e;
      case "listing":
      case "pre":
        a.push(z(b));
        g = e = null;
        for (k in c) if (n.call(c, k) && (h = c[k], null != h)) switch (k) {
          case "children":
            e = h;
            break;
          case "dangerouslySetInnerHTML":
            g = h;
            break;
          default:
            w(a, d, k, h);
        }
        a.push(">");
        if (null != g) {
          if (null != e) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if ("object" !== typeof g || !("__html" in g)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          c = g.__html;
          null !== c && void 0 !== c && ("string" === typeof c && 0 < c.length && "\n" === c[0] ? a.push("\n", c) : a.push("" + c));
        }
        "string" === typeof e && "\n" === e[0] && a.push("\n");
        return e;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        a.push(z(b));
        for (var C in c) if (n.call(c, C) && (e = c[C], null != e)) switch (C) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(b + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          default:
            w(a, d, C, e);
        }
        a.push("/>");
        return null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return wa(a, c, b, d);
      case "html":
        return 0 === f.insertionMode && a.push("<!DOCTYPE html>"), wa(a, c, b, d);
      default:
        if (-1 === b.indexOf("-") && "string" !== typeof c.is) return wa(a, c, b, d);
        a.push(z(b));
        g = e = null;
        for (m in c) if (n.call(c, m) && (h = c[m], null != h)) switch (m) {
          case "children":
            e = h;
            break;
          case "dangerouslySetInnerHTML":
            g = h;
            break;
          case "style":
            ua(a, d, h);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            break;
          default:
            ka(m) && "function" !== typeof h && "symbol" !== typeof h && a.push(" ", m, '="', u(h), '"');
        }
        a.push(">");
        x(a, g, e);
        return e;
    }
  }
  function Aa(a, b, c) {
    a.push('<!--$?--><template id="');
    if (null === c) throw Error("An ID must have been assigned before we can complete the boundary.");
    a.push(c);
    return a.push('"></template>');
  }
  function Ba(a, b, c, d) {
    switch (c.insertionMode) {
      case 0:
      case 1:
        return a.push('<div hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
      case 2:
        return a.push('<svg aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
      case 3:
        return a.push('<math aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
      case 4:
        return a.push('<table hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
      case 5:
        return a.push('<table hidden><tbody id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
      case 6:
        return a.push('<table hidden><tr id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
      case 7:
        return a.push('<table hidden><colgroup id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
      default:
        throw Error("Unknown insertion mode. This is a bug in React.");
    }
  }
  function Ca(a, b) {
    switch (b.insertionMode) {
      case 0:
      case 1:
        return a.push("</div>");
      case 2:
        return a.push("</svg>");
      case 3:
        return a.push("</math>");
      case 4:
        return a.push("</table>");
      case 5:
        return a.push("</tbody></table>");
      case 6:
        return a.push("</tr></table>");
      case 7:
        return a.push("</colgroup></table>");
      default:
        throw Error("Unknown insertion mode. This is a bug in React.");
    }
  }
  var Da = /[<\u2028\u2029]/g;
  function Ea(a) {
    return JSON.stringify(a).replace(Da, function(a2) {
      switch (a2) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function Fa(a, b) {
    b = void 0 === b ? "" : b;
    return { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: b + "P:", segmentPrefix: b + "S:", boundaryPrefix: b + "B:", idPrefix: b, nextSuspenseID: 0, sentCompleteSegmentFunction: false, sentCompleteBoundaryFunction: false, sentClientRenderFunction: false, generateStaticMarkup: a };
  }
  function Ga() {
    return { insertionMode: 1, selectedValue: null };
  }
  function Ha(a, b, c, d) {
    if (c.generateStaticMarkup) return a.push(u(b)), false;
    "" === b ? a = d : (d && a.push("<!-- -->"), a.push(u(b)), a = true);
    return a;
  }
  var A = Object.assign, Ia = Symbol.for("react.element"), Ja = Symbol.for("react.portal"), Ka = Symbol.for("react.fragment"), La = Symbol.for("react.strict_mode"), Ma = Symbol.for("react.profiler"), Na = Symbol.for("react.provider"), Oa = Symbol.for("react.context"), Pa = Symbol.for("react.forward_ref"), Qa = Symbol.for("react.suspense"), Ra = Symbol.for("react.suspense_list"), Sa = Symbol.for("react.memo"), Ta = Symbol.for("react.lazy"), Ua = Symbol.for("react.scope"), Va = Symbol.for("react.debug_trace_mode"), Wa = Symbol.for("react.legacy_hidden"), Xa = Symbol.for("react.default_value"), Ya = Symbol.iterator;
  function Za(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch (a) {
      case Ka:
        return "Fragment";
      case Ja:
        return "Portal";
      case Ma:
        return "Profiler";
      case La:
        return "StrictMode";
      case Qa:
        return "Suspense";
      case Ra:
        return "SuspenseList";
    }
    if ("object" === typeof a) switch (a.$$typeof) {
      case Oa:
        return (a.displayName || "Context") + ".Consumer";
      case Na:
        return (a._context.displayName || "Context") + ".Provider";
      case Pa:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Sa:
        return b = a.displayName || null, null !== b ? b : Za(a.type) || "Memo";
      case Ta:
        b = a._payload;
        a = a._init;
        try {
          return Za(a(b));
        } catch (c) {
        }
    }
    return null;
  }
  var $a = {};
  function ab(a, b) {
    a = a.contextTypes;
    if (!a) return $a;
    var c = {}, d;
    for (d in a) c[d] = b[d];
    return c;
  }
  var D = null;
  function E(a, b) {
    if (a !== b) {
      a.context._currentValue2 = a.parentValue;
      a = a.parent;
      var c = b.parent;
      if (null === a) {
        if (null !== c) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
      } else {
        if (null === c) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        E(a, c);
      }
      b.context._currentValue2 = b.value;
    }
  }
  function bb(a) {
    a.context._currentValue2 = a.parentValue;
    a = a.parent;
    null !== a && bb(a);
  }
  function cb(a) {
    var b = a.parent;
    null !== b && cb(b);
    a.context._currentValue2 = a.value;
  }
  function db(a, b) {
    a.context._currentValue2 = a.parentValue;
    a = a.parent;
    if (null === a) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
    a.depth === b.depth ? E(a, b) : db(a, b);
  }
  function eb(a, b) {
    var c = b.parent;
    if (null === c) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
    a.depth === c.depth ? E(a, c) : eb(a, c);
    b.context._currentValue2 = b.value;
  }
  function F(a) {
    var b = D;
    b !== a && (null === b ? cb(a) : null === a ? bb(b) : b.depth === a.depth ? E(b, a) : b.depth > a.depth ? db(b, a) : eb(b, a), D = a);
  }
  var fb = { isMounted: function() {
    return false;
  }, enqueueSetState: function(a, b) {
    a = a._reactInternals;
    null !== a.queue && a.queue.push(b);
  }, enqueueReplaceState: function(a, b) {
    a = a._reactInternals;
    a.replace = true;
    a.queue = [b];
  }, enqueueForceUpdate: function() {
  } };
  function gb(a, b, c, d) {
    var f = void 0 !== a.state ? a.state : null;
    a.updater = fb;
    a.props = c;
    a.state = f;
    var e = { queue: [], replace: false };
    a._reactInternals = e;
    var g = b.contextType;
    a.context = "object" === typeof g && null !== g ? g._currentValue2 : d;
    g = b.getDerivedStateFromProps;
    "function" === typeof g && (g = g(c, f), f = null === g || void 0 === g ? f : A({}, f, g), a.state = f);
    if ("function" !== typeof b.getDerivedStateFromProps && "function" !== typeof a.getSnapshotBeforeUpdate && ("function" === typeof a.UNSAFE_componentWillMount || "function" === typeof a.componentWillMount)) if (b = a.state, "function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount(), b !== a.state && fb.enqueueReplaceState(a, a.state, null), null !== e.queue && 0 < e.queue.length) if (b = e.queue, g = e.replace, e.queue = null, e.replace = false, g && 1 === b.length) a.state = b[0];
    else {
      e = g ? b[0] : a.state;
      f = true;
      for (g = g ? 1 : 0; g < b.length; g++) {
        var h = b[g];
        h = "function" === typeof h ? h.call(a, e, c, d) : h;
        null != h && (f ? (f = false, e = A({}, e, h)) : A(e, h));
      }
      a.state = e;
    }
    else e.queue = null;
  }
  var hb = { id: 1, overflow: "" };
  function ib(a, b, c) {
    var d = a.id;
    a = a.overflow;
    var f = 32 - G(d) - 1;
    d &= ~(1 << f);
    c += 1;
    var e = 32 - G(b) + f;
    if (30 < e) {
      var g = f - f % 5;
      e = (d & (1 << g) - 1).toString(32);
      d >>= g;
      f -= g;
      return { id: 1 << 32 - G(b) + f | c << f | d, overflow: e + a };
    }
    return { id: 1 << e | c << f | d, overflow: a };
  }
  var G = Math.clz32 ? Math.clz32 : jb, kb = Math.log, lb = Math.LN2;
  function jb(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (kb(a) / lb | 0) | 0;
  }
  function mb(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }
  var nb = "function" === typeof Object.is ? Object.is : mb, H = null, ob = null, I = null, J = null, K = false, L = false, M = 0, N = null, O = 0;
  function P() {
    if (null === H) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
    return H;
  }
  function rb() {
    if (0 < O) throw Error("Rendered more hooks than during the previous render");
    return { memoizedState: null, queue: null, next: null };
  }
  function sb() {
    null === J ? null === I ? (K = false, I = J = rb()) : (K = true, J = I) : null === J.next ? (K = false, J = J.next = rb()) : (K = true, J = J.next);
    return J;
  }
  function tb() {
    ob = H = null;
    L = false;
    I = null;
    O = 0;
    J = N = null;
  }
  function ub(a, b) {
    return "function" === typeof b ? b(a) : b;
  }
  function vb(a, b, c) {
    H = P();
    J = sb();
    if (K) {
      var d = J.queue;
      b = d.dispatch;
      if (null !== N && (c = N.get(d), void 0 !== c)) {
        N.delete(d);
        d = J.memoizedState;
        do
          d = a(d, c.action), c = c.next;
        while (null !== c);
        J.memoizedState = d;
        return [d, b];
      }
      return [J.memoizedState, b];
    }
    a = a === ub ? "function" === typeof b ? b() : b : void 0 !== c ? c(b) : b;
    J.memoizedState = a;
    a = J.queue = { last: null, dispatch: null };
    a = a.dispatch = wb.bind(null, H, a);
    return [J.memoizedState, a];
  }
  function xb(a, b) {
    H = P();
    J = sb();
    b = void 0 === b ? null : b;
    if (null !== J) {
      var c = J.memoizedState;
      if (null !== c && null !== b) {
        var d = c[1];
        a: if (null === d) d = false;
        else {
          for (var f = 0; f < d.length && f < b.length; f++) if (!nb(b[f], d[f])) {
            d = false;
            break a;
          }
          d = true;
        }
        if (d) return c[0];
      }
    }
    a = a();
    J.memoizedState = [a, b];
    return a;
  }
  function wb(a, b, c) {
    if (25 <= O) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
    if (a === H) if (L = true, a = { action: c, next: null }, null === N && (N = /* @__PURE__ */ new Map()), c = N.get(b), void 0 === c) N.set(b, a);
    else {
      for (b = c; null !== b.next; ) b = b.next;
      b.next = a;
    }
  }
  function yb() {
    throw Error("startTransition cannot be called during server rendering.");
  }
  function Q() {
  }
  var zb = { readContext: function(a) {
    return a._currentValue2;
  }, useContext: function(a) {
    P();
    return a._currentValue2;
  }, useMemo: xb, useReducer: vb, useRef: function(a) {
    H = P();
    J = sb();
    var b = J.memoizedState;
    return null === b ? (a = { current: a }, J.memoizedState = a) : b;
  }, useState: function(a) {
    return vb(ub, a);
  }, useInsertionEffect: Q, useLayoutEffect: function() {
  }, useCallback: function(a, b) {
    return xb(function() {
      return a;
    }, b);
  }, useImperativeHandle: Q, useEffect: Q, useDebugValue: Q, useDeferredValue: function(a) {
    P();
    return a;
  }, useTransition: function() {
    P();
    return [false, yb];
  }, useId: function() {
    var a = ob.treeContext;
    var b = a.overflow;
    a = a.id;
    a = (a & ~(1 << 32 - G(a) - 1)).toString(32) + b;
    var c = R;
    if (null === c) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
    b = M++;
    a = ":" + c.idPrefix + "R" + a;
    0 < b && (a += "H" + b.toString(32));
    return a + ":";
  }, useMutableSource: function(a, b) {
    P();
    return b(a._source);
  }, useSyncExternalStore: function(a, b, c) {
    if (void 0 === c) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
    return c();
  } }, R = null, Ab = ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function Bb(a) {
    console.error(a);
    return null;
  }
  function S() {
  }
  function Cb(a, b, c, d, f, e, g, h, k) {
    var m = [], l2 = /* @__PURE__ */ new Set();
    b = { destination: null, responseState: b, progressiveChunkSize: void 0 === d ? 12800 : d, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: l2, pingedTasks: m, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === f ? Bb : f, onAllReady: void 0 === e ? S : e, onShellReady: void 0 === g ? S : g, onShellError: S, onFatalError: S };
    c = T(b, 0, null, c, false, false);
    c.parentFlushed = true;
    a = Db(b, a, null, c, l2, $a, null, hb);
    m.push(a);
    return b;
  }
  function Db(a, b, c, d, f, e, g, h) {
    a.allPendingTasks++;
    null === c ? a.pendingRootTasks++ : c.pendingTasks++;
    var k = { node: b, ping: function() {
      var b2 = a.pingedTasks;
      b2.push(k);
      1 === b2.length && Eb(a);
    }, blockedBoundary: c, blockedSegment: d, abortSet: f, legacyContext: e, context: g, treeContext: h };
    f.add(k);
    return k;
  }
  function T(a, b, c, d, f, e) {
    return { status: 0, id: -1, index: b, parentFlushed: false, chunks: [], children: [], formatContext: d, boundary: c, lastPushedText: f, textEmbedded: e };
  }
  function U(a, b) {
    a = a.onError(b);
    if (null != a && "string" !== typeof a) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
    return a;
  }
  function V(a, b) {
    var c = a.onShellError;
    c(b);
    c = a.onFatalError;
    c(b);
    null !== a.destination ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
  }
  function Fb(a, b, c, d, f) {
    H = {};
    ob = b;
    M = 0;
    for (a = c(d, f); L; ) L = false, M = 0, O += 1, J = null, a = c(d, f);
    tb();
    return a;
  }
  function Gb(a, b, c, d) {
    var f = c.render(), e = d.childContextTypes;
    if (null !== e && void 0 !== e) {
      var g = b.legacyContext;
      if ("function" !== typeof c.getChildContext) d = g;
      else {
        c = c.getChildContext();
        for (var h in c) if (!(h in e)) throw Error((Za(d) || "Unknown") + '.getChildContext(): key "' + h + '" is not defined in childContextTypes.');
        d = A({}, g, c);
      }
      b.legacyContext = d;
      W(a, b, f);
      b.legacyContext = g;
    } else W(a, b, f);
  }
  function Hb(a, b) {
    if (a && a.defaultProps) {
      b = A({}, b);
      a = a.defaultProps;
      for (var c in a) void 0 === b[c] && (b[c] = a[c]);
      return b;
    }
    return b;
  }
  function Ib(a, b, c, d, f) {
    if ("function" === typeof c) if (c.prototype && c.prototype.isReactComponent) {
      f = ab(c, b.legacyContext);
      var e = c.contextType;
      e = new c(d, "object" === typeof e && null !== e ? e._currentValue2 : f);
      gb(e, c, d, f);
      Gb(a, b, e, c);
    } else {
      e = ab(c, b.legacyContext);
      f = Fb(a, b, c, d, e);
      var g = 0 !== M;
      if ("object" === typeof f && null !== f && "function" === typeof f.render && void 0 === f.$$typeof) gb(f, c, d, e), Gb(a, b, f, c);
      else if (g) {
        d = b.treeContext;
        b.treeContext = ib(d, 1, 0);
        try {
          W(a, b, f);
        } finally {
          b.treeContext = d;
        }
      } else W(a, b, f);
    }
    else if ("string" === typeof c) {
      f = b.blockedSegment;
      e = za(f.chunks, c, d, a.responseState, f.formatContext);
      f.lastPushedText = false;
      g = f.formatContext;
      f.formatContext = sa(g, c, d);
      Jb(a, b, e);
      f.formatContext = g;
      switch (c) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          f.chunks.push("</", c, ">");
      }
      f.lastPushedText = false;
    } else {
      switch (c) {
        case Wa:
        case Va:
        case La:
        case Ma:
        case Ka:
          W(a, b, d.children);
          return;
        case Ra:
          W(a, b, d.children);
          return;
        case Ua:
          throw Error("ReactDOMServer does not yet support scope components.");
        case Qa:
          a: {
            c = b.blockedBoundary;
            f = b.blockedSegment;
            e = d.fallback;
            d = d.children;
            g = /* @__PURE__ */ new Set();
            var h = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g, errorDigest: null }, k = T(a, f.chunks.length, h, f.formatContext, false, false);
            f.children.push(k);
            f.lastPushedText = false;
            var m = T(a, 0, null, f.formatContext, false, false);
            m.parentFlushed = true;
            b.blockedBoundary = h;
            b.blockedSegment = m;
            try {
              if (Jb(a, b, d), a.responseState.generateStaticMarkup || m.lastPushedText && m.textEmbedded && m.chunks.push("<!-- -->"), m.status = 1, X(h, m), 0 === h.pendingTasks) break a;
            } catch (l2) {
              m.status = 4, h.forceClientRender = true, h.errorDigest = U(a, l2);
            } finally {
              b.blockedBoundary = c, b.blockedSegment = f;
            }
            b = Db(a, e, c, k, g, b.legacyContext, b.context, b.treeContext);
            a.pingedTasks.push(b);
          }
          return;
      }
      if ("object" === typeof c && null !== c) switch (c.$$typeof) {
        case Pa:
          d = Fb(a, b, c.render, d, f);
          if (0 !== M) {
            c = b.treeContext;
            b.treeContext = ib(c, 1, 0);
            try {
              W(a, b, d);
            } finally {
              b.treeContext = c;
            }
          } else W(a, b, d);
          return;
        case Sa:
          c = c.type;
          d = Hb(c, d);
          Ib(a, b, c, d, f);
          return;
        case Na:
          f = d.children;
          c = c._context;
          d = d.value;
          e = c._currentValue2;
          c._currentValue2 = d;
          g = D;
          D = d = { parent: g, depth: null === g ? 0 : g.depth + 1, context: c, parentValue: e, value: d };
          b.context = d;
          W(a, b, f);
          a = D;
          if (null === a) throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          d = a.parentValue;
          a.context._currentValue2 = d === Xa ? a.context._defaultValue : d;
          a = D = a.parent;
          b.context = a;
          return;
        case Oa:
          d = d.children;
          d = d(c._currentValue2);
          W(a, b, d);
          return;
        case Ta:
          f = c._init;
          c = f(c._payload);
          d = Hb(c, d);
          Ib(a, b, c, d, void 0);
          return;
      }
      throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == c ? c : typeof c) + "."));
    }
  }
  function W(a, b, c) {
    b.node = c;
    if ("object" === typeof c && null !== c) {
      switch (c.$$typeof) {
        case Ia:
          Ib(a, b, c.type, c.props, c.ref);
          return;
        case Ja:
          throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
        case Ta:
          var d = c._init;
          c = d(c._payload);
          W(a, b, c);
          return;
      }
      if (ra(c)) {
        Kb(a, b, c);
        return;
      }
      null === c || "object" !== typeof c ? d = null : (d = Ya && c[Ya] || c["@@iterator"], d = "function" === typeof d ? d : null);
      if (d && (d = d.call(c))) {
        c = d.next();
        if (!c.done) {
          var f = [];
          do
            f.push(c.value), c = d.next();
          while (!c.done);
          Kb(a, b, f);
        }
        return;
      }
      a = Object.prototype.toString.call(c);
      throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === a ? "object with keys {" + Object.keys(c).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
    }
    "string" === typeof c ? (d = b.blockedSegment, d.lastPushedText = Ha(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : "number" === typeof c && (d = b.blockedSegment, d.lastPushedText = Ha(
      b.blockedSegment.chunks,
      "" + c,
      a.responseState,
      d.lastPushedText
    ));
  }
  function Kb(a, b, c) {
    for (var d = c.length, f = 0; f < d; f++) {
      var e = b.treeContext;
      b.treeContext = ib(e, d, f);
      try {
        Jb(a, b, c[f]);
      } finally {
        b.treeContext = e;
      }
    }
  }
  function Jb(a, b, c) {
    var d = b.blockedSegment.formatContext, f = b.legacyContext, e = b.context;
    try {
      return W(a, b, c);
    } catch (k) {
      if (tb(), "object" === typeof k && null !== k && "function" === typeof k.then) {
        c = k;
        var g = b.blockedSegment, h = T(a, g.chunks.length, null, g.formatContext, g.lastPushedText, true);
        g.children.push(h);
        g.lastPushedText = false;
        a = Db(a, b.node, b.blockedBoundary, h, b.abortSet, b.legacyContext, b.context, b.treeContext).ping;
        c.then(a, a);
        b.blockedSegment.formatContext = d;
        b.legacyContext = f;
        b.context = e;
        F(e);
      } else throw b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, F(e), k;
    }
  }
  function Lb(a) {
    var b = a.blockedBoundary;
    a = a.blockedSegment;
    a.status = 3;
    Mb(this, b, a);
  }
  function Nb(a, b, c) {
    var d = a.blockedBoundary;
    a.blockedSegment.status = 3;
    null === d ? (b.allPendingTasks--, 2 !== b.status && (b.status = 2, null !== b.destination && b.destination.push(null))) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = true, d.errorDigest = b.onError(void 0 === c ? Error("The render was aborted by the server without a reason.") : c), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(a2) {
      return Nb(a2, b, c);
    }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, 0 === b.allPendingTasks && (a = b.onAllReady, a()));
  }
  function X(a, b) {
    if (0 === b.chunks.length && 1 === b.children.length && null === b.children[0].boundary) {
      var c = b.children[0];
      c.id = b.id;
      c.parentFlushed = true;
      1 === c.status && X(a, c);
    } else a.completedSegments.push(b);
  }
  function Mb(a, b, c) {
    if (null === b) {
      if (c.parentFlushed) {
        if (null !== a.completedRootSegment) throw Error("There can only be one root segment. This is a bug in React.");
        a.completedRootSegment = c;
      }
      a.pendingRootTasks--;
      0 === a.pendingRootTasks && (a.onShellError = S, b = a.onShellReady, b());
    } else b.pendingTasks--, b.forceClientRender || (0 === b.pendingTasks ? (c.parentFlushed && 1 === c.status && X(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(Lb, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && 1 === c.status && (X(b, c), 1 === b.completedSegments.length && b.parentFlushed && a.partialBoundaries.push(b)));
    a.allPendingTasks--;
    0 === a.allPendingTasks && (a = a.onAllReady, a());
  }
  function Eb(a) {
    if (2 !== a.status) {
      var b = D, c = Ab.current;
      Ab.current = zb;
      var d = R;
      R = a.responseState;
      try {
        var f = a.pingedTasks, e;
        for (e = 0; e < f.length; e++) {
          var g = f[e];
          var h = a, k = g.blockedSegment;
          if (0 === k.status) {
            F(g.context);
            try {
              W(h, g, g.node), h.responseState.generateStaticMarkup || k.lastPushedText && k.textEmbedded && k.chunks.push("<!-- -->"), g.abortSet.delete(g), k.status = 1, Mb(h, g.blockedBoundary, k);
            } catch (y) {
              if (tb(), "object" === typeof y && null !== y && "function" === typeof y.then) {
                var m = g.ping;
                y.then(m, m);
              } else {
                g.abortSet.delete(g);
                k.status = 4;
                var l2 = g.blockedBoundary, p = y, B = U(h, p);
                null === l2 ? V(h, p) : (l2.pendingTasks--, l2.forceClientRender || (l2.forceClientRender = true, l2.errorDigest = B, l2.parentFlushed && h.clientRenderedBoundaries.push(l2)));
                h.allPendingTasks--;
                if (0 === h.allPendingTasks) {
                  var C = h.onAllReady;
                  C();
                }
              }
            } finally {
            }
          }
        }
        f.splice(0, e);
        null !== a.destination && Ob(a, a.destination);
      } catch (y) {
        U(a, y), V(a, y);
      } finally {
        R = d, Ab.current = c, c === zb && F(b);
      }
    }
  }
  function Y(a, b, c) {
    c.parentFlushed = true;
    switch (c.status) {
      case 0:
        var d = c.id = a.nextSegmentId++;
        c.lastPushedText = false;
        c.textEmbedded = false;
        a = a.responseState;
        b.push('<template id="');
        b.push(a.placeholderPrefix);
        a = d.toString(16);
        b.push(a);
        return b.push('"></template>');
      case 1:
        c.status = 2;
        var f = true;
        d = c.chunks;
        var e = 0;
        c = c.children;
        for (var g = 0; g < c.length; g++) {
          for (f = c[g]; e < f.index; e++) b.push(d[e]);
          f = Z(a, b, f);
        }
        for (; e < d.length - 1; e++) b.push(d[e]);
        e < d.length && (f = b.push(d[e]));
        return f;
      default:
        throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
    }
  }
  function Z(a, b, c) {
    var d = c.boundary;
    if (null === d) return Y(a, b, c);
    d.parentFlushed = true;
    if (d.forceClientRender) return a.responseState.generateStaticMarkup || (d = d.errorDigest, b.push("<!--$!-->"), b.push("<template"), d && (b.push(' data-dgst="'), d = u(d), b.push(d), b.push('"')), b.push("></template>")), Y(a, b, c), a = a.responseState.generateStaticMarkup ? true : b.push("<!--/$-->"), a;
    if (0 < d.pendingTasks) {
      d.rootSegmentID = a.nextSegmentId++;
      0 < d.completedSegments.length && a.partialBoundaries.push(d);
      var f = a.responseState;
      var e = f.nextSuspenseID++;
      f = f.boundaryPrefix + e.toString(16);
      d = d.id = f;
      Aa(b, a.responseState, d);
      Y(a, b, c);
      return b.push("<!--/$-->");
    }
    if (d.byteSize > a.progressiveChunkSize) return d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), Aa(b, a.responseState, d.id), Y(a, b, c), b.push("<!--/$-->");
    a.responseState.generateStaticMarkup || b.push("<!--$-->");
    c = d.completedSegments;
    if (1 !== c.length) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
    Z(a, b, c[0]);
    a = a.responseState.generateStaticMarkup ? true : b.push("<!--/$-->");
    return a;
  }
  function Pb(a, b, c) {
    Ba(b, a.responseState, c.formatContext, c.id);
    Z(a, b, c);
    return Ca(b, c.formatContext);
  }
  function Qb(a, b, c) {
    for (var d = c.completedSegments, f = 0; f < d.length; f++) Rb(a, b, c, d[f]);
    d.length = 0;
    a = a.responseState;
    d = c.id;
    c = c.rootSegmentID;
    b.push(a.startInlineScript);
    a.sentCompleteBoundaryFunction ? b.push('$RC("') : (a.sentCompleteBoundaryFunction = true, b.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'));
    if (null === d) throw Error("An ID must have been assigned before we can complete the boundary.");
    c = c.toString(16);
    b.push(d);
    b.push('","');
    b.push(a.segmentPrefix);
    b.push(c);
    return b.push('")<\/script>');
  }
  function Rb(a, b, c, d) {
    if (2 === d.status) return true;
    var f = d.id;
    if (-1 === f) {
      if (-1 === (d.id = c.rootSegmentID)) throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
      return Pb(a, b, d);
    }
    Pb(a, b, d);
    a = a.responseState;
    b.push(a.startInlineScript);
    a.sentCompleteSegmentFunction ? b.push('$RS("') : (a.sentCompleteSegmentFunction = true, b.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'));
    b.push(a.segmentPrefix);
    f = f.toString(16);
    b.push(f);
    b.push('","');
    b.push(a.placeholderPrefix);
    b.push(f);
    return b.push('")<\/script>');
  }
  function Ob(a, b) {
    try {
      var c = a.completedRootSegment;
      if (null !== c && 0 === a.pendingRootTasks) {
        Z(a, b, c);
        a.completedRootSegment = null;
        var d = a.responseState.bootstrapChunks;
        for (c = 0; c < d.length - 1; c++) b.push(d[c]);
        c < d.length && b.push(d[c]);
      }
      var f = a.clientRenderedBoundaries, e;
      for (e = 0; e < f.length; e++) {
        var g = f[e];
        d = b;
        var h = a.responseState, k = g.id, m = g.errorDigest, l2 = g.errorMessage, p = g.errorComponentStack;
        d.push(h.startInlineScript);
        h.sentClientRenderFunction ? d.push('$RX("') : (h.sentClientRenderFunction = true, d.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'));
        if (null === k) throw Error("An ID must have been assigned before we can complete the boundary.");
        d.push(k);
        d.push('"');
        if (m || l2 || p) {
          d.push(",");
          var B = Ea(m || "");
          d.push(B);
        }
        if (l2 || p) {
          d.push(",");
          var C = Ea(l2 || "");
          d.push(C);
        }
        if (p) {
          d.push(",");
          var y = Ea(p);
          d.push(y);
        }
        if (!d.push(")<\/script>")) {
          a.destination = null;
          e++;
          f.splice(0, e);
          return;
        }
      }
      f.splice(0, e);
      var aa = a.completedBoundaries;
      for (e = 0; e < aa.length; e++) if (!Qb(a, b, aa[e])) {
        a.destination = null;
        e++;
        aa.splice(0, e);
        return;
      }
      aa.splice(0, e);
      var ba = a.partialBoundaries;
      for (e = 0; e < ba.length; e++) {
        var pb = ba[e];
        a: {
          f = a;
          g = b;
          var ca = pb.completedSegments;
          for (h = 0; h < ca.length; h++) if (!Rb(f, g, pb, ca[h])) {
            h++;
            ca.splice(0, h);
            var qb = false;
            break a;
          }
          ca.splice(0, h);
          qb = true;
        }
        if (!qb) {
          a.destination = null;
          e++;
          ba.splice(0, e);
          return;
        }
      }
      ba.splice(0, e);
      var da = a.completedBoundaries;
      for (e = 0; e < da.length; e++) if (!Qb(a, b, da[e])) {
        a.destination = null;
        e++;
        da.splice(0, e);
        return;
      }
      da.splice(0, e);
    } finally {
      0 === a.allPendingTasks && 0 === a.pingedTasks.length && 0 === a.clientRenderedBoundaries.length && 0 === a.completedBoundaries.length && b.push(null);
    }
  }
  function Sb(a, b) {
    if (1 === a.status) a.status = 2, b.destroy(a.fatalError);
    else if (2 !== a.status && null === a.destination) {
      a.destination = b;
      try {
        Ob(a, b);
      } catch (c) {
        U(a, c), V(a, c);
      }
    }
  }
  function Tb(a, b) {
    try {
      var c = a.abortableTasks;
      c.forEach(function(c2) {
        return Nb(c2, a, b);
      });
      c.clear();
      null !== a.destination && Ob(a, a.destination);
    } catch (d) {
      U(a, d), V(a, d);
    }
  }
  function Ub() {
  }
  function Vb(a, b, c, d) {
    var f = false, e = null, g = "", h = false;
    a = Cb(a, Fa(c, b ? b.identifierPrefix : void 0), Ga(), Infinity, Ub, void 0, function() {
      h = true;
    });
    Eb(a);
    Tb(a, d);
    Sb(a, { push: function(a2) {
      null !== a2 && (g += a2);
      return true;
    }, destroy: function(a2) {
      f = true;
      e = a2;
    } });
    if (f) throw e;
    if (!h) throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
    return g;
  }
  function Wb(a, b) {
    a.prototype = Object.create(b.prototype);
    a.prototype.constructor = a;
    a.__proto__ = b;
  }
  var Xb = function(a) {
    function b() {
      var b2 = a.call(this, {}) || this;
      b2.request = null;
      b2.startedFlowing = false;
      return b2;
    }
    Wb(b, a);
    var c = b.prototype;
    c._destroy = function(a2, b2) {
      Tb(this.request);
      b2(a2);
    };
    c._read = function() {
      this.startedFlowing && Sb(this.request, this);
    };
    return b;
  }(fa.Readable);
  function Yb() {
  }
  function Zb(a, b) {
    var c = new Xb(), d = Cb(a, Fa(false, b ? b.identifierPrefix : void 0), Ga(), Infinity, Yb, function() {
      c.startedFlowing = true;
      Sb(d, c);
    }, void 0);
    c.request = d;
    Eb(d);
    return c;
  }
  reactDomServerLegacy_node_production_min.renderToNodeStream = function(a, b) {
    return Zb(a, b);
  };
  reactDomServerLegacy_node_production_min.renderToStaticMarkup = function(a, b) {
    return Vb(a, b, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
  };
  reactDomServerLegacy_node_production_min.renderToStaticNodeStream = function(a, b) {
    return Zb(a, b);
  };
  reactDomServerLegacy_node_production_min.renderToString = function(a, b) {
    return Vb(a, b, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
  };
  reactDomServerLegacy_node_production_min.version = "18.3.1";
  return reactDomServerLegacy_node_production_min;
}
var reactDomServer_node_production_min = {};
/**
 * @license React
 * react-dom-server.node.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDomServer_node_production_min;
function requireReactDomServer_node_production_min() {
  if (hasRequiredReactDomServer_node_production_min) return reactDomServer_node_production_min;
  hasRequiredReactDomServer_node_production_min = 1;
  var aa = require$$0, ba = requireReact(), k = null, l2 = 0, q = true;
  function r2(a, b) {
    if ("string" === typeof b) {
      if (0 !== b.length) if (2048 < 3 * b.length) 0 < l2 && (t(a, k.subarray(0, l2)), k = new Uint8Array(2048), l2 = 0), t(a, u.encode(b));
      else {
        var c = k;
        0 < l2 && (c = k.subarray(l2));
        c = u.encodeInto(b, c);
        var d = c.read;
        l2 += c.written;
        d < b.length && (t(a, k), k = new Uint8Array(2048), l2 = u.encodeInto(b.slice(d), k).written);
        2048 === l2 && (t(a, k), k = new Uint8Array(2048), l2 = 0);
      }
    } else 0 !== b.byteLength && (2048 < b.byteLength ? (0 < l2 && (t(a, k.subarray(0, l2)), k = new Uint8Array(2048), l2 = 0), t(a, b)) : (c = k.length - l2, c < b.byteLength && (0 === c ? t(
      a,
      k
    ) : (k.set(b.subarray(0, c), l2), l2 += c, t(a, k), b = b.subarray(c)), k = new Uint8Array(2048), l2 = 0), k.set(b, l2), l2 += b.byteLength, 2048 === l2 && (t(a, k), k = new Uint8Array(2048), l2 = 0)));
  }
  function t(a, b) {
    a = a.write(b);
    q = q && a;
  }
  function w(a, b) {
    r2(a, b);
    return q;
  }
  function ca(a) {
    k && 0 < l2 && a.write(k.subarray(0, l2));
    k = null;
    l2 = 0;
    q = true;
  }
  var u = new aa.TextEncoder();
  function x(a) {
    return u.encode(a);
  }
  var y = Object.prototype.hasOwnProperty, da = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ea = {}, fa = {};
  function ha(a) {
    if (y.call(fa, a)) return true;
    if (y.call(ea, a)) return false;
    if (da.test(a)) return fa[a] = true;
    ea[a] = true;
    return false;
  }
  function z(a, b, c, d, f, e, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = f;
    this.mustUseProperty = c;
    this.propertyName = a;
    this.type = b;
    this.sanitizeURL = e;
    this.removeEmptyString = g;
  }
  var A = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    A[a] = new z(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b = a[0];
    A[b] = new z(b, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    A[a] = new z(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    A[a] = new z(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    A[a] = new z(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    A[a] = new z(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    A[a] = new z(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    A[a] = new z(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    A[a] = new z(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var ia = /[\-:]([a-z])/g;
  function ja(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b = a.replace(
      ia,
      ja
    );
    A[b] = new z(b, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b = a.replace(ia, ja);
    A[b] = new z(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b = a.replace(ia, ja);
    A[b] = new z(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    A[a] = new z(a, 1, false, a.toLowerCase(), null, false, false);
  });
  A.xlinkHref = new z("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    A[a] = new z(a, 1, false, a.toLowerCase(), null, true, true);
  });
  var B = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, ka = ["Webkit", "ms", "Moz", "O"];
  Object.keys(B).forEach(function(a) {
    ka.forEach(function(b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1);
      B[b] = B[a];
    });
  });
  var la = /["'&<>]/;
  function F(a) {
    if ("boolean" === typeof a || "number" === typeof a) return "" + a;
    a = "" + a;
    var b = la.exec(a);
    if (b) {
      var c = "", d, f = 0;
      for (d = b.index; d < a.length; d++) {
        switch (a.charCodeAt(d)) {
          case 34:
            b = "&quot;";
            break;
          case 38:
            b = "&amp;";
            break;
          case 39:
            b = "&#x27;";
            break;
          case 60:
            b = "&lt;";
            break;
          case 62:
            b = "&gt;";
            break;
          default:
            continue;
        }
        f !== d && (c += a.substring(f, d));
        f = d + 1;
        c += b;
      }
      a = f !== d ? c + a.substring(f, d) : c;
    }
    return a;
  }
  var ma = /([A-Z])/g, pa = /^ms-/, qa = Array.isArray, ra = x("<script>"), sa = x("<\/script>"), ta = x('<script src="'), ua = x('<script type="module" src="'), va = x('" async=""><\/script>'), wa = /(<\/|<)(s)(cript)/gi;
  function xa(a, b, c, d) {
    return "" + b + ("s" === c ? "\\u0073" : "\\u0053") + d;
  }
  function G(a, b) {
    return { insertionMode: a, selectedValue: b };
  }
  function ya(a, b, c) {
    switch (b) {
      case "select":
        return G(1, null != c.value ? c.value : c.defaultValue);
      case "svg":
        return G(2, null);
      case "math":
        return G(3, null);
      case "foreignObject":
        return G(1, null);
      case "table":
        return G(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return G(5, null);
      case "colgroup":
        return G(7, null);
      case "tr":
        return G(6, null);
    }
    return 4 <= a.insertionMode || 0 === a.insertionMode ? G(1, null) : a;
  }
  var za = x("<!-- -->");
  function Aa(a, b, c, d) {
    if ("" === b) return d;
    d && a.push(za);
    a.push(F(b));
    return true;
  }
  var Ba = /* @__PURE__ */ new Map(), Ca = x(' style="'), Da = x(":"), Ea = x(";");
  function Fa(a, b, c) {
    if ("object" !== typeof c) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
    b = true;
    for (var d in c) if (y.call(c, d)) {
      var f = c[d];
      if (null != f && "boolean" !== typeof f && "" !== f) {
        if (0 === d.indexOf("--")) {
          var e = F(d);
          f = F(("" + f).trim());
        } else {
          e = d;
          var g = Ba.get(e);
          void 0 !== g ? e = g : (g = x(F(e.replace(ma, "-$1").toLowerCase().replace(pa, "-ms-"))), Ba.set(e, g), e = g);
          f = "number" === typeof f ? 0 === f || y.call(
            B,
            d
          ) ? "" + f : f + "px" : F(("" + f).trim());
        }
        b ? (b = false, a.push(Ca, e, Da, f)) : a.push(Ea, e, Da, f);
      }
    }
    b || a.push(H);
  }
  var I = x(" "), J = x('="'), H = x('"'), Ga = x('=""');
  function K(a, b, c, d) {
    switch (c) {
      case "style":
        Fa(a, b, d);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < c.length) || "o" !== c[0] && "O" !== c[0] || "n" !== c[1] && "N" !== c[1]) {
      if (b = A.hasOwnProperty(c) ? A[c] : null, null !== b) {
        switch (typeof d) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!b.acceptsBooleans) return;
        }
        c = b.attributeName;
        switch (b.type) {
          case 3:
            d && a.push(I, c, Ga);
            break;
          case 4:
            true === d ? a.push(I, c, Ga) : false !== d && a.push(I, c, J, F(d), H);
            break;
          case 5:
            isNaN(d) || a.push(I, c, J, F(d), H);
            break;
          case 6:
            !isNaN(d) && 1 <= d && a.push(I, c, J, F(d), H);
            break;
          default:
            b.sanitizeURL && (d = "" + d), a.push(I, c, J, F(d), H);
        }
      } else if (ha(c)) {
        switch (typeof d) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (b = c.toLowerCase().slice(0, 5), "data-" !== b && "aria-" !== b) return;
        }
        a.push(I, c, J, F(d), H);
      }
    }
  }
  var L = x(">"), Ha = x("/>");
  function M(a, b, c) {
    if (null != b) {
      if (null != c) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
      if ("object" !== typeof b || !("__html" in b)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
      b = b.__html;
      null !== b && void 0 !== b && a.push("" + b);
    }
  }
  function Ia(a) {
    var b = "";
    ba.Children.forEach(a, function(a2) {
      null != a2 && (b += a2);
    });
    return b;
  }
  var Ja = x(' selected=""');
  function Ka(a, b, c, d) {
    a.push(N(c));
    var f = c = null, e;
    for (e in b) if (y.call(b, e)) {
      var g = b[e];
      if (null != g) switch (e) {
        case "children":
          c = g;
          break;
        case "dangerouslySetInnerHTML":
          f = g;
          break;
        default:
          K(a, d, e, g);
      }
    }
    a.push(L);
    M(a, f, c);
    return "string" === typeof c ? (a.push(F(c)), null) : c;
  }
  var La = x("\n"), Ma = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Na = /* @__PURE__ */ new Map();
  function N(a) {
    var b = Na.get(a);
    if (void 0 === b) {
      if (!Ma.test(a)) throw Error("Invalid tag: " + a);
      b = x("<" + a);
      Na.set(a, b);
    }
    return b;
  }
  var Oa = x("<!DOCTYPE html>");
  function Pa(a, b, c, d, f) {
    switch (b) {
      case "select":
        a.push(N("select"));
        var e = null, g = null;
        for (p in c) if (y.call(c, p)) {
          var h = c[p];
          if (null != h) switch (p) {
            case "children":
              e = h;
              break;
            case "dangerouslySetInnerHTML":
              g = h;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              K(a, d, p, h);
          }
        }
        a.push(L);
        M(a, g, e);
        return e;
      case "option":
        g = f.selectedValue;
        a.push(N("option"));
        var m = h = null, n = null;
        var p = null;
        for (e in c) if (y.call(c, e)) {
          var v = c[e];
          if (null != v) switch (e) {
            case "children":
              h = v;
              break;
            case "selected":
              n = v;
              break;
            case "dangerouslySetInnerHTML":
              p = v;
              break;
            case "value":
              m = v;
            default:
              K(a, d, e, v);
          }
        }
        if (null != g) if (c = null !== m ? "" + m : Ia(h), qa(g)) for (d = 0; d < g.length; d++) {
          if ("" + g[d] === c) {
            a.push(Ja);
            break;
          }
        }
        else "" + g === c && a.push(Ja);
        else n && a.push(Ja);
        a.push(L);
        M(a, p, h);
        return h;
      case "textarea":
        a.push(N("textarea"));
        p = g = e = null;
        for (h in c) if (y.call(c, h) && (m = c[h], null != m)) switch (h) {
          case "children":
            p = m;
            break;
          case "value":
            e = m;
            break;
          case "defaultValue":
            g = m;
            break;
          case "dangerouslySetInnerHTML":
            throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
          default:
            K(a, d, h, m);
        }
        null === e && null !== g && (e = g);
        a.push(L);
        if (null != p) {
          if (null != e) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (qa(p) && 1 < p.length) throw Error("<textarea> can only have at most one child.");
          e = "" + p;
        }
        "string" === typeof e && "\n" === e[0] && a.push(La);
        null !== e && a.push(F("" + e));
        return null;
      case "input":
        a.push(N("input"));
        m = p = h = e = null;
        for (g in c) if (y.call(c, g) && (n = c[g], null != n)) switch (g) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          case "defaultChecked":
            m = n;
            break;
          case "defaultValue":
            h = n;
            break;
          case "checked":
            p = n;
            break;
          case "value":
            e = n;
            break;
          default:
            K(a, d, g, n);
        }
        null !== p ? K(a, d, "checked", p) : null !== m && K(a, d, "checked", m);
        null !== e ? K(a, d, "value", e) : null !== h && K(a, d, "value", h);
        a.push(Ha);
        return null;
      case "menuitem":
        a.push(N("menuitem"));
        for (var C in c) if (y.call(c, C) && (e = c[C], null != e)) switch (C) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
          default:
            K(a, d, C, e);
        }
        a.push(L);
        return null;
      case "title":
        a.push(N("title"));
        e = null;
        for (v in c) if (y.call(c, v) && (g = c[v], null != g)) switch (v) {
          case "children":
            e = g;
            break;
          case "dangerouslySetInnerHTML":
            throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
          default:
            K(a, d, v, g);
        }
        a.push(L);
        return e;
      case "listing":
      case "pre":
        a.push(N(b));
        g = e = null;
        for (m in c) if (y.call(c, m) && (h = c[m], null != h)) switch (m) {
          case "children":
            e = h;
            break;
          case "dangerouslySetInnerHTML":
            g = h;
            break;
          default:
            K(a, d, m, h);
        }
        a.push(L);
        if (null != g) {
          if (null != e) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if ("object" !== typeof g || !("__html" in g)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          c = g.__html;
          null !== c && void 0 !== c && ("string" === typeof c && 0 < c.length && "\n" === c[0] ? a.push(La, c) : a.push("" + c));
        }
        "string" === typeof e && "\n" === e[0] && a.push(La);
        return e;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        a.push(N(b));
        for (var D in c) if (y.call(c, D) && (e = c[D], null != e)) switch (D) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(b + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          default:
            K(a, d, D, e);
        }
        a.push(Ha);
        return null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return Ka(a, c, b, d);
      case "html":
        return 0 === f.insertionMode && a.push(Oa), Ka(
          a,
          c,
          b,
          d
        );
      default:
        if (-1 === b.indexOf("-") && "string" !== typeof c.is) return Ka(a, c, b, d);
        a.push(N(b));
        g = e = null;
        for (n in c) if (y.call(c, n) && (h = c[n], null != h)) switch (n) {
          case "children":
            e = h;
            break;
          case "dangerouslySetInnerHTML":
            g = h;
            break;
          case "style":
            Fa(a, d, h);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            break;
          default:
            ha(n) && "function" !== typeof h && "symbol" !== typeof h && a.push(I, n, J, F(h), H);
        }
        a.push(L);
        M(a, g, e);
        return e;
    }
  }
  var Qa = x("</"), Ra = x(">"), Sa = x('<template id="'), Ta = x('"></template>'), Ua = x("<!--$-->"), Va = x('<!--$?--><template id="'), Wa = x('"></template>'), Xa = x("<!--$!-->"), Ya = x("<!--/$-->"), Za = x("<template"), $a = x('"'), ab = x(' data-dgst="');
  x(' data-msg="');
  x(' data-stck="');
  var bb = x("></template>");
  function cb(a, b, c) {
    r2(a, Va);
    if (null === c) throw Error("An ID must have been assigned before we can complete the boundary.");
    r2(a, c);
    return w(a, Wa);
  }
  var db = x('<div hidden id="'), eb = x('">'), fb = x("</div>"), gb = x('<svg aria-hidden="true" style="display:none" id="'), hb = x('">'), ib = x("</svg>"), jb = x('<math aria-hidden="true" style="display:none" id="'), kb = x('">'), lb = x("</math>"), mb = x('<table hidden id="'), nb = x('">'), ob = x("</table>"), pb = x('<table hidden><tbody id="'), qb = x('">'), rb = x("</tbody></table>"), sb = x('<table hidden><tr id="'), tb = x('">'), ub = x("</tr></table>"), vb = x('<table hidden><colgroup id="'), wb = x('">'), xb = x("</colgroup></table>");
  function yb(a, b, c, d) {
    switch (c.insertionMode) {
      case 0:
      case 1:
        return r2(a, db), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, eb);
      case 2:
        return r2(a, gb), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, hb);
      case 3:
        return r2(a, jb), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, kb);
      case 4:
        return r2(a, mb), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, nb);
      case 5:
        return r2(a, pb), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, qb);
      case 6:
        return r2(a, sb), r2(a, b.segmentPrefix), r2(a, d.toString(16)), w(a, tb);
      case 7:
        return r2(a, vb), r2(
          a,
          b.segmentPrefix
        ), r2(a, d.toString(16)), w(a, wb);
      default:
        throw Error("Unknown insertion mode. This is a bug in React.");
    }
  }
  function zb(a, b) {
    switch (b.insertionMode) {
      case 0:
      case 1:
        return w(a, fb);
      case 2:
        return w(a, ib);
      case 3:
        return w(a, lb);
      case 4:
        return w(a, ob);
      case 5:
        return w(a, rb);
      case 6:
        return w(a, ub);
      case 7:
        return w(a, xb);
      default:
        throw Error("Unknown insertion mode. This is a bug in React.");
    }
  }
  var Ab = x('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Bb = x('$RS("'), Cb = x('","'), Db = x('")<\/script>'), Fb = x('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Gb = x('$RC("'), Hb = x('","'), Ib = x('")<\/script>'), Jb = x('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Kb = x('$RX("'), Lb = x('"'), Mb = x(")<\/script>"), Nb = x(","), Ob = /[<\u2028\u2029]/g;
  function Pb(a) {
    return JSON.stringify(a).replace(Ob, function(a2) {
      switch (a2) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var O = Object.assign, Qb = Symbol.for("react.element"), Rb = Symbol.for("react.portal"), Sb = Symbol.for("react.fragment"), Tb = Symbol.for("react.strict_mode"), Ub = Symbol.for("react.profiler"), Vb = Symbol.for("react.provider"), Wb = Symbol.for("react.context"), Xb = Symbol.for("react.forward_ref"), Yb = Symbol.for("react.suspense"), Zb = Symbol.for("react.suspense_list"), $b = Symbol.for("react.memo"), ac = Symbol.for("react.lazy"), bc = Symbol.for("react.scope"), cc = Symbol.for("react.debug_trace_mode"), dc = Symbol.for("react.legacy_hidden"), ec = Symbol.for("react.default_value"), fc = Symbol.iterator;
  function gc(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch (a) {
      case Sb:
        return "Fragment";
      case Rb:
        return "Portal";
      case Ub:
        return "Profiler";
      case Tb:
        return "StrictMode";
      case Yb:
        return "Suspense";
      case Zb:
        return "SuspenseList";
    }
    if ("object" === typeof a) switch (a.$$typeof) {
      case Wb:
        return (a.displayName || "Context") + ".Consumer";
      case Vb:
        return (a._context.displayName || "Context") + ".Provider";
      case Xb:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case $b:
        return b = a.displayName || null, null !== b ? b : gc(a.type) || "Memo";
      case ac:
        b = a._payload;
        a = a._init;
        try {
          return gc(a(b));
        } catch (c) {
        }
    }
    return null;
  }
  var hc = {};
  function ic(a, b) {
    a = a.contextTypes;
    if (!a) return hc;
    var c = {}, d;
    for (d in a) c[d] = b[d];
    return c;
  }
  var P = null;
  function Q(a, b) {
    if (a !== b) {
      a.context._currentValue = a.parentValue;
      a = a.parent;
      var c = b.parent;
      if (null === a) {
        if (null !== c) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
      } else {
        if (null === c) throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        Q(a, c);
      }
      b.context._currentValue = b.value;
    }
  }
  function jc(a) {
    a.context._currentValue = a.parentValue;
    a = a.parent;
    null !== a && jc(a);
  }
  function kc(a) {
    var b = a.parent;
    null !== b && kc(b);
    a.context._currentValue = a.value;
  }
  function lc(a, b) {
    a.context._currentValue = a.parentValue;
    a = a.parent;
    if (null === a) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
    a.depth === b.depth ? Q(a, b) : lc(a, b);
  }
  function mc(a, b) {
    var c = b.parent;
    if (null === c) throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
    a.depth === c.depth ? Q(a, c) : mc(a, c);
    b.context._currentValue = b.value;
  }
  function nc(a) {
    var b = P;
    b !== a && (null === b ? kc(a) : null === a ? jc(b) : b.depth === a.depth ? Q(b, a) : b.depth > a.depth ? lc(b, a) : mc(b, a), P = a);
  }
  var oc = { isMounted: function() {
    return false;
  }, enqueueSetState: function(a, b) {
    a = a._reactInternals;
    null !== a.queue && a.queue.push(b);
  }, enqueueReplaceState: function(a, b) {
    a = a._reactInternals;
    a.replace = true;
    a.queue = [b];
  }, enqueueForceUpdate: function() {
  } };
  function pc(a, b, c, d) {
    var f = void 0 !== a.state ? a.state : null;
    a.updater = oc;
    a.props = c;
    a.state = f;
    var e = { queue: [], replace: false };
    a._reactInternals = e;
    var g = b.contextType;
    a.context = "object" === typeof g && null !== g ? g._currentValue : d;
    g = b.getDerivedStateFromProps;
    "function" === typeof g && (g = g(c, f), f = null === g || void 0 === g ? f : O({}, f, g), a.state = f);
    if ("function" !== typeof b.getDerivedStateFromProps && "function" !== typeof a.getSnapshotBeforeUpdate && ("function" === typeof a.UNSAFE_componentWillMount || "function" === typeof a.componentWillMount)) if (b = a.state, "function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount(), b !== a.state && oc.enqueueReplaceState(a, a.state, null), null !== e.queue && 0 < e.queue.length) if (b = e.queue, g = e.replace, e.queue = null, e.replace = false, g && 1 === b.length) a.state = b[0];
    else {
      e = g ? b[0] : a.state;
      f = true;
      for (g = g ? 1 : 0; g < b.length; g++) {
        var h = b[g];
        h = "function" === typeof h ? h.call(a, e, c, d) : h;
        null != h && (f ? (f = false, e = O({}, e, h)) : O(e, h));
      }
      a.state = e;
    }
    else e.queue = null;
  }
  var qc = { id: 1, overflow: "" };
  function rc(a, b, c) {
    var d = a.id;
    a = a.overflow;
    var f = 32 - sc(d) - 1;
    d &= ~(1 << f);
    c += 1;
    var e = 32 - sc(b) + f;
    if (30 < e) {
      var g = f - f % 5;
      e = (d & (1 << g) - 1).toString(32);
      d >>= g;
      f -= g;
      return { id: 1 << 32 - sc(b) + f | c << f | d, overflow: e + a };
    }
    return { id: 1 << e | c << f | d, overflow: a };
  }
  var sc = Math.clz32 ? Math.clz32 : tc, uc = Math.log, vc = Math.LN2;
  function tc(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (uc(a) / vc | 0) | 0;
  }
  function wc(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }
  var xc = "function" === typeof Object.is ? Object.is : wc, R = null, yc = null, zc = null, S = null, T = false, Ac = false, U = 0, V = null, Bc = 0;
  function W() {
    if (null === R) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
    return R;
  }
  function Cc() {
    if (0 < Bc) throw Error("Rendered more hooks than during the previous render");
    return { memoizedState: null, queue: null, next: null };
  }
  function Dc() {
    null === S ? null === zc ? (T = false, zc = S = Cc()) : (T = true, S = zc) : null === S.next ? (T = false, S = S.next = Cc()) : (T = true, S = S.next);
    return S;
  }
  function Ec() {
    yc = R = null;
    Ac = false;
    zc = null;
    Bc = 0;
    S = V = null;
  }
  function Fc(a, b) {
    return "function" === typeof b ? b(a) : b;
  }
  function Gc(a, b, c) {
    R = W();
    S = Dc();
    if (T) {
      var d = S.queue;
      b = d.dispatch;
      if (null !== V && (c = V.get(d), void 0 !== c)) {
        V.delete(d);
        d = S.memoizedState;
        do
          d = a(d, c.action), c = c.next;
        while (null !== c);
        S.memoizedState = d;
        return [d, b];
      }
      return [S.memoizedState, b];
    }
    a = a === Fc ? "function" === typeof b ? b() : b : void 0 !== c ? c(b) : b;
    S.memoizedState = a;
    a = S.queue = { last: null, dispatch: null };
    a = a.dispatch = Hc.bind(null, R, a);
    return [S.memoizedState, a];
  }
  function Ic(a, b) {
    R = W();
    S = Dc();
    b = void 0 === b ? null : b;
    if (null !== S) {
      var c = S.memoizedState;
      if (null !== c && null !== b) {
        var d = c[1];
        a: if (null === d) d = false;
        else {
          for (var f = 0; f < d.length && f < b.length; f++) if (!xc(b[f], d[f])) {
            d = false;
            break a;
          }
          d = true;
        }
        if (d) return c[0];
      }
    }
    a = a();
    S.memoizedState = [a, b];
    return a;
  }
  function Hc(a, b, c) {
    if (25 <= Bc) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
    if (a === R) if (Ac = true, a = { action: c, next: null }, null === V && (V = /* @__PURE__ */ new Map()), c = V.get(b), void 0 === c) V.set(b, a);
    else {
      for (b = c; null !== b.next; ) b = b.next;
      b.next = a;
    }
  }
  function Jc() {
    throw Error("startTransition cannot be called during server rendering.");
  }
  function Kc() {
  }
  var Mc = { readContext: function(a) {
    return a._currentValue;
  }, useContext: function(a) {
    W();
    return a._currentValue;
  }, useMemo: Ic, useReducer: Gc, useRef: function(a) {
    R = W();
    S = Dc();
    var b = S.memoizedState;
    return null === b ? (a = { current: a }, S.memoizedState = a) : b;
  }, useState: function(a) {
    return Gc(Fc, a);
  }, useInsertionEffect: Kc, useLayoutEffect: function() {
  }, useCallback: function(a, b) {
    return Ic(function() {
      return a;
    }, b);
  }, useImperativeHandle: Kc, useEffect: Kc, useDebugValue: Kc, useDeferredValue: function(a) {
    W();
    return a;
  }, useTransition: function() {
    W();
    return [false, Jc];
  }, useId: function() {
    var a = yc.treeContext;
    var b = a.overflow;
    a = a.id;
    a = (a & ~(1 << 32 - sc(a) - 1)).toString(32) + b;
    var c = Lc;
    if (null === c) throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
    b = U++;
    a = ":" + c.idPrefix + "R" + a;
    0 < b && (a += "H" + b.toString(32));
    return a + ":";
  }, useMutableSource: function(a, b) {
    W();
    return b(a._source);
  }, useSyncExternalStore: function(a, b, c) {
    if (void 0 === c) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
    return c();
  } }, Lc = null, Nc = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function Oc(a) {
    console.error(a);
    return null;
  }
  function X() {
  }
  function Pc(a, b) {
    var c = a.pingedTasks;
    c.push(b);
    1 === c.length && setImmediate(function() {
      return Qc(a);
    });
  }
  function Rc(a, b, c, d, f, e, g, h) {
    a.allPendingTasks++;
    null === c ? a.pendingRootTasks++ : c.pendingTasks++;
    var m = { node: b, ping: function() {
      return Pc(a, m);
    }, blockedBoundary: c, blockedSegment: d, abortSet: f, legacyContext: e, context: g, treeContext: h };
    f.add(m);
    return m;
  }
  function Sc(a, b, c, d, f, e) {
    return { status: 0, id: -1, index: b, parentFlushed: false, chunks: [], children: [], formatContext: d, boundary: c, lastPushedText: f, textEmbedded: e };
  }
  function Y(a, b) {
    a = a.onError(b);
    if (null != a && "string" !== typeof a) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
    return a;
  }
  function Tc(a, b) {
    var c = a.onShellError;
    c(b);
    c = a.onFatalError;
    c(b);
    null !== a.destination ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
  }
  function Uc(a, b, c, d, f) {
    R = {};
    yc = b;
    U = 0;
    for (a = c(d, f); Ac; ) Ac = false, U = 0, Bc += 1, S = null, a = c(d, f);
    Ec();
    return a;
  }
  function Vc(a, b, c, d) {
    var f = c.render(), e = d.childContextTypes;
    if (null !== e && void 0 !== e) {
      var g = b.legacyContext;
      if ("function" !== typeof c.getChildContext) d = g;
      else {
        c = c.getChildContext();
        for (var h in c) if (!(h in e)) throw Error((gc(d) || "Unknown") + '.getChildContext(): key "' + h + '" is not defined in childContextTypes.');
        d = O({}, g, c);
      }
      b.legacyContext = d;
      Z(a, b, f);
      b.legacyContext = g;
    } else Z(a, b, f);
  }
  function Wc(a, b) {
    if (a && a.defaultProps) {
      b = O({}, b);
      a = a.defaultProps;
      for (var c in a) void 0 === b[c] && (b[c] = a[c]);
      return b;
    }
    return b;
  }
  function Xc(a, b, c, d, f) {
    if ("function" === typeof c) if (c.prototype && c.prototype.isReactComponent) {
      f = ic(c, b.legacyContext);
      var e = c.contextType;
      e = new c(d, "object" === typeof e && null !== e ? e._currentValue : f);
      pc(e, c, d, f);
      Vc(a, b, e, c);
    } else {
      e = ic(c, b.legacyContext);
      f = Uc(a, b, c, d, e);
      var g = 0 !== U;
      if ("object" === typeof f && null !== f && "function" === typeof f.render && void 0 === f.$$typeof) pc(f, c, d, e), Vc(a, b, f, c);
      else if (g) {
        d = b.treeContext;
        b.treeContext = rc(d, 1, 0);
        try {
          Z(a, b, f);
        } finally {
          b.treeContext = d;
        }
      } else Z(a, b, f);
    }
    else if ("string" === typeof c) {
      f = b.blockedSegment;
      e = Pa(f.chunks, c, d, a.responseState, f.formatContext);
      f.lastPushedText = false;
      g = f.formatContext;
      f.formatContext = ya(g, c, d);
      Yc(a, b, e);
      f.formatContext = g;
      switch (c) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          f.chunks.push(Qa, c, Ra);
      }
      f.lastPushedText = false;
    } else {
      switch (c) {
        case dc:
        case cc:
        case Tb:
        case Ub:
        case Sb:
          Z(a, b, d.children);
          return;
        case Zb:
          Z(
            a,
            b,
            d.children
          );
          return;
        case bc:
          throw Error("ReactDOMServer does not yet support scope components.");
        case Yb:
          a: {
            c = b.blockedBoundary;
            f = b.blockedSegment;
            e = d.fallback;
            d = d.children;
            g = /* @__PURE__ */ new Set();
            var h = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g, errorDigest: null }, m = Sc(a, f.chunks.length, h, f.formatContext, false, false);
            f.children.push(m);
            f.lastPushedText = false;
            var n = Sc(a, 0, null, f.formatContext, false, false);
            n.parentFlushed = true;
            b.blockedBoundary = h;
            b.blockedSegment = n;
            try {
              if (Yc(a, b, d), n.lastPushedText && n.textEmbedded && n.chunks.push(za), n.status = 1, Zc(h, n), 0 === h.pendingTasks) break a;
            } catch (p) {
              n.status = 4, h.forceClientRender = true, h.errorDigest = Y(a, p);
            } finally {
              b.blockedBoundary = c, b.blockedSegment = f;
            }
            b = Rc(a, e, c, m, g, b.legacyContext, b.context, b.treeContext);
            a.pingedTasks.push(b);
          }
          return;
      }
      if ("object" === typeof c && null !== c) switch (c.$$typeof) {
        case Xb:
          d = Uc(a, b, c.render, d, f);
          if (0 !== U) {
            c = b.treeContext;
            b.treeContext = rc(c, 1, 0);
            try {
              Z(a, b, d);
            } finally {
              b.treeContext = c;
            }
          } else Z(
            a,
            b,
            d
          );
          return;
        case $b:
          c = c.type;
          d = Wc(c, d);
          Xc(a, b, c, d, f);
          return;
        case Vb:
          f = d.children;
          c = c._context;
          d = d.value;
          e = c._currentValue;
          c._currentValue = d;
          g = P;
          P = d = { parent: g, depth: null === g ? 0 : g.depth + 1, context: c, parentValue: e, value: d };
          b.context = d;
          Z(a, b, f);
          a = P;
          if (null === a) throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          d = a.parentValue;
          a.context._currentValue = d === ec ? a.context._defaultValue : d;
          a = P = a.parent;
          b.context = a;
          return;
        case Wb:
          d = d.children;
          d = d(c._currentValue);
          Z(a, b, d);
          return;
        case ac:
          f = c._init;
          c = f(c._payload);
          d = Wc(c, d);
          Xc(a, b, c, d, void 0);
          return;
      }
      throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((null == c ? c : typeof c) + "."));
    }
  }
  function Z(a, b, c) {
    b.node = c;
    if ("object" === typeof c && null !== c) {
      switch (c.$$typeof) {
        case Qb:
          Xc(a, b, c.type, c.props, c.ref);
          return;
        case Rb:
          throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
        case ac:
          var d = c._init;
          c = d(c._payload);
          Z(a, b, c);
          return;
      }
      if (qa(c)) {
        $c(a, b, c);
        return;
      }
      null === c || "object" !== typeof c ? d = null : (d = fc && c[fc] || c["@@iterator"], d = "function" === typeof d ? d : null);
      if (d && (d = d.call(c))) {
        c = d.next();
        if (!c.done) {
          var f = [];
          do
            f.push(c.value), c = d.next();
          while (!c.done);
          $c(a, b, f);
        }
        return;
      }
      a = Object.prototype.toString.call(c);
      throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === a ? "object with keys {" + Object.keys(c).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
    }
    "string" === typeof c ? (d = b.blockedSegment, d.lastPushedText = Aa(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : "number" === typeof c && (d = b.blockedSegment, d.lastPushedText = Aa(
      b.blockedSegment.chunks,
      "" + c,
      a.responseState,
      d.lastPushedText
    ));
  }
  function $c(a, b, c) {
    for (var d = c.length, f = 0; f < d; f++) {
      var e = b.treeContext;
      b.treeContext = rc(e, d, f);
      try {
        Yc(a, b, c[f]);
      } finally {
        b.treeContext = e;
      }
    }
  }
  function Yc(a, b, c) {
    var d = b.blockedSegment.formatContext, f = b.legacyContext, e = b.context;
    try {
      return Z(a, b, c);
    } catch (m) {
      if (Ec(), "object" === typeof m && null !== m && "function" === typeof m.then) {
        c = m;
        var g = b.blockedSegment, h = Sc(a, g.chunks.length, null, g.formatContext, g.lastPushedText, true);
        g.children.push(h);
        g.lastPushedText = false;
        a = Rc(a, b.node, b.blockedBoundary, h, b.abortSet, b.legacyContext, b.context, b.treeContext).ping;
        c.then(a, a);
        b.blockedSegment.formatContext = d;
        b.legacyContext = f;
        b.context = e;
        nc(e);
      } else throw b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, nc(e), m;
    }
  }
  function ad(a) {
    var b = a.blockedBoundary;
    a = a.blockedSegment;
    a.status = 3;
    bd(this, b, a);
  }
  function cd(a, b, c) {
    var d = a.blockedBoundary;
    a.blockedSegment.status = 3;
    null === d ? (b.allPendingTasks--, 2 !== b.status && (b.status = 2, null !== b.destination && b.destination.end())) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = true, d.errorDigest = b.onError(void 0 === c ? Error("The render was aborted by the server without a reason.") : c), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(a2) {
      return cd(a2, b, c);
    }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, 0 === b.allPendingTasks && (a = b.onAllReady, a()));
  }
  function Zc(a, b) {
    if (0 === b.chunks.length && 1 === b.children.length && null === b.children[0].boundary) {
      var c = b.children[0];
      c.id = b.id;
      c.parentFlushed = true;
      1 === c.status && Zc(a, c);
    } else a.completedSegments.push(b);
  }
  function bd(a, b, c) {
    if (null === b) {
      if (c.parentFlushed) {
        if (null !== a.completedRootSegment) throw Error("There can only be one root segment. This is a bug in React.");
        a.completedRootSegment = c;
      }
      a.pendingRootTasks--;
      0 === a.pendingRootTasks && (a.onShellError = X, b = a.onShellReady, b());
    } else b.pendingTasks--, b.forceClientRender || (0 === b.pendingTasks ? (c.parentFlushed && 1 === c.status && Zc(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(ad, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && 1 === c.status && (Zc(b, c), 1 === b.completedSegments.length && b.parentFlushed && a.partialBoundaries.push(b)));
    a.allPendingTasks--;
    0 === a.allPendingTasks && (a = a.onAllReady, a());
  }
  function Qc(a) {
    if (2 !== a.status) {
      var b = P, c = Nc.current;
      Nc.current = Mc;
      var d = Lc;
      Lc = a.responseState;
      try {
        var f = a.pingedTasks, e;
        for (e = 0; e < f.length; e++) {
          var g = f[e];
          var h = a, m = g.blockedSegment;
          if (0 === m.status) {
            nc(g.context);
            try {
              Z(h, g, g.node), m.lastPushedText && m.textEmbedded && m.chunks.push(za), g.abortSet.delete(g), m.status = 1, bd(h, g.blockedBoundary, m);
            } catch (E) {
              if (Ec(), "object" === typeof E && null !== E && "function" === typeof E.then) {
                var n = g.ping;
                E.then(n, n);
              } else {
                g.abortSet.delete(g);
                m.status = 4;
                var p = g.blockedBoundary, v = E, C = Y(h, v);
                null === p ? Tc(h, v) : (p.pendingTasks--, p.forceClientRender || (p.forceClientRender = true, p.errorDigest = C, p.parentFlushed && h.clientRenderedBoundaries.push(p)));
                h.allPendingTasks--;
                if (0 === h.allPendingTasks) {
                  var D = h.onAllReady;
                  D();
                }
              }
            } finally {
            }
          }
        }
        f.splice(0, e);
        null !== a.destination && dd(a, a.destination);
      } catch (E) {
        Y(a, E), Tc(a, E);
      } finally {
        Lc = d, Nc.current = c, c === Mc && nc(b);
      }
    }
  }
  function ed(a, b, c) {
    c.parentFlushed = true;
    switch (c.status) {
      case 0:
        var d = c.id = a.nextSegmentId++;
        c.lastPushedText = false;
        c.textEmbedded = false;
        a = a.responseState;
        r2(b, Sa);
        r2(b, a.placeholderPrefix);
        a = d.toString(16);
        r2(b, a);
        return w(b, Ta);
      case 1:
        c.status = 2;
        var f = true;
        d = c.chunks;
        var e = 0;
        c = c.children;
        for (var g = 0; g < c.length; g++) {
          for (f = c[g]; e < f.index; e++) r2(b, d[e]);
          f = fd(a, b, f);
        }
        for (; e < d.length - 1; e++) r2(b, d[e]);
        e < d.length && (f = w(b, d[e]));
        return f;
      default:
        throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
    }
  }
  function fd(a, b, c) {
    var d = c.boundary;
    if (null === d) return ed(a, b, c);
    d.parentFlushed = true;
    if (d.forceClientRender) d = d.errorDigest, w(b, Xa), r2(b, Za), d && (r2(b, ab), r2(b, F(d)), r2(b, $a)), w(b, bb), ed(a, b, c);
    else if (0 < d.pendingTasks) {
      d.rootSegmentID = a.nextSegmentId++;
      0 < d.completedSegments.length && a.partialBoundaries.push(d);
      var f = a.responseState;
      var e = f.nextSuspenseID++;
      f = x(f.boundaryPrefix + e.toString(16));
      d = d.id = f;
      cb(b, a.responseState, d);
      ed(a, b, c);
    } else if (d.byteSize > a.progressiveChunkSize) d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), cb(b, a.responseState, d.id), ed(a, b, c);
    else {
      w(b, Ua);
      c = d.completedSegments;
      if (1 !== c.length) throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
      fd(a, b, c[0]);
    }
    return w(b, Ya);
  }
  function gd(a, b, c) {
    yb(b, a.responseState, c.formatContext, c.id);
    fd(a, b, c);
    return zb(b, c.formatContext);
  }
  function hd(a, b, c) {
    for (var d = c.completedSegments, f = 0; f < d.length; f++) id2(a, b, c, d[f]);
    d.length = 0;
    a = a.responseState;
    d = c.id;
    c = c.rootSegmentID;
    r2(b, a.startInlineScript);
    a.sentCompleteBoundaryFunction ? r2(b, Gb) : (a.sentCompleteBoundaryFunction = true, r2(b, Fb));
    if (null === d) throw Error("An ID must have been assigned before we can complete the boundary.");
    c = c.toString(16);
    r2(b, d);
    r2(b, Hb);
    r2(b, a.segmentPrefix);
    r2(b, c);
    return w(b, Ib);
  }
  function id2(a, b, c, d) {
    if (2 === d.status) return true;
    var f = d.id;
    if (-1 === f) {
      if (-1 === (d.id = c.rootSegmentID)) throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
      return gd(a, b, d);
    }
    gd(a, b, d);
    a = a.responseState;
    r2(b, a.startInlineScript);
    a.sentCompleteSegmentFunction ? r2(b, Bb) : (a.sentCompleteSegmentFunction = true, r2(b, Ab));
    r2(b, a.segmentPrefix);
    f = f.toString(16);
    r2(b, f);
    r2(b, Cb);
    r2(b, a.placeholderPrefix);
    r2(b, f);
    return w(b, Db);
  }
  function dd(a, b) {
    k = new Uint8Array(2048);
    l2 = 0;
    q = true;
    try {
      var c = a.completedRootSegment;
      if (null !== c && 0 === a.pendingRootTasks) {
        fd(a, b, c);
        a.completedRootSegment = null;
        var d = a.responseState.bootstrapChunks;
        for (c = 0; c < d.length - 1; c++) r2(b, d[c]);
        c < d.length && w(b, d[c]);
      }
      var f = a.clientRenderedBoundaries, e;
      for (e = 0; e < f.length; e++) {
        var g = f[e];
        d = b;
        var h = a.responseState, m = g.id, n = g.errorDigest, p = g.errorMessage, v = g.errorComponentStack;
        r2(d, h.startInlineScript);
        h.sentClientRenderFunction ? r2(d, Kb) : (h.sentClientRenderFunction = true, r2(d, Jb));
        if (null === m) throw Error("An ID must have been assigned before we can complete the boundary.");
        r2(d, m);
        r2(d, Lb);
        if (n || p || v) r2(d, Nb), r2(d, Pb(n || ""));
        if (p || v) r2(d, Nb), r2(d, Pb(p || ""));
        v && (r2(d, Nb), r2(d, Pb(v)));
        if (!w(d, Mb)) {
          a.destination = null;
          e++;
          f.splice(0, e);
          return;
        }
      }
      f.splice(0, e);
      var C = a.completedBoundaries;
      for (e = 0; e < C.length; e++) if (!hd(a, b, C[e])) {
        a.destination = null;
        e++;
        C.splice(0, e);
        return;
      }
      C.splice(0, e);
      ca(b);
      k = new Uint8Array(2048);
      l2 = 0;
      q = true;
      var D = a.partialBoundaries;
      for (e = 0; e < D.length; e++) {
        var E = D[e];
        a: {
          f = a;
          g = b;
          var na = E.completedSegments;
          for (h = 0; h < na.length; h++) if (!id2(f, g, E, na[h])) {
            h++;
            na.splice(0, h);
            var Eb = false;
            break a;
          }
          na.splice(0, h);
          Eb = true;
        }
        if (!Eb) {
          a.destination = null;
          e++;
          D.splice(0, e);
          return;
        }
      }
      D.splice(0, e);
      var oa = a.completedBoundaries;
      for (e = 0; e < oa.length; e++) if (!hd(a, b, oa[e])) {
        a.destination = null;
        e++;
        oa.splice(0, e);
        return;
      }
      oa.splice(0, e);
    } finally {
      ca(b), "function" === typeof b.flush && b.flush(), 0 === a.allPendingTasks && 0 === a.pingedTasks.length && 0 === a.clientRenderedBoundaries.length && 0 === a.completedBoundaries.length && b.end();
    }
  }
  function jd(a) {
    setImmediate(function() {
      return Qc(a);
    });
  }
  function kd(a, b) {
    if (1 === a.status) a.status = 2, b.destroy(a.fatalError);
    else if (2 !== a.status && null === a.destination) {
      a.destination = b;
      try {
        dd(a, b);
      } catch (c) {
        Y(a, c), Tc(a, c);
      }
    }
  }
  function ld(a, b) {
    try {
      var c = a.abortableTasks;
      c.forEach(function(c2) {
        return cd(c2, a, b);
      });
      c.clear();
      null !== a.destination && dd(a, a.destination);
    } catch (d) {
      Y(a, d), Tc(a, d);
    }
  }
  function md(a, b) {
    return function() {
      return kd(b, a);
    };
  }
  function nd(a, b) {
    return function() {
      return ld(a, b);
    };
  }
  function od(a, b) {
    var c = b ? b.identifierPrefix : void 0, d = b ? b.nonce : void 0, f = b ? b.bootstrapScriptContent : void 0, e = b ? b.bootstrapScripts : void 0;
    var g = b ? b.bootstrapModules : void 0;
    c = void 0 === c ? "" : c;
    d = void 0 === d ? ra : x('<script nonce="' + F(d) + '">');
    var h = [];
    void 0 !== f && h.push(d, ("" + f).replace(wa, xa), sa);
    if (void 0 !== e) for (f = 0; f < e.length; f++) h.push(ta, F(e[f]), va);
    if (void 0 !== g) for (e = 0; e < g.length; e++) h.push(ua, F(g[e]), va);
    g = {
      bootstrapChunks: h,
      startInlineScript: d,
      placeholderPrefix: x(c + "P:"),
      segmentPrefix: x(c + "S:"),
      boundaryPrefix: c + "B:",
      idPrefix: c,
      nextSuspenseID: 0,
      sentCompleteSegmentFunction: false,
      sentCompleteBoundaryFunction: false,
      sentClientRenderFunction: false
    };
    e = b ? b.namespaceURI : void 0;
    e = G("http://www.w3.org/2000/svg" === e ? 2 : "http://www.w3.org/1998/Math/MathML" === e ? 3 : 0, null);
    f = b ? b.progressiveChunkSize : void 0;
    d = b ? b.onError : void 0;
    h = b ? b.onAllReady : void 0;
    var m = b ? b.onShellReady : void 0, n = b ? b.onShellError : void 0;
    b = [];
    c = /* @__PURE__ */ new Set();
    g = {
      destination: null,
      responseState: g,
      progressiveChunkSize: void 0 === f ? 12800 : f,
      status: 0,
      fatalError: null,
      nextSegmentId: 0,
      allPendingTasks: 0,
      pendingRootTasks: 0,
      completedRootSegment: null,
      abortableTasks: c,
      pingedTasks: b,
      clientRenderedBoundaries: [],
      completedBoundaries: [],
      partialBoundaries: [],
      onError: void 0 === d ? Oc : d,
      onAllReady: void 0 === h ? X : h,
      onShellReady: void 0 === m ? X : m,
      onShellError: void 0 === n ? X : n,
      onFatalError: X
    };
    e = Sc(g, 0, null, e, false, false);
    e.parentFlushed = true;
    a = Rc(g, a, null, e, c, hc, null, qc);
    b.push(a);
    return g;
  }
  reactDomServer_node_production_min.renderToPipeableStream = function(a, b) {
    var c = od(a, b), d = false;
    jd(c);
    return { pipe: function(a2) {
      if (d) throw Error("React currently only supports piping to one writable stream.");
      d = true;
      kd(c, a2);
      a2.on("drain", md(a2, c));
      a2.on("error", nd(c, Error("The destination stream errored while writing data.")));
      a2.on("close", nd(c, Error("The destination stream closed early.")));
      return a2;
    }, abort: function(a2) {
      ld(c, a2);
    } };
  };
  reactDomServer_node_production_min.version = "18.3.1";
  return reactDomServer_node_production_min;
}
var reactDomServerLegacy_node_development = {};
/**
 * @license React
 * react-dom-server-legacy.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDomServerLegacy_node_development;
function requireReactDomServerLegacy_node_development() {
  if (hasRequiredReactDomServerLegacy_node_development) return reactDomServerLegacy_node_development;
  hasRequiredReactDomServerLegacy_node_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var React2 = requireReact();
      var stream = require$$1;
      var ReactVersion = "18.3.1";
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        callback();
      }
      function beginWriting(destination) {
      }
      function writeChunk(destination, chunk) {
        writeChunkAndReturn(destination, chunk);
      }
      function writeChunkAndReturn(destination, chunk) {
        return destination.push(chunk);
      }
      function completeWriting(destination) {
      }
      function close(destination) {
        destination.push(null);
      }
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return content;
      }
      function closeWithError(destination, error2) {
        destination.destroy(error2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        // TODO: This prevents the assignment of defaultValue to regular
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "allowFullScreen",
        "async",
        // Note: there is a special case that prevents it from being written to the DOM
        // on the client side because the browsers are inconsistent. Instead we call focus().
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        // Microdata
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "checked",
        // Note: `option.selected` is not updated if `select.multiple` is
        // disabled with `removeAttribute`. We have special logic for handling this.
        "multiple",
        "muted",
        "selected"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          true,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "capture",
        "download"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "cols",
        "rows",
        "size",
        "span"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/1999/xlink",
          false,
          // sanitizeURL
          false
        );
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          false,
          // sanitizeURL
          false
        );
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        false,
        // mustUseProperty
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        true,
        // sanitizeURL
        false
      );
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          true,
          // sanitizeURL
          true
        );
      });
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        // state
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        // state
        "aria-hidden": 0,
        // state
        "aria-invalid": 0,
        // state
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        // Widget Attributes
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        // Live Region Attributes
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        // Drag-and-Drop Attributes
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        // Relationship Attributes
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
            return true;
          }
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
              warnedProperties[name] = true;
              return true;
            }
            if (name !== correctName) {
              error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
              warnedProperties[name] = true;
              return true;
            }
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name] = true;
              return false;
            }
            if (name !== standardName) {
              error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties[name] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid = validateProperty(type, key);
            if (!isValid) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          } else if (invalidProps.length > 1) {
            error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === "select" && props.multiple) {
              error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            } else {
              error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
            }
          }
        }
      }
      var possibleStandardNames = {
        // HTML
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        // SVG
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
            return true;
          }
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (eventRegistry != null) {
            var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies.hasOwnProperty(name)) {
              return true;
            }
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
              error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
              error("Unknown event handler property `%s`. It will be ignored.", name);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name)) {
            if (INVALID_EVENT_NAME_REGEX.test(name)) {
              error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "number" && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
              error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (!isReserved && name !== lowerCasedName) {
            error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo)) {
            if (value) {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
            } else {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo)) {
            warnedProperties$1[name] = true;
            return false;
          }
          if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties$1[name] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          } else if (unknownProps.length > 1) {
            error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          }
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnUnknownProperties(type, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error(
            "Unsupported style property %s. Did you mean %s?",
            name,
            // As Andi Smith suggests
            // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
            // is converted to lowercase `ms`.
            camelize(name.replace(msPattern, "ms-"))
          );
        };
        var warnBadVendoredStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name, value) {
          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
            return;
          }
          warnedStyleValues[value] = true;
          error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name, value) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error("`NaN` is an invalid value for the `%s` css style property.", name);
        };
        var warnStyleValueIsInfinity = function(name, value) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error("`Infinity` is an invalid value for the `%s` css style property.", name);
        };
        warnValidStyle = function(name, value) {
          if (name.indexOf("-") > -1) {
            warnHyphenatedStyleName(name);
          } else if (badVendoredStyleNamePattern.test(name)) {
            warnBadVendoredStyleName(name);
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name, value);
          }
          if (typeof value === "number") {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name, value);
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name, value);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      var matchHtmlRegExp = /["'&<>]/;
      function escapeHtml2(string) {
        {
          checkHtmlStringCoercion(string);
        }
        var str = "" + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
          return str;
        }
        var escape;
        var html = "";
        var index;
        var lastIndex = 0;
        for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape = "&quot;";
              break;
            case 38:
              escape = "&amp;";
              break;
            case 39:
              escape = "&#x27;";
              break;
            case 60:
              escape = "&lt;";
              break;
            case 62:
              escape = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escape;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      function escapeTextForBrowser(text) {
        if (typeof text === "boolean" || typeof text === "number") {
          return "" + text;
        }
        return escapeHtml2(text);
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern$1 = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var startInlineScript = stringToPrecomputedChunk("<script>");
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
        var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
        var bootstrapChunks = [];
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: false,
          sentCompleteBoundaryFunction: false,
          sentClientRenderFunction: false
        };
      }
      var ROOT_HTML_MODE = 0;
      var HTML_MODE = 1;
      var SVG_MODE = 2;
      var MATHML_MODE = 3;
      var HTML_TABLE_MODE = 4;
      var HTML_TABLE_BODY_MODE = 5;
      var HTML_TABLE_ROW_MODE = 6;
      var HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        if (parentContext.insertionMode === ROOT_HTML_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        return parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix;
        var id2 = ":" + idPrefix + "R" + treeId;
        if (localId > 0) {
          id2 += "H" + localId.toString(32);
        }
        return id2 + ":";
      }
      function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text);
      }
      var textSeparator = stringToPrecomputedChunk("<!-- -->");
      function pushTextInstance(target, text, responseState, textEmbedded) {
        if (text === "") {
          return textEmbedded;
        }
        if (textEmbedded) {
          target.push(textSeparator);
        }
        target.push(stringToChunk(encodeHTMLTextNode(text)));
        return true;
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        if (lastPushedText && textEmbedded) {
          target.push(textSeparator);
        }
      }
      var styleNameCache = /* @__PURE__ */ new Map();
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== void 0) {
          return chunk;
        }
        var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        styleNameCache.set(styleName, result);
        return result;
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="');
      var styleAssign = stringToPrecomputedChunk(":");
      var styleSeparator = stringToPrecomputedChunk(";");
      function pushStyle(target, responseState, style) {
        if (typeof style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
        var isFirst = true;
        for (var styleName in style) {
          if (!hasOwnProperty.call(style, styleName)) {
            continue;
          }
          var styleValue = style[styleName];
          if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
            continue;
          }
          var nameChunk = void 0;
          var valueChunk = void 0;
          var isCustomProperty = styleName.indexOf("--") === 0;
          if (isCustomProperty) {
            nameChunk = stringToChunk(escapeTextForBrowser(styleName));
            {
              checkCSSPropertyStringCoercion(styleValue, styleName);
            }
            valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
          } else {
            {
              warnValidStyle$1(styleName, styleValue);
            }
            nameChunk = processStyleName(styleName);
            if (typeof styleValue === "number") {
              if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                valueChunk = stringToChunk(styleValue + "px");
              } else {
                valueChunk = stringToChunk("" + styleValue);
              }
            } else {
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            }
          }
          if (isFirst) {
            isFirst = false;
            target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
          } else {
            target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
          }
        }
        if (!isFirst) {
          target.push(attributeEnd);
        }
      }
      var attributeSeparator = stringToPrecomputedChunk(" ");
      var attributeAssign = stringToPrecomputedChunk('="');
      var attributeEnd = stringToPrecomputedChunk('"');
      var attributeEmptyString = stringToPrecomputedChunk('=""');
      function pushAttribute(target, responseState, name, value) {
        switch (name) {
          case "style": {
            pushStyle(target, responseState, value);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (
          // shouldIgnoreAttribute
          // We have already filtered out null/undefined and reserved words.
          name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")
        ) {
          return;
        }
        var propertyInfo = getPropertyInfo(name);
        if (propertyInfo !== null) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              if (!propertyInfo.acceptsBooleans) {
                return;
              }
            }
          }
          var attributeName = propertyInfo.attributeName;
          var attributeNameChunk = stringToChunk(attributeName);
          switch (propertyInfo.type) {
            case BOOLEAN:
              if (value) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              }
              return;
            case OVERLOADED_BOOLEAN:
              if (value === true) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              } else if (value === false) ;
              else {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              return;
            case NUMERIC:
              if (!isNaN(value)) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            case POSITIVE_NUMERIC:
              if (!isNaN(value) && value >= 1) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            default:
              if (propertyInfo.sanitizeURL) {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                value = "" + value;
                sanitizeURL(value);
              }
              target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        } else if (isAttributeNameSafe(name)) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var prefix2 = name.toLowerCase().slice(0, 5);
              if (prefix2 !== "data-" && prefix2 !== "aria-") {
                return;
              }
            }
          }
          target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
        }
      }
      var endOfStartTag = stringToPrecomputedChunk(">");
      var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== void 0) {
            {
              checkHtmlStringCoercion(html);
            }
            target.push(stringToChunk("" + html));
          }
        }
      }
      var didWarnDefaultInputValue = false;
      var didWarnDefaultChecked = false;
      var didWarnDefaultSelectValue = false;
      var didWarnDefaultTextareaValue = false;
      var didWarnInvalidOptionChildren = false;
      var didWarnInvalidOptionInnerHTML = false;
      var didWarnSelectedSetOnOption = false;
      function checkSelectProp(props, propName) {
        {
          var value = props[propName];
          if (value != null) {
            var array = isArray(value);
            if (props.multiple && !array) {
              error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
            } else if (!props.multiple && array) {
              error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
            }
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        {
          checkControlledValueProps("select", props);
          checkSelectProp(props, "value");
          checkSelectProp(props, "defaultValue");
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
            error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultSelectValue = true;
          }
        }
        target.push(startChunkForTag("select"));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        React2.Children.forEach(children, function(child) {
          if (child == null) {
            return;
          }
          content += child;
          {
            if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
              didWarnInvalidOptionChildren = true;
              error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
            }
          }
        });
        return content;
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null;
        var value = null;
        var selected = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue;
                {
                  if (!didWarnSelectedSetOnOption) {
                    error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                    didWarnSelectedSetOnOption = true;
                  }
                }
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (selectedValue != null) {
          var stringValue;
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            stringValue = "" + value;
          } else {
            {
              if (innerHTML !== null) {
                if (!didWarnInvalidOptionInnerHTML) {
                  didWarnInvalidOptionInnerHTML = true;
                  error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            stringValue = flattenOptionChildren(children);
          }
          if (isArray(selectedValue)) {
            for (var i = 0; i < selectedValue.length; i++) {
              {
                checkAttributeStringCoercion(selectedValue[i], "value");
              }
              var v = "" + selectedValue[i];
              if (v === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          } else {
            {
              checkAttributeStringCoercion(selectedValue, "select.value");
            }
            if ("" + selectedValue === stringValue) {
              target.push(selectedMarkerAttribute);
            }
          }
        } else if (selected) {
          target.push(selectedMarkerAttribute);
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function pushInput(target, props, responseState) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultChecked = true;
          }
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
            error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultInputValue = true;
          }
        }
        target.push(startChunkForTag("input"));
        var value = null;
        var defaultValue = null;
        var checked = null;
        var defaultChecked = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked = propValue;
                break;
              case "value":
                value = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (checked !== null) {
          pushAttribute(target, responseState, "checked", checked);
        } else if (defaultChecked !== null) {
          pushAttribute(target, responseState, "checked", defaultChecked);
        }
        if (value !== null) {
          pushAttribute(target, responseState, "value", value);
        } else if (defaultValue !== null) {
          pushAttribute(target, responseState, "value", defaultValue);
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartTextArea(target, props, responseState) {
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
            error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultTextareaValue = true;
          }
        }
        target.push(startChunkForTag("textarea"));
        var value = null;
        var defaultValue = null;
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (value === null && defaultValue !== null) {
          value = defaultValue;
        }
        target.push(endOfStartTag);
        if (children != null) {
          {
            error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          }
          if (value != null) {
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          }
          if (isArray(children)) {
            if (children.length > 1) {
              throw new Error("<textarea> can only have at most one child.");
            }
            {
              checkHtmlStringCoercion(children[0]);
            }
            value = "" + children[0];
          }
          {
            checkHtmlStringCoercion(children);
          }
          value = "" + children;
        }
        if (typeof value === "string" && value[0] === "\n") {
          target.push(leadingNewline);
        }
        if (value !== null) {
          {
            checkAttributeStringCoercion(value, "value");
          }
          target.push(stringToChunk(encodeHTMLTextNode("" + value)));
        }
        return null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        return null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          if (Array.isArray(children) && children.length > 1) {
            error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && child.$$typeof != null) {
            error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && typeof child !== "string" && typeof child !== "number") {
            error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          }
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        if (typeof children === "string") {
          target.push(stringToChunk(encodeHTMLTextNode(children)));
          return null;
        }
        return children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                  target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                }
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      var leadingNewline = stringToPrecomputedChunk("\n");
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== void 0) {
            if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
              target.push(leadingNewline, stringToChunk(html));
            } else {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        if (typeof children === "string" && children[0] === "\n") {
          target.push(leadingNewline);
        }
        return children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
      var validatedTagCache = /* @__PURE__ */ new Map();
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === void 0) {
          if (!VALID_TAG_REGEX.test(tag)) {
            throw new Error("Invalid tag: " + tag);
          }
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
      function pushStartInstance(target, type, props, responseState, formatContext) {
        {
          validateProperties(type, props);
          validateProperties$1(type, props);
          validateProperties$2(type, props, null);
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
          }
          if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
            if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
              error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
            }
          }
        }
        switch (type) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre": {
            return pushStartPreformattedElement(target, props, type, responseState);
          }
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            return pushSelfClosing(target, props, type, responseState);
          }
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph": {
            return pushStartGenericElement(target, props, type, responseState);
          }
          case "html": {
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              target.push(DOCTYPE);
            }
            return pushStartGenericElement(target, props, type, responseState);
          }
          default: {
            if (type.indexOf("-") === -1 && typeof props.is !== "string") {
              return pushStartGenericElement(target, props, type, responseState);
            } else {
              return pushStartCustomElement(target, props, type, responseState);
            }
          }
        }
      }
      var endTag1 = stringToPrecomputedChunk("</");
      var endTag2 = stringToPrecomputedChunk(">");
      function pushEndInstance(target, type, props) {
        switch (type) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            break;
          }
          default: {
            target.push(endTag1, stringToChunk(type), endTag2);
          }
        }
      }
      function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks;
        var i = 0;
        for (; i < bootstrapChunks.length - 1; i++) {
          writeChunk(destination, bootstrapChunks[i]);
        }
        if (i < bootstrapChunks.length) {
          return writeChunkAndReturn(destination, bootstrapChunks[i]);
        }
        return true;
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="');
      var placeholder2 = stringToPrecomputedChunk('"></template>');
      function writePlaceholder(destination, responseState, id2) {
        writeChunk(destination, placeholder1);
        writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id2.toString(16));
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
      var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
      var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
      var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
      var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
      var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
      var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
      var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
      var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
      var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
      var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id2) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (id2 === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, id2);
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result;
        result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        if (errorDigest) {
          writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
          writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
          writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        {
          if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
        }
        result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        return result;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
      var startSegmentHTML2 = stringToPrecomputedChunk('">');
      var endSegmentHTML = stringToPrecomputedChunk("</div>");
      var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
      var startSegmentSVG2 = stringToPrecomputedChunk('">');
      var endSegmentSVG = stringToPrecomputedChunk("</svg>");
      var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
      var startSegmentMathML2 = stringToPrecomputedChunk('">');
      var endSegmentMathML = stringToPrecomputedChunk("</math>");
      var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
      var startSegmentTable2 = stringToPrecomputedChunk('">');
      var endSegmentTable = stringToPrecomputedChunk("</table>");
      var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
      var startSegmentTableBody2 = stringToPrecomputedChunk('">');
      var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
      var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
      var startSegmentTableRow2 = stringToPrecomputedChunk('">');
      var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
      var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
      var startSegmentColGroup2 = stringToPrecomputedChunk('">');
      var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
      function writeStartSegment(destination, responseState, formatContext, id2) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            writeChunk(destination, startSegmentHTML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentHTML2);
          }
          case SVG_MODE: {
            writeChunk(destination, startSegmentSVG);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentSVG2);
          }
          case MATHML_MODE: {
            writeChunk(destination, startSegmentMathML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentMathML2);
          }
          case HTML_TABLE_MODE: {
            writeChunk(destination, startSegmentTable);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTable2);
          }
          case HTML_TABLE_BODY_MODE: {
            writeChunk(destination, startSegmentTableBody);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableBody2);
          }
          case HTML_TABLE_ROW_MODE: {
            writeChunk(destination, startSegmentTableRow);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableRow2);
          }
          case HTML_COLGROUP_MODE: {
            writeChunk(destination, startSegmentColGroup);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentColGroup2);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            return writeChunkAndReturn(destination, endSegmentHTML);
          }
          case SVG_MODE: {
            return writeChunkAndReturn(destination, endSegmentSVG);
          }
          case MATHML_MODE: {
            return writeChunkAndReturn(destination, endSegmentMathML);
          }
          case HTML_TABLE_MODE: {
            return writeChunkAndReturn(destination, endSegmentTable);
          }
          case HTML_TABLE_BODY_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableBody);
          }
          case HTML_TABLE_ROW_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableRow);
          }
          case HTML_COLGROUP_MODE: {
            return writeChunkAndReturn(destination, endSegmentColGroup);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
      var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
      var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
      var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
      var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
      var completeSegmentScript2 = stringToPrecomputedChunk('","');
      var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteSegmentFunction) {
          responseState.sentCompleteSegmentFunction = true;
          writeChunk(destination, completeSegmentScript1Full);
        } else {
          writeChunk(destination, completeSegmentScript1Partial);
        }
        writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, formattedID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, responseState.placeholderPrefix);
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
      var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
      var completeBoundaryScript2 = stringToPrecomputedChunk('","');
      var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteBoundaryFunction) {
          responseState.sentCompleteBoundaryFunction = true;
          writeChunk(destination, completeBoundaryScript1Full);
        } else {
          writeChunk(destination, completeBoundaryScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, boundaryID);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, responseState.segmentPrefix);
        writeChunk(destination, formattedContentID);
        return writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
      var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
      var clientRenderScript1A = stringToPrecomputedChunk('"');
      var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
      var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentClientRenderFunction) {
          responseState.sentClientRenderFunction = true;
          writeChunk(destination, clientRenderScript1Full);
        } else {
          writeChunk(destination, clientRenderScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, boundaryID);
        writeChunk(destination, clientRenderScript1A);
        if (errorDigest || errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
        }
        if (errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
        }
        if (errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
        }
        return writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default: {
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
            }
          }
        });
      }
      function createResponseState$1(generateStaticMarkup, identifierPrefix) {
        var responseState = createResponseState(identifierPrefix, void 0);
        return {
          // Keep this in sync with ReactDOMServerFormatConfig
          bootstrapChunks: responseState.bootstrapChunks,
          startInlineScript: responseState.startInlineScript,
          placeholderPrefix: responseState.placeholderPrefix,
          segmentPrefix: responseState.segmentPrefix,
          boundaryPrefix: responseState.boundaryPrefix,
          idPrefix: responseState.idPrefix,
          nextSuspenseID: responseState.nextSuspenseID,
          sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
          sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
          sentClientRenderFunction: responseState.sentClientRenderFunction,
          // This is an extra field for the legacy renderer
          generateStaticMarkup
        };
      }
      function createRootFormatContext() {
        return {
          insertionMode: HTML_MODE,
          // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
          selectedValue: null
        };
      }
      function pushTextInstance$1(target, text, responseState, textEmbedded) {
        if (responseState.generateStaticMarkup) {
          target.push(stringToChunk(escapeTextForBrowser(text)));
          return false;
        } else {
          return pushTextInstance(target, text, responseState, textEmbedded);
        }
      }
      function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
        if (responseState.generateStaticMarkup) {
          return;
        } else {
          return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
        }
      }
      function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeStartCompletedSuspenseBoundary(destination);
      }
      function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
      }
      function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeEndCompletedSuspenseBoundary(destination);
      }
      function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeEndClientRenderedSuspenseBoundary(destination);
      }
      var assign = Object.assign;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame2 = componentFrameCache.get(fn);
          if (frame2 !== void 0) {
            return frame2;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s2 = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]) {
              c--;
            }
            for (; s2 >= 1 && c >= 0; s2--, c--) {
              if (sampleLines[s2] !== controlLines[c]) {
                if (s2 !== 1 || c !== 1) {
                  do {
                    s2--;
                    c--;
                    if (c < 0 || sampleLines[s2] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s2 >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      function getMaskedContext(type, unmaskedContext) {
        {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return context;
        }
      }
      function processChildContext(instance, type, parentContext, childContextTypes) {
        {
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
            }
          }
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var rootContextSnapshot = null;
      var currentActiveSnapshot = null;
      function popNode(prev) {
        {
          prev.context._currentValue2 = prev.parentValue;
        }
      }
      function pushNode(next) {
        {
          next.context._currentValue2 = next.value;
        }
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev === next) ;
        else {
          popNode(prev);
          var parentPrev = prev.parent;
          var parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
          } else {
            if (parentNext === null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev !== null) {
          popAllPrevious(parentPrev);
        }
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        if (parentNext !== null) {
          pushAllNext(parentNext);
        }
        pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (parentPrev.depth === next.depth) {
          popToNearestCommonAncestor(parentPrev, next);
        } else {
          popPreviousToCommonLevel(parentPrev, next);
        }
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (prev.depth === parentNext.depth) {
          popToNearestCommonAncestor(prev, parentNext);
        } else {
          popNextToCommonLevel(prev, parentNext);
        }
        pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        var next = newSnapshot;
        if (prev !== next) {
          if (prev === null) {
            pushAllNext(next);
          } else if (next === null) {
            popAllPrevious(prev);
          } else if (prev.depth === next.depth) {
            popToNearestCommonAncestor(prev, next);
          } else if (prev.depth > next.depth) {
            popPreviousToCommonLevel(prev, next);
          } else {
            popNextToCommonLevel(prev, next);
          }
          currentActiveSnapshot = next;
        }
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        {
          prevValue = context._currentValue2;
          context._currentValue2 = nextValue;
          {
            if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer2 = rendererSigil;
          }
        }
        var prevNode = currentActiveSnapshot;
        var newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        currentActiveSnapshot = newNode;
        return newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null) {
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        }
        {
          if (prevSnapshot.context !== context) {
            error("The parent context is not the expected context. This is probably a bug in React.");
          }
        }
        {
          var _value = prevSnapshot.parentValue;
          if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
            prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
          } else {
            prevSnapshot.context._currentValue2 = _value;
          }
          {
            if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer2 = rendererSigil;
          }
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value = context._currentValue2;
        return value;
      }
      function get(key) {
        return key._reactInternals;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var didWarnAboutNoopUpdateForComponent = {};
      var didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
        didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey]) {
            return;
          }
          error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
          didWarnAboutNoopUpdateForComponent[warningKey] = true;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return false;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "setState");
          } else {
            internals.queue.push(payload);
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get(inst);
          internals.replace = true;
          internals.queue = [payload];
          {
            if (callback !== void 0 && callback !== null) {
              warnOnInvalidCallback(callback, "setState");
            }
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "forceUpdate");
          } else {
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        }
      };
      function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var newState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid = (
              // Allow null for conditional declaration
              contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
            );
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === void 0) {
                addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== void 0) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          context = maskedLegacyContext;
        }
        var instance = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        return instance;
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            } else {
              error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
          }
          if (instance.propTypes) {
            error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
          }
          if (instance.contextType) {
            error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
          }
          {
            if (instance.contextTypes) {
              error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== void 0 && hasMutatedProps) {
            error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
          }
          if (instance.defaultProps) {
            error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray(_state))) {
            error("%s.state: must be set to an object or null", name);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
          }
        }
      }
      function callComponentWillMount(type, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          {
            if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!didWarnAboutDeprecatedWillMount[componentName]) {
                warn(
                  // keep this warning in sync with ReactStrictModeWarning.js
                  "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                  componentName
                );
                didWarnAboutDeprecatedWillMount[componentName] = true;
              }
            }
          }
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue;
          var oldReplace = internalInstance.replace;
          internalInstance.queue = null;
          internalInstance.replace = false;
          if (oldReplace && oldQueue.length === 1) {
            inst.state = oldQueue[0];
          } else {
            var nextState = oldReplace ? oldQueue[0] : inst.state;
            var dontMutate = true;
            for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
              var partial = oldQueue[i];
              var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
              if (partialState != null) {
                if (dontMutate) {
                  dontMutate = false;
                  nextState = assign({}, nextState, partialState);
                } else {
                  assign(nextState, partialState);
                }
              }
            }
            inst.state = nextState;
          }
        } else {
          internalInstance.queue = null;
        }
      }
      function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        {
          checkClassInstance(instance, ctor, newProps);
        }
        var initialState = instance.state !== void 0 ? instance.state : null;
        instance.updater = classComponentUpdater;
        instance.props = newProps;
        instance.state = initialState;
        var internalInstance = {
          queue: [],
          replace: false
        };
        set(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          instance.context = maskedLegacyContext;
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
          }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(ctor, instance);
          processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
        }
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow;
        var idWithLeadingBit = context.id;
        var id2 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id2.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        var baseOverflow = baseContext.overflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id2 = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id2,
            overflow
          };
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id2) {
        return 1 << getBitLength(id2) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var currentlyRenderingComponent = null;
      var currentlyRenderingTask = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var isReRender = false;
      var didScheduleRenderPhaseUpdate = false;
      var localIdCounter = 0;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;
      var isInHookUserCodeInDev = false;
      var currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        {
          if (isInHookUserCodeInDev) {
            error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          }
        }
        return currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
          }
        }
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function createHook() {
        if (numberOfReRenders > 0) {
          throw new Error("Rendered more hooks than during the previous render");
        }
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false;
            firstWorkInProgressHook = workInProgressHook = createHook();
          } else {
            isReRender = true;
            workInProgressHook = firstWorkInProgressHook;
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false;
            workInProgressHook = workInProgressHook.next = createHook();
          } else {
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
          }
        }
        return workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity;
        currentlyRenderingTask = task;
        {
          isInHookUserCodeInDev = false;
        }
        localIdCounter = 0;
      }
      function finishHooks(Component, props, children, refOrContext) {
        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false;
          localIdCounter = 0;
          numberOfReRenders += 1;
          workInProgressHook = null;
          children = Component(props, refOrContext);
        }
        resetHooksState();
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        {
          isInHookUserCodeInDev = false;
        }
        currentlyRenderingComponent = null;
        currentlyRenderingTask = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        renderPhaseUpdates = null;
        workInProgressHook = null;
      }
      function readContext$1(context) {
        {
          if (isInHookUserCodeInDev) {
            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          }
        }
        return readContext(context);
      }
      function useContext(context) {
        {
          currentHookNameInDev = "useContext";
        }
        resolveCurrentlyRenderingComponent();
        return readContext(context);
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function useState(initialState) {
        {
          currentHookNameInDev = "useState";
        }
        return useReducer(
          basicStateReducer,
          // useReducer has a special case to support lazy useState initializers
          initialState
        );
      }
      function useReducer(reducer, initialArg, init) {
        {
          if (reducer !== basicStateReducer) {
            currentHookNameInDev = "useReducer";
          }
        }
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          var queue = workInProgressHook.queue;
          var dispatch = queue.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate !== void 0) {
              renderPhaseUpdates.delete(queue);
              var newState = workInProgressHook.memoizedState;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                {
                  isInHookUserCodeInDev = true;
                }
                newState = reducer(newState, action);
                {
                  isInHookUserCodeInDev = false;
                }
                update = update.next;
              } while (update !== null);
              workInProgressHook.memoizedState = newState;
              return [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          {
            isInHookUserCodeInDev = true;
          }
          var initialState;
          if (reducer === basicStateReducer) {
            initialState = typeof initialArg === "function" ? initialArg() : initialArg;
          } else {
            initialState = init !== void 0 ? init(initialArg) : initialArg;
          }
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          };
          var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
        }
        {
          isInHookUserCodeInDev = true;
        }
        var nextValue = nextCreate();
        {
          isInHookUserCodeInDev = false;
        }
        workInProgressHook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          {
            Object.seal(ref);
          }
          workInProgressHook.memoizedState = ref;
          return ref;
        } else {
          return previousRef;
        }
      }
      function useLayoutEffect(create, inputs) {
        {
          currentHookNameInDev = "useLayoutEffect";
          error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
        }
      }
      function dispatchAction(componentIdentity, queue, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) {
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        }
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            action,
            next: null
          };
          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = /* @__PURE__ */ new Map();
          }
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
          if (firstRenderPhaseUpdate === void 0) {
            renderPhaseUpdates.set(queue, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe) {
        resolveCurrentlyRenderingComponent();
        return getSnapshot(source._source);
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === void 0) {
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        }
        return getServerSnapshot();
      }
      function useDeferredValue(value) {
        resolveCurrentlyRenderingComponent();
        return value;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition() {
        resolveCurrentlyRenderingComponent();
        return [false, unsupportedStartTransition];
      }
      function useId() {
        var task = currentlyRenderingTask;
        var treeId = getTreeId(task.treeContext);
        var responseState = currentResponseState;
        if (responseState === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        }
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop2() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop2,
        useLayoutEffect,
        useCallback,
        // useImperativeHandle is not run in the server environment
        useImperativeHandle: noop2,
        // Effects are not run in the server environment.
        useEffect: noop2,
        // Debugging effect
        useDebugValue: noop2,
        useDeferredValue,
        useTransition,
        useId,
        // Subscriptions are not setup in a server environment.
        useMutableSource,
        useSyncExternalStore
      };
      var currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "";
          var node = componentStack;
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node.type, null, null);
                break;
            }
            node = node.parent;
          } while (node);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      var PENDING = 0;
      var COMPLETED = 1;
      var FLUSHED = 2;
      var ABORTED = 3;
      var ERRORED = 4;
      var OPEN = 0;
      var CLOSING = 1;
      var CLOSED = 2;
      var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error2) {
        console["error"](error2);
        return null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [];
        var abortSet = /* @__PURE__ */ new Set();
        var request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError2 === void 0 ? defaultErrorHandler : onError2,
          onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
          onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
          onShellError: noop$1,
          onFatalError: noop$1
        };
        var rootSegment = createPendingSegment(
          request,
          0,
          null,
          rootFormatContext,
          // Root segments are never embedded in Text on either edge
          false,
          false
        );
        rootSegment.parentFlushed = true;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        pingedTasks.push(rootTask);
        return request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task);
        if (pingedTasks.length === 1) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          forceClientRender: false,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++;
        if (blockedBoundary === null) {
          request.pendingRootTasks++;
        } else {
          blockedBoundary.pendingTasks++;
        }
        var task = {
          node,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        {
          task.componentStack = null;
        }
        abortSet.add(task);
        return task;
      }
      function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          // lazily assigned later
          index,
          parentFlushed: false,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        {
          if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
            return "";
          }
          return getStackByComponentStackNode(currentTaskInDEV.componentStack);
        }
      }
      function pushBuiltInComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushFunctionComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushClassComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type
          };
        }
      }
      function popComponentStackInDEV(task) {
        {
          if (task.componentStack === null) {
            error("Unexpectedly popped too many stack frames. This is a bug in React.");
          } else {
            task.componentStack = task.componentStack.parent;
          }
        }
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error2) {
        {
          var errorMessage;
          if (typeof error2 === "string") {
            errorMessage = error2;
          } else if (error2 && typeof error2.message === "string") {
            errorMessage = error2.message;
          } else {
            errorMessage = String(error2);
          }
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null;
          boundary.errorMessage = errorMessage;
          boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error2) {
        var errorDigest = request.onError(error2);
        if (errorDigest != null && typeof errorDigest !== "string") {
          throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
        }
        return errorDigest;
      }
      function fatalError(request, error2) {
        var onShellError = request.onShellError;
        onShellError(error2);
        var onFatalError = request.onFatalError;
        onFatalError(error2);
        if (request.destination !== null) {
          request.status = CLOSED;
          closeWithError(request.destination, error2);
        } else {
          request.status = CLOSING;
          request.fatalError = error2;
        }
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary;
        var parentSegment = task.blockedSegment;
        var fallback = props.fallback;
        var content = props.children;
        var fallbackAbortSet = /* @__PURE__ */ new Set();
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
        var insertionIndex = parentSegment.chunks.length;
        var boundarySegment = createPendingSegment(
          request,
          insertionIndex,
          newBoundary,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          false,
          false
        );
        parentSegment.children.push(boundarySegment);
        parentSegment.lastPushedText = false;
        var contentRootSegment = createPendingSegment(
          request,
          0,
          null,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          false,
          false
        );
        contentRootSegment.parentFlushed = true;
        task.blockedBoundary = newBoundary;
        task.blockedSegment = contentRootSegment;
        try {
          renderNode(request, task, content);
          pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
          contentRootSegment.status = COMPLETED;
          queueCompletedSegment(newBoundary, contentRootSegment);
          if (newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error2) {
          contentRootSegment.status = ERRORED;
          newBoundary.forceClientRender = true;
          newBoundary.errorDigest = logRecoverableError(request, error2);
          {
            captureBoundaryErrorDetailsDev(newBoundary, error2);
          }
        } finally {
          task.blockedBoundary = parentBoundary;
          task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        {
          suspendedFallbackTask.componentStack = task.componentStack;
        }
        request.pingedTasks.push(suspendedFallbackTask);
        popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type);
        var segment = task.blockedSegment;
        var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
        segment.lastPushedText = false;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type, props);
        renderNode(request, task, children);
        segment.formatContext = prevContext;
        pushEndInstance(segment.chunks, type);
        segment.lastPushedText = false;
        popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result = Component(props, secondArg);
        return finishHooks(Component, props, result, secondArg);
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        {
          if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) {
              error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        {
          var childContextTypes = Component.childContextTypes;
          if (childContextTypes !== null && childContextTypes !== void 0) {
            var previousContext = task.legacyContext;
            var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext;
            renderNodeDestructive(request, task, nextChildren);
            task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext);
        var instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext);
        finishClassComponent(request, task, instance, Component, props);
        popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {};
      var didWarnAboutModulePatternComponent = {};
      var didWarnAboutContextTypeOnFunctionComponent = {};
      var didWarnAboutGetDerivedStateOnFunctionComponent = {};
      var didWarnAboutReassigningProps = false;
      var didWarnAboutDefaultPropsOnFunctionComponent = {};
      var didWarnAboutGenerators = false;
      var didWarnAboutMaps = false;
      var hasWarnedAboutUsingContextAsConsumer = false;
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        {
          legacyContext = getMaskedContext(Component, task.legacyContext);
        }
        pushFunctionComponentStackInDEV(task, Component);
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
        }
        var value = renderWithHooks(request, task, Component, props, legacyContext);
        var hasId = checkDidRenderIdHook();
        {
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (
          // Run these checks in production only if the flag is off.
          // Eventually we'll delete this branch altogether.
          typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
        ) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          mountClassInstance(value, Component, props, legacyContext);
          finishClassComponent(request, task, value, Component, props);
        } else {
          {
            validateFunctionComponentInDev(Component);
          }
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, value);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, value);
          }
        }
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (Component.defaultProps !== void 0) {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
              error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
              didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === void 0) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render);
        var children = renderWithHooks(request, task, type.render, props, ref);
        var hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext;
          var totalChildren = 1;
          var index = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else {
          renderNodeDestructive(request, task, children);
        }
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type, props, ref) {
        var innerType = type.type;
        var resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
      }
      function renderContextConsumer(request, task, context, props) {
        {
          if (context._context === void 0) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var render = props.children;
        {
          if (typeof render !== "function") {
            error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          }
        }
        var newValue = readContext(context);
        var newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type, props) {
        var context = type._context;
        var value = props.value;
        var children = props.children;
        var prevSnapshot;
        {
          prevSnapshot = task.context;
        }
        task.context = pushProvider(context, value);
        renderNodeDestructive(request, task, children);
        task.context = popProvider(context);
        {
          if (prevSnapshot !== task.context) {
            error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
          }
        }
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload);
        var resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref);
        popComponentStackInDEV(task);
      }
      function renderElement(request, task, type, props, ref) {
        if (typeof type === "function") {
          if (shouldConstruct$1(type)) {
            renderClassComponent(request, task, type, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type, props);
            return;
          }
        }
        if (typeof type === "string") {
          renderHostElement(request, task, type, props);
          return;
        }
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList");
            renderNodeDestructive(request, task, props.children);
            popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE: {
            throw new Error("ReactDOMServer does not yet support scope components.");
          }
          case REACT_SUSPENSE_TYPE: {
            {
              renderSuspenseBoundary(request, task, props);
            }
            return;
          }
        }
        if (typeof type === "object" && type !== null) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type, props, ref);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type, props, ref);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type, props);
              return;
            }
          }
        }
        var info = "";
        {
          if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          }
        }
        throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        {
          if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
          iterable[Symbol.toStringTag] === "Generator") {
            if (!didWarnAboutGenerators) {
              error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
            }
            didWarnAboutGenerators = true;
          }
          if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) {
              error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
            }
            didWarnAboutMaps = true;
          }
        }
      }
      function renderNodeDestructive(request, task, node) {
        {
          try {
            return renderNodeDestructiveImpl(request, task, node);
          } catch (x) {
            if (typeof x === "object" && x !== null && typeof x.then === "function") ;
            else {
              lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
            }
            throw x;
          }
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        task.node = node;
        if (typeof node === "object" && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node;
              var type = element.type;
              var props = element.props;
              var ref = element.ref;
              renderElement(request, task, type, props, ref);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node;
              var payload = lazyNode._payload;
              var init = lazyNode._init;
              var resolvedNode;
              {
                try {
                  resolvedNode = init(payload);
                } catch (x) {
                  if (typeof x === "object" && x !== null && typeof x.then === "function") {
                    pushBuiltInComponentStackInDEV(task, "Lazy");
                  }
                  throw x;
                }
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray(node)) {
            renderChildrenArray(request, task, node);
            return;
          }
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            {
              validateIterable(node, iteratorFn);
            }
            var iterator = iteratorFn.call(node);
            if (iterator) {
              var step = iterator.next();
              if (!step.done) {
                var children = [];
                do {
                  children.push(step.value);
                  step = iterator.next();
                } while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        if (typeof node === "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node === "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
          return;
        }
        {
          if (typeof node === "function") {
            error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
      }
      function renderChildrenArray(request, task, children) {
        var totalChildren = children.length;
        for (var i = 0; i < totalChildren; i++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
          try {
            renderNode(request, task, children[i]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x) {
        var segment = task.blockedSegment;
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(
          request,
          insertionIndex,
          null,
          segment.formatContext,
          // Adopt the parent segment's leading text embed
          segment.lastPushedText,
          // Assume we are text embedded at the trailing edge
          true
        );
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        {
          if (task.componentStack !== null) {
            newTask.componentStack = task.componentStack.parent;
          }
        }
        var ping = newTask.ping;
        x.then(ping, ping);
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext;
        var previousLegacyContext = task.legacyContext;
        var previousContext = task.context;
        var previousComponentStack = null;
        {
          previousComponentStack = task.componentStack;
        }
        try {
          return renderNodeDestructive(request, task, node);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            spawnNewSuspendedTask(request, task, x);
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            return;
          } else {
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            throw x;
          }
        }
      }
      function erroredTask(request, boundary, segment, error2) {
        var errorDigest = logRecoverableError(request, error2);
        if (boundary === null) {
          fatalError(request, error2);
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            boundary.errorDigest = errorDigest;
            {
              captureBoundaryErrorDetailsDev(boundary, error2);
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this;
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        if (boundary === null) {
          request.allPendingTasks--;
          if (request.status !== CLOSED) {
            request.status = CLOSED;
            if (request.destination !== null) {
              close(request.destination);
            }
          }
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              if (_error && typeof _error.message === "string") {
                _error = errorPrefix + _error.message;
              } else {
                _error = errorPrefix + String(_error);
              }
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
          boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          });
          boundary.fallbackAbortableTasks.clear();
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          if (childSegment.status === COMPLETED) {
            queueCompletedSegment(boundary, childSegment);
          }
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null) {
              throw new Error("There can only be one root segment. This is a bug in React.");
            }
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          if (request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else {
          boundary.pendingTasks--;
          if (boundary.forceClientRender) ;
          else if (boundary.pendingTasks === 0) {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
              }
            }
            if (boundary.parentFlushed) {
              request.completedBoundaries.push(boundary);
            }
            boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
            boundary.fallbackAbortableTasks.clear();
          } else {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
                var completedSegments = boundary.completedSegments;
                if (completedSegments.length === 1) {
                  if (boundary.parentFlushed) {
                    request.partialBoundaries.push(boundary);
                  }
                }
              }
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status !== PENDING) {
          return;
        }
        switchContext(task.context);
        var prevTaskInDEV = null;
        {
          prevTaskInDEV = currentTaskInDEV;
          currentTaskInDEV = task;
        }
        try {
          renderNodeDestructive(request, task, task.node);
          pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
          task.abortSet.delete(task);
          segment.status = COMPLETED;
          finishedTask(request, task.blockedBoundary, segment);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            var ping = task.ping;
            x.then(ping, ping);
          } else {
            task.abortSet.delete(task);
            segment.status = ERRORED;
            erroredTask(request, task.blockedBoundary, segment, x);
          }
        } finally {
          {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status === CLOSED) {
          return;
        }
        var prevContext = getActiveContext();
        var prevDispatcher = ReactCurrentDispatcher$1.current;
        ReactCurrentDispatcher$1.current = Dispatcher;
        var prevGetCurrentStackImpl;
        {
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
          ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
        }
        var prevResponseState = currentResponseState;
        setCurrentResponseState(request.responseState);
        try {
          var pingedTasks = request.pingedTasks;
          var i;
          for (i = 0; i < pingedTasks.length; i++) {
            var task = pingedTasks[i];
            retryTask(request, task);
          }
          pingedTasks.splice(0, i);
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        } finally {
          setCurrentResponseState(prevResponseState);
          ReactCurrentDispatcher$1.current = prevDispatcher;
          {
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
          }
          if (prevDispatcher === Dispatcher) {
            switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            segment.lastPushedText = false;
            segment.textEmbedded = false;
            return writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            var r2 = true;
            var chunks = segment.chunks;
            var chunkIdx = 0;
            var children = segment.children;
            for (var childIdx = 0; childIdx < children.length; childIdx++) {
              var nextChild = children[childIdx];
              for (; chunkIdx < nextChild.index; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              r2 = flushSegment(request, destination, nextChild);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++) {
              writeChunk(destination, chunks[chunkIdx]);
            }
            if (chunkIdx < chunks.length) {
              r2 = writeChunkAndReturn(destination, chunks[chunkIdx]);
            }
            return r2;
          }
          default: {
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
          }
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null) {
          return flushSubtree(request, destination, segment);
        }
        boundary.parentFlushed = true;
        if (boundary.forceClientRender) {
          writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          flushSubtree(request, destination, segment);
          return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
        } else if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++;
          if (boundary.completedSegments.length > 0) {
            request.partialBoundaries.push(boundary);
          }
          var id2 = boundary.id = assignSuspenseBoundaryID(request.responseState);
          writeStartPendingSuspenseBoundary(destination, request.responseState, id2);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else if (boundary.byteSize > request.progressiveChunkSize) {
          boundary.rootSegmentID = request.nextSegmentId++;
          request.completedBoundaries.push(boundary);
          writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1) {
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          }
          var contentSegment = completedSegments[0];
          flushSegment(request, destination, contentSegment);
          return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
        flushSegment(request, destination, segment);
        return writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (; i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        completedSegments.length = 0;
        return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (; i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
            i++;
            completedSegments.splice(0, i);
            return false;
          }
        }
        completedSegments.splice(0, i);
        return true;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) {
          return true;
        }
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1) {
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          }
          return flushSegmentContainer(request, destination, segment);
        } else {
          flushSegmentContainer(request, destination, segment);
          return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
        }
      }
      function flushCompletedQueues(request, destination) {
        try {
          var completedRootSegment = request.completedRootSegment;
          if (completedRootSegment !== null && request.pendingRootTasks === 0) {
            flushSegment(request, destination, completedRootSegment);
            request.completedRootSegment = null;
            writeCompletedRoot(destination, request.responseState);
          }
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          var i;
          for (i = 0; i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0; i < completedBoundaries.length; i++) {
            var _boundary = completedBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          }
          completedBoundaries.splice(0, i);
          completeWriting(destination);
          beginWriting(destination);
          var partialBoundaries = request.partialBoundaries;
          for (i = 0; i < partialBoundaries.length; i++) {
            var _boundary2 = partialBoundaries[i];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0; i < largeBoundaries.length; i++) {
            var _boundary3 = largeBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          }
          largeBoundaries.splice(0, i);
        } finally {
          if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
            {
              if (request.abortableTasks.size !== 0) {
                error("There was still abortable task at the root when we closed. This is a bug in React.");
              }
            }
            close(destination);
          }
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED;
          closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status === CLOSED) {
          return;
        }
        if (request.destination !== null) {
          return;
        }
        request.destination = destination;
        try {
          flushCompletedQueues(request, destination);
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          });
          abortableTasks.clear();
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function onError() {
      }
      function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
        var didFatal = false;
        var fatalError2 = null;
        var result = "";
        var destination = {
          push: function(chunk) {
            if (chunk !== null) {
              result += chunk;
            }
            return true;
          },
          destroy: function(error2) {
            didFatal = true;
            fatalError2 = error2;
          }
        };
        var readyToStream = false;
        function onShellReady() {
          readyToStream = true;
        }
        var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : void 0), createRootFormatContext(), Infinity, onError, void 0, onShellReady);
        startWork(request);
        abort(request, abortReason);
        startFlowing(request, destination);
        if (didFatal) {
          throw fatalError2;
        }
        if (!readyToStream) {
          throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
        }
        return result;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
        _inheritsLoose(ReactMarkupReadableStream2, _Readable);
        function ReactMarkupReadableStream2() {
          var _this;
          _this = _Readable.call(this, {}) || this;
          _this.request = null;
          _this.startedFlowing = false;
          return _this;
        }
        var _proto = ReactMarkupReadableStream2.prototype;
        _proto._destroy = function _destroy(err, callback) {
          abort(this.request);
          callback(err);
        };
        _proto._read = function _read(size) {
          if (this.startedFlowing) {
            startFlowing(this.request, this);
          }
        };
        return ReactMarkupReadableStream2;
      }(stream.Readable);
      function onError$1() {
      }
      function renderToNodeStreamImpl(children, options, generateStaticMarkup) {
        function onAllReady() {
          destination.startedFlowing = true;
          startFlowing(request, destination);
        }
        var destination = new ReactMarkupReadableStream();
        var request = createRequest(children, createResponseState$1(false, options ? options.identifierPrefix : void 0), createRootFormatContext(), Infinity, onError$1, onAllReady, void 0);
        destination.request = request;
        startWork(request);
        return destination;
      }
      function renderToNodeStream(children, options) {
        {
          error("renderToNodeStream is deprecated. Use renderToPipeableStream instead.");
        }
        return renderToNodeStreamImpl(children, options);
      }
      function renderToStaticNodeStream(children, options) {
        {
          error("ReactDOMServer.renderToStaticNodeStream() is deprecated. Use ReactDOMServer.renderToPipeableStream() and wait to `pipe` until the `onAllReady` callback has been called instead.");
        }
        return renderToNodeStreamImpl(children, options);
      }
      function renderToString2(children, options) {
        return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
      }
      function renderToStaticMarkup(children, options) {
        return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
      }
      reactDomServerLegacy_node_development.renderToNodeStream = renderToNodeStream;
      reactDomServerLegacy_node_development.renderToStaticMarkup = renderToStaticMarkup;
      reactDomServerLegacy_node_development.renderToStaticNodeStream = renderToStaticNodeStream;
      reactDomServerLegacy_node_development.renderToString = renderToString2;
      reactDomServerLegacy_node_development.version = ReactVersion;
    })();
  }
  return reactDomServerLegacy_node_development;
}
var reactDomServer_node_development = {};
/**
 * @license React
 * react-dom-server.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDomServer_node_development;
function requireReactDomServer_node_development() {
  if (hasRequiredReactDomServer_node_development) return reactDomServer_node_development;
  hasRequiredReactDomServer_node_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var React2 = requireReact();
      var util = require$$0;
      var ReactVersion = "18.3.1";
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        setImmediate(callback);
      }
      function flushBuffered(destination) {
        if (typeof destination.flush === "function") {
          destination.flush();
        }
      }
      var VIEW_SIZE = 2048;
      var currentView = null;
      var writtenBytes = 0;
      var destinationHasCapacity = true;
      function beginWriting(destination) {
        currentView = new Uint8Array(VIEW_SIZE);
        writtenBytes = 0;
        destinationHasCapacity = true;
      }
      function writeStringChunk(destination, stringChunk) {
        if (stringChunk.length === 0) {
          return;
        }
        if (stringChunk.length * 3 > VIEW_SIZE) {
          if (writtenBytes > 0) {
            writeToDestination(destination, currentView.subarray(0, writtenBytes));
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          writeToDestination(destination, textEncoder.encode(stringChunk));
          return;
        }
        var target = currentView;
        if (writtenBytes > 0) {
          target = currentView.subarray(writtenBytes);
        }
        var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target), read = _textEncoder$encodeIn.read, written = _textEncoder$encodeIn.written;
        writtenBytes += written;
        if (read < stringChunk.length) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written;
        }
        if (writtenBytes === VIEW_SIZE) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
      }
      function writeViewChunk(destination, chunk) {
        if (chunk.byteLength === 0) {
          return;
        }
        if (chunk.byteLength > VIEW_SIZE) {
          if (writtenBytes > 0) {
            writeToDestination(destination, currentView.subarray(0, writtenBytes));
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          writeToDestination(destination, chunk);
          return;
        }
        var bytesToWrite = chunk;
        var allowableBytes = currentView.length - writtenBytes;
        if (allowableBytes < bytesToWrite.byteLength) {
          if (allowableBytes === 0) {
            writeToDestination(destination, currentView);
          } else {
            currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
            writtenBytes += allowableBytes;
            writeToDestination(destination, currentView);
            bytesToWrite = bytesToWrite.subarray(allowableBytes);
          }
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
        currentView.set(bytesToWrite, writtenBytes);
        writtenBytes += bytesToWrite.byteLength;
        if (writtenBytes === VIEW_SIZE) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
      }
      function writeChunk(destination, chunk) {
        if (typeof chunk === "string") {
          writeStringChunk(destination, chunk);
        } else {
          writeViewChunk(destination, chunk);
        }
      }
      function writeToDestination(destination, view) {
        var currentHasCapacity = destination.write(view);
        destinationHasCapacity = destinationHasCapacity && currentHasCapacity;
      }
      function writeChunkAndReturn(destination, chunk) {
        writeChunk(destination, chunk);
        return destinationHasCapacity;
      }
      function completeWriting(destination) {
        if (currentView && writtenBytes > 0) {
          destination.write(currentView.subarray(0, writtenBytes));
        }
        currentView = null;
        writtenBytes = 0;
        destinationHasCapacity = true;
      }
      function close(destination) {
        destination.end();
      }
      var textEncoder = new util.TextEncoder();
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return textEncoder.encode(content);
      }
      function closeWithError(destination, error2) {
        destination.destroy(error2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        // TODO: This prevents the assignment of defaultValue to regular
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "allowFullScreen",
        "async",
        // Note: there is a special case that prevents it from being written to the DOM
        // on the client side because the browsers are inconsistent. Instead we call focus().
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        // Microdata
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "checked",
        // Note: `option.selected` is not updated if `select.multiple` is
        // disabled with `removeAttribute`. We have special logic for handling this.
        "multiple",
        "muted",
        "selected"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          true,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "capture",
        "download"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "cols",
        "rows",
        "size",
        "span"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          false,
          // mustUseProperty
          name,
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          false,
          // mustUseProperty
          name.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/1999/xlink",
          false,
          // sanitizeURL
          false
        );
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
        // NOTE: if you add a camelCased prop to this list,
        // you'll need to set attributeName to name.toLowerCase()
        // instead in the assignment below.
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          false,
          // mustUseProperty
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          false,
          // sanitizeURL
          false
        );
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          false,
          // sanitizeURL
          false
        );
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        false,
        // mustUseProperty
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        true,
        // sanitizeURL
        false
      );
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          false,
          // mustUseProperty
          attributeName.toLowerCase(),
          // attributeName
          null,
          // attributeNamespace
          true,
          // sanitizeURL
          true
        );
      });
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        // state
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        // state
        "aria-hidden": 0,
        // state
        "aria-invalid": 0,
        // state
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        // Widget Attributes
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        // Live Region Attributes
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        // Drag-and-Drop Attributes
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        // Relationship Attributes
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
            return true;
          }
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
              warnedProperties[name] = true;
              return true;
            }
            if (name !== correctName) {
              error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
              warnedProperties[name] = true;
              return true;
            }
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name] = true;
              return false;
            }
            if (name !== standardName) {
              error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties[name] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid = validateProperty(type, key);
            if (!isValid) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          } else if (invalidProps.length > 1) {
            error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === "select" && props.multiple) {
              error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            } else {
              error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
            }
          }
        }
      }
      var possibleStandardNames = {
        // HTML
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        // SVG
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
            return true;
          }
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (eventRegistry != null) {
            var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies.hasOwnProperty(name)) {
              return true;
            }
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
              error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
              error("Unknown event handler property `%s`. It will be ignored.", name);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name)) {
            if (INVALID_EVENT_NAME_REGEX.test(name)) {
              error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "number" && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
              error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (!isReserved && name !== lowerCasedName) {
            error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo)) {
            if (value) {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
            } else {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo)) {
            warnedProperties$1[name] = true;
            return false;
          }
          if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties$1[name] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          } else if (unknownProps.length > 1) {
            error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          }
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnUnknownProperties(type, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error(
            "Unsupported style property %s. Did you mean %s?",
            name,
            // As Andi Smith suggests
            // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
            // is converted to lowercase `ms`.
            camelize(name.replace(msPattern, "ms-"))
          );
        };
        var warnBadVendoredStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name, value) {
          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
            return;
          }
          warnedStyleValues[value] = true;
          error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name, value) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error("`NaN` is an invalid value for the `%s` css style property.", name);
        };
        var warnStyleValueIsInfinity = function(name, value) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error("`Infinity` is an invalid value for the `%s` css style property.", name);
        };
        warnValidStyle = function(name, value) {
          if (name.indexOf("-") > -1) {
            warnHyphenatedStyleName(name);
          } else if (badVendoredStyleNamePattern.test(name)) {
            warnBadVendoredStyleName(name);
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name, value);
          }
          if (typeof value === "number") {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name, value);
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name, value);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      var matchHtmlRegExp = /["'&<>]/;
      function escapeHtml2(string) {
        {
          checkHtmlStringCoercion(string);
        }
        var str = "" + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
          return str;
        }
        var escape;
        var html = "";
        var index;
        var lastIndex = 0;
        for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape = "&quot;";
              break;
            case 38:
              escape = "&amp;";
              break;
            case 39:
              escape = "&#x27;";
              break;
            case 60:
              escape = "&lt;";
              break;
            case 62:
              escape = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escape;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      function escapeTextForBrowser(text) {
        if (typeof text === "boolean" || typeof text === "number") {
          return "" + text;
        }
        return escapeHtml2(text);
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern$1 = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var startInlineScript = stringToPrecomputedChunk("<script>");
      var endInlineScript = stringToPrecomputedChunk("<\/script>");
      var startScriptSrc = stringToPrecomputedChunk('<script src="');
      var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
      var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
      function escapeBootstrapScriptContent(scriptText) {
        {
          checkHtmlStringCoercion(scriptText);
        }
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi;
      var scriptReplacer = function(match, prefix2, s2, suffix) {
        return "" + prefix2 + (s2 === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
        var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
        var bootstrapChunks = [];
        if (bootstrapScriptContent !== void 0) {
          bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
        }
        if (bootstrapScripts !== void 0) {
          for (var i = 0; i < bootstrapScripts.length; i++) {
            bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
          }
        }
        if (bootstrapModules !== void 0) {
          for (var _i = 0; _i < bootstrapModules.length; _i++) {
            bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
          }
        }
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: false,
          sentCompleteBoundaryFunction: false,
          sentClientRenderFunction: false
        };
      }
      var ROOT_HTML_MODE = 0;
      var HTML_MODE = 1;
      var SVG_MODE = 2;
      var MATHML_MODE = 3;
      var HTML_TABLE_MODE = 4;
      var HTML_TABLE_BODY_MODE = 5;
      var HTML_TABLE_ROW_MODE = 6;
      var HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function createRootFormatContext(namespaceURI) {
        var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
        return createFormatContext(insertionMode, null);
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        if (parentContext.insertionMode === ROOT_HTML_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        return parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix;
        var id2 = ":" + idPrefix + "R" + treeId;
        if (localId > 0) {
          id2 += "H" + localId.toString(32);
        }
        return id2 + ":";
      }
      function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text);
      }
      var textSeparator = stringToPrecomputedChunk("<!-- -->");
      function pushTextInstance(target, text, responseState, textEmbedded) {
        if (text === "") {
          return textEmbedded;
        }
        if (textEmbedded) {
          target.push(textSeparator);
        }
        target.push(stringToChunk(encodeHTMLTextNode(text)));
        return true;
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        if (lastPushedText && textEmbedded) {
          target.push(textSeparator);
        }
      }
      var styleNameCache = /* @__PURE__ */ new Map();
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== void 0) {
          return chunk;
        }
        var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        styleNameCache.set(styleName, result);
        return result;
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="');
      var styleAssign = stringToPrecomputedChunk(":");
      var styleSeparator = stringToPrecomputedChunk(";");
      function pushStyle(target, responseState, style) {
        if (typeof style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
        var isFirst = true;
        for (var styleName in style) {
          if (!hasOwnProperty.call(style, styleName)) {
            continue;
          }
          var styleValue = style[styleName];
          if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
            continue;
          }
          var nameChunk = void 0;
          var valueChunk = void 0;
          var isCustomProperty = styleName.indexOf("--") === 0;
          if (isCustomProperty) {
            nameChunk = stringToChunk(escapeTextForBrowser(styleName));
            {
              checkCSSPropertyStringCoercion(styleValue, styleName);
            }
            valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
          } else {
            {
              warnValidStyle$1(styleName, styleValue);
            }
            nameChunk = processStyleName(styleName);
            if (typeof styleValue === "number") {
              if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                valueChunk = stringToChunk(styleValue + "px");
              } else {
                valueChunk = stringToChunk("" + styleValue);
              }
            } else {
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            }
          }
          if (isFirst) {
            isFirst = false;
            target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
          } else {
            target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
          }
        }
        if (!isFirst) {
          target.push(attributeEnd);
        }
      }
      var attributeSeparator = stringToPrecomputedChunk(" ");
      var attributeAssign = stringToPrecomputedChunk('="');
      var attributeEnd = stringToPrecomputedChunk('"');
      var attributeEmptyString = stringToPrecomputedChunk('=""');
      function pushAttribute(target, responseState, name, value) {
        switch (name) {
          case "style": {
            pushStyle(target, responseState, value);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (
          // shouldIgnoreAttribute
          // We have already filtered out null/undefined and reserved words.
          name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")
        ) {
          return;
        }
        var propertyInfo = getPropertyInfo(name);
        if (propertyInfo !== null) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              if (!propertyInfo.acceptsBooleans) {
                return;
              }
            }
          }
          var attributeName = propertyInfo.attributeName;
          var attributeNameChunk = stringToChunk(attributeName);
          switch (propertyInfo.type) {
            case BOOLEAN:
              if (value) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              }
              return;
            case OVERLOADED_BOOLEAN:
              if (value === true) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              } else if (value === false) ;
              else {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              return;
            case NUMERIC:
              if (!isNaN(value)) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            case POSITIVE_NUMERIC:
              if (!isNaN(value) && value >= 1) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            default:
              if (propertyInfo.sanitizeURL) {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                value = "" + value;
                sanitizeURL(value);
              }
              target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        } else if (isAttributeNameSafe(name)) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var prefix2 = name.toLowerCase().slice(0, 5);
              if (prefix2 !== "data-" && prefix2 !== "aria-") {
                return;
              }
            }
          }
          target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
        }
      }
      var endOfStartTag = stringToPrecomputedChunk(">");
      var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== void 0) {
            {
              checkHtmlStringCoercion(html);
            }
            target.push(stringToChunk("" + html));
          }
        }
      }
      var didWarnDefaultInputValue = false;
      var didWarnDefaultChecked = false;
      var didWarnDefaultSelectValue = false;
      var didWarnDefaultTextareaValue = false;
      var didWarnInvalidOptionChildren = false;
      var didWarnInvalidOptionInnerHTML = false;
      var didWarnSelectedSetOnOption = false;
      function checkSelectProp(props, propName) {
        {
          var value = props[propName];
          if (value != null) {
            var array = isArray(value);
            if (props.multiple && !array) {
              error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
            } else if (!props.multiple && array) {
              error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
            }
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        {
          checkControlledValueProps("select", props);
          checkSelectProp(props, "value");
          checkSelectProp(props, "defaultValue");
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
            error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultSelectValue = true;
          }
        }
        target.push(startChunkForTag("select"));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        React2.Children.forEach(children, function(child) {
          if (child == null) {
            return;
          }
          content += child;
          {
            if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
              didWarnInvalidOptionChildren = true;
              error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
            }
          }
        });
        return content;
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null;
        var value = null;
        var selected = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue;
                {
                  if (!didWarnSelectedSetOnOption) {
                    error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                    didWarnSelectedSetOnOption = true;
                  }
                }
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (selectedValue != null) {
          var stringValue;
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            stringValue = "" + value;
          } else {
            {
              if (innerHTML !== null) {
                if (!didWarnInvalidOptionInnerHTML) {
                  didWarnInvalidOptionInnerHTML = true;
                  error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            stringValue = flattenOptionChildren(children);
          }
          if (isArray(selectedValue)) {
            for (var i = 0; i < selectedValue.length; i++) {
              {
                checkAttributeStringCoercion(selectedValue[i], "value");
              }
              var v = "" + selectedValue[i];
              if (v === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          } else {
            {
              checkAttributeStringCoercion(selectedValue, "select.value");
            }
            if ("" + selectedValue === stringValue) {
              target.push(selectedMarkerAttribute);
            }
          }
        } else if (selected) {
          target.push(selectedMarkerAttribute);
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function pushInput(target, props, responseState) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultChecked = true;
          }
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
            error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultInputValue = true;
          }
        }
        target.push(startChunkForTag("input"));
        var value = null;
        var defaultValue = null;
        var checked = null;
        var defaultChecked = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked = propValue;
                break;
              case "value":
                value = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (checked !== null) {
          pushAttribute(target, responseState, "checked", checked);
        } else if (defaultChecked !== null) {
          pushAttribute(target, responseState, "checked", defaultChecked);
        }
        if (value !== null) {
          pushAttribute(target, responseState, "value", value);
        } else if (defaultValue !== null) {
          pushAttribute(target, responseState, "value", defaultValue);
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartTextArea(target, props, responseState) {
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
            error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultTextareaValue = true;
          }
        }
        target.push(startChunkForTag("textarea"));
        var value = null;
        var defaultValue = null;
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (value === null && defaultValue !== null) {
          value = defaultValue;
        }
        target.push(endOfStartTag);
        if (children != null) {
          {
            error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          }
          if (value != null) {
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          }
          if (isArray(children)) {
            if (children.length > 1) {
              throw new Error("<textarea> can only have at most one child.");
            }
            {
              checkHtmlStringCoercion(children[0]);
            }
            value = "" + children[0];
          }
          {
            checkHtmlStringCoercion(children);
          }
          value = "" + children;
        }
        if (typeof value === "string" && value[0] === "\n") {
          target.push(leadingNewline);
        }
        if (value !== null) {
          {
            checkAttributeStringCoercion(value, "value");
          }
          target.push(stringToChunk(encodeHTMLTextNode("" + value)));
        }
        return null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        return null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          if (Array.isArray(children) && children.length > 1) {
            error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && child.$$typeof != null) {
            error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && typeof child !== "string" && typeof child !== "number") {
            error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          }
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        if (typeof children === "string") {
          target.push(stringToChunk(encodeHTMLTextNode(children)));
          return null;
        }
        return children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                  target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                }
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      var leadingNewline = stringToPrecomputedChunk("\n");
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== void 0) {
            if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
              target.push(leadingNewline, stringToChunk(html));
            } else {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        if (typeof children === "string" && children[0] === "\n") {
          target.push(leadingNewline);
        }
        return children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
      var validatedTagCache = /* @__PURE__ */ new Map();
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === void 0) {
          if (!VALID_TAG_REGEX.test(tag)) {
            throw new Error("Invalid tag: " + tag);
          }
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
      function pushStartInstance(target, type, props, responseState, formatContext) {
        {
          validateProperties(type, props);
          validateProperties$1(type, props);
          validateProperties$2(type, props, null);
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
          }
          if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
            if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
              error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
            }
          }
        }
        switch (type) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre": {
            return pushStartPreformattedElement(target, props, type, responseState);
          }
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            return pushSelfClosing(target, props, type, responseState);
          }
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph": {
            return pushStartGenericElement(target, props, type, responseState);
          }
          case "html": {
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              target.push(DOCTYPE);
            }
            return pushStartGenericElement(target, props, type, responseState);
          }
          default: {
            if (type.indexOf("-") === -1 && typeof props.is !== "string") {
              return pushStartGenericElement(target, props, type, responseState);
            } else {
              return pushStartCustomElement(target, props, type, responseState);
            }
          }
        }
      }
      var endTag1 = stringToPrecomputedChunk("</");
      var endTag2 = stringToPrecomputedChunk(">");
      function pushEndInstance(target, type, props) {
        switch (type) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            break;
          }
          default: {
            target.push(endTag1, stringToChunk(type), endTag2);
          }
        }
      }
      function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks;
        var i = 0;
        for (; i < bootstrapChunks.length - 1; i++) {
          writeChunk(destination, bootstrapChunks[i]);
        }
        if (i < bootstrapChunks.length) {
          return writeChunkAndReturn(destination, bootstrapChunks[i]);
        }
        return true;
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="');
      var placeholder2 = stringToPrecomputedChunk('"></template>');
      function writePlaceholder(destination, responseState, id2) {
        writeChunk(destination, placeholder1);
        writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id2.toString(16));
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
      var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
      var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
      var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
      var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
      var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
      var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
      var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
      var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
      var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
      var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id2) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (id2 === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, id2);
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result;
        result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        if (errorDigest) {
          writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
          writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
          writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        {
          if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
        }
        result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        return result;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
      var startSegmentHTML2 = stringToPrecomputedChunk('">');
      var endSegmentHTML = stringToPrecomputedChunk("</div>");
      var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
      var startSegmentSVG2 = stringToPrecomputedChunk('">');
      var endSegmentSVG = stringToPrecomputedChunk("</svg>");
      var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
      var startSegmentMathML2 = stringToPrecomputedChunk('">');
      var endSegmentMathML = stringToPrecomputedChunk("</math>");
      var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
      var startSegmentTable2 = stringToPrecomputedChunk('">');
      var endSegmentTable = stringToPrecomputedChunk("</table>");
      var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
      var startSegmentTableBody2 = stringToPrecomputedChunk('">');
      var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
      var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
      var startSegmentTableRow2 = stringToPrecomputedChunk('">');
      var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
      var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
      var startSegmentColGroup2 = stringToPrecomputedChunk('">');
      var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
      function writeStartSegment(destination, responseState, formatContext, id2) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            writeChunk(destination, startSegmentHTML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentHTML2);
          }
          case SVG_MODE: {
            writeChunk(destination, startSegmentSVG);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentSVG2);
          }
          case MATHML_MODE: {
            writeChunk(destination, startSegmentMathML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentMathML2);
          }
          case HTML_TABLE_MODE: {
            writeChunk(destination, startSegmentTable);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTable2);
          }
          case HTML_TABLE_BODY_MODE: {
            writeChunk(destination, startSegmentTableBody);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableBody2);
          }
          case HTML_TABLE_ROW_MODE: {
            writeChunk(destination, startSegmentTableRow);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableRow2);
          }
          case HTML_COLGROUP_MODE: {
            writeChunk(destination, startSegmentColGroup);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id2.toString(16)));
            return writeChunkAndReturn(destination, startSegmentColGroup2);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            return writeChunkAndReturn(destination, endSegmentHTML);
          }
          case SVG_MODE: {
            return writeChunkAndReturn(destination, endSegmentSVG);
          }
          case MATHML_MODE: {
            return writeChunkAndReturn(destination, endSegmentMathML);
          }
          case HTML_TABLE_MODE: {
            return writeChunkAndReturn(destination, endSegmentTable);
          }
          case HTML_TABLE_BODY_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableBody);
          }
          case HTML_TABLE_ROW_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableRow);
          }
          case HTML_COLGROUP_MODE: {
            return writeChunkAndReturn(destination, endSegmentColGroup);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
      var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
      var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
      var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
      var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
      var completeSegmentScript2 = stringToPrecomputedChunk('","');
      var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteSegmentFunction) {
          responseState.sentCompleteSegmentFunction = true;
          writeChunk(destination, completeSegmentScript1Full);
        } else {
          writeChunk(destination, completeSegmentScript1Partial);
        }
        writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, formattedID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, responseState.placeholderPrefix);
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
      var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
      var completeBoundaryScript2 = stringToPrecomputedChunk('","');
      var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteBoundaryFunction) {
          responseState.sentCompleteBoundaryFunction = true;
          writeChunk(destination, completeBoundaryScript1Full);
        } else {
          writeChunk(destination, completeBoundaryScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, boundaryID);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, responseState.segmentPrefix);
        writeChunk(destination, formattedContentID);
        return writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
      var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
      var clientRenderScript1A = stringToPrecomputedChunk('"');
      var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
      var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentClientRenderFunction) {
          responseState.sentClientRenderFunction = true;
          writeChunk(destination, clientRenderScript1Full);
        } else {
          writeChunk(destination, clientRenderScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, boundaryID);
        writeChunk(destination, clientRenderScript1A);
        if (errorDigest || errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
        }
        if (errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
        }
        if (errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
        }
        return writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default: {
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
            }
          }
        });
      }
      var assign = Object.assign;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame2 = componentFrameCache.get(fn);
          if (frame2 !== void 0) {
            return frame2;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s2 = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s2 >= 1 && c >= 0 && sampleLines[s2] !== controlLines[c]) {
              c--;
            }
            for (; s2 >= 1 && c >= 0; s2--, c--) {
              if (sampleLines[s2] !== controlLines[c]) {
                if (s2 !== 1 || c !== 1) {
                  do {
                    s2--;
                    c--;
                    if (c < 0 || sampleLines[s2] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s2 >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      function getMaskedContext(type, unmaskedContext) {
        {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return context;
        }
      }
      function processChildContext(instance, type, parentContext, childContextTypes) {
        {
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
            }
          }
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var rootContextSnapshot = null;
      var currentActiveSnapshot = null;
      function popNode(prev) {
        {
          prev.context._currentValue = prev.parentValue;
        }
      }
      function pushNode(next) {
        {
          next.context._currentValue = next.value;
        }
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev === next) ;
        else {
          popNode(prev);
          var parentPrev = prev.parent;
          var parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
          } else {
            if (parentNext === null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev !== null) {
          popAllPrevious(parentPrev);
        }
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        if (parentNext !== null) {
          pushAllNext(parentNext);
        }
        pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (parentPrev.depth === next.depth) {
          popToNearestCommonAncestor(parentPrev, next);
        } else {
          popPreviousToCommonLevel(parentPrev, next);
        }
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (prev.depth === parentNext.depth) {
          popToNearestCommonAncestor(prev, parentNext);
        } else {
          popNextToCommonLevel(prev, parentNext);
        }
        pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        var next = newSnapshot;
        if (prev !== next) {
          if (prev === null) {
            pushAllNext(next);
          } else if (next === null) {
            popAllPrevious(prev);
          } else if (prev.depth === next.depth) {
            popToNearestCommonAncestor(prev, next);
          } else if (prev.depth > next.depth) {
            popPreviousToCommonLevel(prev, next);
          } else {
            popNextToCommonLevel(prev, next);
          }
          currentActiveSnapshot = next;
        }
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        {
          prevValue = context._currentValue;
          context._currentValue = nextValue;
          {
            if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
        var prevNode = currentActiveSnapshot;
        var newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        currentActiveSnapshot = newNode;
        return newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null) {
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        }
        {
          if (prevSnapshot.context !== context) {
            error("The parent context is not the expected context. This is probably a bug in React.");
          }
        }
        {
          var value = prevSnapshot.parentValue;
          if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
            prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
          } else {
            prevSnapshot.context._currentValue = value;
          }
          {
            if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value = context._currentValue;
        return value;
      }
      function get(key) {
        return key._reactInternals;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var didWarnAboutNoopUpdateForComponent = {};
      var didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
        didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey]) {
            return;
          }
          error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
          didWarnAboutNoopUpdateForComponent[warningKey] = true;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return false;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "setState");
          } else {
            internals.queue.push(payload);
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get(inst);
          internals.replace = true;
          internals.queue = [payload];
          {
            if (callback !== void 0 && callback !== null) {
              warnOnInvalidCallback(callback, "setState");
            }
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "forceUpdate");
          } else {
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        }
      };
      function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var newState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid = (
              // Allow null for conditional declaration
              contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
            );
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === void 0) {
                addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== void 0) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          context = maskedLegacyContext;
        }
        var instance = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        return instance;
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            } else {
              error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
          }
          if (instance.propTypes) {
            error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
          }
          if (instance.contextType) {
            error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
          }
          {
            if (instance.contextTypes) {
              error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== void 0 && hasMutatedProps) {
            error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
          }
          if (instance.defaultProps) {
            error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray(_state))) {
            error("%s.state: must be set to an object or null", name);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
          }
        }
      }
      function callComponentWillMount(type, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          {
            if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!didWarnAboutDeprecatedWillMount[componentName]) {
                warn(
                  // keep this warning in sync with ReactStrictModeWarning.js
                  "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                  componentName
                );
                didWarnAboutDeprecatedWillMount[componentName] = true;
              }
            }
          }
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue;
          var oldReplace = internalInstance.replace;
          internalInstance.queue = null;
          internalInstance.replace = false;
          if (oldReplace && oldQueue.length === 1) {
            inst.state = oldQueue[0];
          } else {
            var nextState = oldReplace ? oldQueue[0] : inst.state;
            var dontMutate = true;
            for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
              var partial = oldQueue[i];
              var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
              if (partialState != null) {
                if (dontMutate) {
                  dontMutate = false;
                  nextState = assign({}, nextState, partialState);
                } else {
                  assign(nextState, partialState);
                }
              }
            }
            inst.state = nextState;
          }
        } else {
          internalInstance.queue = null;
        }
      }
      function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        {
          checkClassInstance(instance, ctor, newProps);
        }
        var initialState = instance.state !== void 0 ? instance.state : null;
        instance.updater = classComponentUpdater;
        instance.props = newProps;
        instance.state = initialState;
        var internalInstance = {
          queue: [],
          replace: false
        };
        set(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          instance.context = maskedLegacyContext;
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
          }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(ctor, instance);
          processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
        }
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow;
        var idWithLeadingBit = context.id;
        var id2 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id2.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        var baseOverflow = baseContext.overflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id2 = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id2,
            overflow
          };
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id2) {
        return 1 << getBitLength(id2) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var currentlyRenderingComponent = null;
      var currentlyRenderingTask = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var isReRender = false;
      var didScheduleRenderPhaseUpdate = false;
      var localIdCounter = 0;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;
      var isInHookUserCodeInDev = false;
      var currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        {
          if (isInHookUserCodeInDev) {
            error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          }
        }
        return currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
          }
        }
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function createHook() {
        if (numberOfReRenders > 0) {
          throw new Error("Rendered more hooks than during the previous render");
        }
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false;
            firstWorkInProgressHook = workInProgressHook = createHook();
          } else {
            isReRender = true;
            workInProgressHook = firstWorkInProgressHook;
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false;
            workInProgressHook = workInProgressHook.next = createHook();
          } else {
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
          }
        }
        return workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity;
        currentlyRenderingTask = task;
        {
          isInHookUserCodeInDev = false;
        }
        localIdCounter = 0;
      }
      function finishHooks(Component, props, children, refOrContext) {
        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false;
          localIdCounter = 0;
          numberOfReRenders += 1;
          workInProgressHook = null;
          children = Component(props, refOrContext);
        }
        resetHooksState();
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        {
          isInHookUserCodeInDev = false;
        }
        currentlyRenderingComponent = null;
        currentlyRenderingTask = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        renderPhaseUpdates = null;
        workInProgressHook = null;
      }
      function readContext$1(context) {
        {
          if (isInHookUserCodeInDev) {
            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          }
        }
        return readContext(context);
      }
      function useContext(context) {
        {
          currentHookNameInDev = "useContext";
        }
        resolveCurrentlyRenderingComponent();
        return readContext(context);
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function useState(initialState) {
        {
          currentHookNameInDev = "useState";
        }
        return useReducer(
          basicStateReducer,
          // useReducer has a special case to support lazy useState initializers
          initialState
        );
      }
      function useReducer(reducer, initialArg, init) {
        {
          if (reducer !== basicStateReducer) {
            currentHookNameInDev = "useReducer";
          }
        }
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          var queue = workInProgressHook.queue;
          var dispatch = queue.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate !== void 0) {
              renderPhaseUpdates.delete(queue);
              var newState = workInProgressHook.memoizedState;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                {
                  isInHookUserCodeInDev = true;
                }
                newState = reducer(newState, action);
                {
                  isInHookUserCodeInDev = false;
                }
                update = update.next;
              } while (update !== null);
              workInProgressHook.memoizedState = newState;
              return [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          {
            isInHookUserCodeInDev = true;
          }
          var initialState;
          if (reducer === basicStateReducer) {
            initialState = typeof initialArg === "function" ? initialArg() : initialArg;
          } else {
            initialState = init !== void 0 ? init(initialArg) : initialArg;
          }
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          };
          var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
        }
        {
          isInHookUserCodeInDev = true;
        }
        var nextValue = nextCreate();
        {
          isInHookUserCodeInDev = false;
        }
        workInProgressHook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          {
            Object.seal(ref);
          }
          workInProgressHook.memoizedState = ref;
          return ref;
        } else {
          return previousRef;
        }
      }
      function useLayoutEffect(create, inputs) {
        {
          currentHookNameInDev = "useLayoutEffect";
          error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
        }
      }
      function dispatchAction(componentIdentity, queue, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) {
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        }
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            action,
            next: null
          };
          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = /* @__PURE__ */ new Map();
          }
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
          if (firstRenderPhaseUpdate === void 0) {
            renderPhaseUpdates.set(queue, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe) {
        resolveCurrentlyRenderingComponent();
        return getSnapshot(source._source);
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === void 0) {
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        }
        return getServerSnapshot();
      }
      function useDeferredValue(value) {
        resolveCurrentlyRenderingComponent();
        return value;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition() {
        resolveCurrentlyRenderingComponent();
        return [false, unsupportedStartTransition];
      }
      function useId() {
        var task = currentlyRenderingTask;
        var treeId = getTreeId(task.treeContext);
        var responseState = currentResponseState;
        if (responseState === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        }
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop2() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop2,
        useLayoutEffect,
        useCallback,
        // useImperativeHandle is not run in the server environment
        useImperativeHandle: noop2,
        // Effects are not run in the server environment.
        useEffect: noop2,
        // Debugging effect
        useDebugValue: noop2,
        useDeferredValue,
        useTransition,
        useId,
        // Subscriptions are not setup in a server environment.
        useMutableSource,
        useSyncExternalStore
      };
      var currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "";
          var node = componentStack;
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node.type, null, null);
                break;
            }
            node = node.parent;
          } while (node);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      var PENDING = 0;
      var COMPLETED = 1;
      var FLUSHED = 2;
      var ABORTED = 3;
      var ERRORED = 4;
      var OPEN = 0;
      var CLOSING = 1;
      var CLOSED = 2;
      var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error2) {
        console["error"](error2);
        return null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [];
        var abortSet = /* @__PURE__ */ new Set();
        var request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError === void 0 ? defaultErrorHandler : onError,
          onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
          onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
          onShellError: onShellError === void 0 ? noop$1 : onShellError,
          onFatalError: noop$1
        };
        var rootSegment = createPendingSegment(
          request,
          0,
          null,
          rootFormatContext,
          // Root segments are never embedded in Text on either edge
          false,
          false
        );
        rootSegment.parentFlushed = true;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        pingedTasks.push(rootTask);
        return request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task);
        if (pingedTasks.length === 1) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          forceClientRender: false,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++;
        if (blockedBoundary === null) {
          request.pendingRootTasks++;
        } else {
          blockedBoundary.pendingTasks++;
        }
        var task = {
          node,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        {
          task.componentStack = null;
        }
        abortSet.add(task);
        return task;
      }
      function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          // lazily assigned later
          index,
          parentFlushed: false,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        {
          if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
            return "";
          }
          return getStackByComponentStackNode(currentTaskInDEV.componentStack);
        }
      }
      function pushBuiltInComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushFunctionComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushClassComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type
          };
        }
      }
      function popComponentStackInDEV(task) {
        {
          if (task.componentStack === null) {
            error("Unexpectedly popped too many stack frames. This is a bug in React.");
          } else {
            task.componentStack = task.componentStack.parent;
          }
        }
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error2) {
        {
          var errorMessage;
          if (typeof error2 === "string") {
            errorMessage = error2;
          } else if (error2 && typeof error2.message === "string") {
            errorMessage = error2.message;
          } else {
            errorMessage = String(error2);
          }
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null;
          boundary.errorMessage = errorMessage;
          boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error2) {
        var errorDigest = request.onError(error2);
        if (errorDigest != null && typeof errorDigest !== "string") {
          throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
        }
        return errorDigest;
      }
      function fatalError(request, error2) {
        var onShellError = request.onShellError;
        onShellError(error2);
        var onFatalError = request.onFatalError;
        onFatalError(error2);
        if (request.destination !== null) {
          request.status = CLOSED;
          closeWithError(request.destination, error2);
        } else {
          request.status = CLOSING;
          request.fatalError = error2;
        }
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary;
        var parentSegment = task.blockedSegment;
        var fallback = props.fallback;
        var content = props.children;
        var fallbackAbortSet = /* @__PURE__ */ new Set();
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
        var insertionIndex = parentSegment.chunks.length;
        var boundarySegment = createPendingSegment(
          request,
          insertionIndex,
          newBoundary,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          false,
          false
        );
        parentSegment.children.push(boundarySegment);
        parentSegment.lastPushedText = false;
        var contentRootSegment = createPendingSegment(
          request,
          0,
          null,
          parentSegment.formatContext,
          // boundaries never require text embedding at their edges because comment nodes bound them
          false,
          false
        );
        contentRootSegment.parentFlushed = true;
        task.blockedBoundary = newBoundary;
        task.blockedSegment = contentRootSegment;
        try {
          renderNode(request, task, content);
          pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
          contentRootSegment.status = COMPLETED;
          queueCompletedSegment(newBoundary, contentRootSegment);
          if (newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error2) {
          contentRootSegment.status = ERRORED;
          newBoundary.forceClientRender = true;
          newBoundary.errorDigest = logRecoverableError(request, error2);
          {
            captureBoundaryErrorDetailsDev(newBoundary, error2);
          }
        } finally {
          task.blockedBoundary = parentBoundary;
          task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        {
          suspendedFallbackTask.componentStack = task.componentStack;
        }
        request.pingedTasks.push(suspendedFallbackTask);
        popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type);
        var segment = task.blockedSegment;
        var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
        segment.lastPushedText = false;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type, props);
        renderNode(request, task, children);
        segment.formatContext = prevContext;
        pushEndInstance(segment.chunks, type);
        segment.lastPushedText = false;
        popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result = Component(props, secondArg);
        return finishHooks(Component, props, result, secondArg);
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        {
          if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) {
              error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        {
          var childContextTypes = Component.childContextTypes;
          if (childContextTypes !== null && childContextTypes !== void 0) {
            var previousContext = task.legacyContext;
            var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext;
            renderNodeDestructive(request, task, nextChildren);
            task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext);
        var instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext);
        finishClassComponent(request, task, instance, Component, props);
        popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {};
      var didWarnAboutModulePatternComponent = {};
      var didWarnAboutContextTypeOnFunctionComponent = {};
      var didWarnAboutGetDerivedStateOnFunctionComponent = {};
      var didWarnAboutReassigningProps = false;
      var didWarnAboutDefaultPropsOnFunctionComponent = {};
      var didWarnAboutGenerators = false;
      var didWarnAboutMaps = false;
      var hasWarnedAboutUsingContextAsConsumer = false;
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        {
          legacyContext = getMaskedContext(Component, task.legacyContext);
        }
        pushFunctionComponentStackInDEV(task, Component);
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
        }
        var value = renderWithHooks(request, task, Component, props, legacyContext);
        var hasId = checkDidRenderIdHook();
        {
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (
          // Run these checks in production only if the flag is off.
          // Eventually we'll delete this branch altogether.
          typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
        ) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          mountClassInstance(value, Component, props, legacyContext);
          finishClassComponent(request, task, value, Component, props);
        } else {
          {
            validateFunctionComponentInDev(Component);
          }
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, value);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, value);
          }
        }
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (Component.defaultProps !== void 0) {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
              error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
              didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === void 0) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render);
        var children = renderWithHooks(request, task, type.render, props, ref);
        var hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext;
          var totalChildren = 1;
          var index = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else {
          renderNodeDestructive(request, task, children);
        }
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type, props, ref) {
        var innerType = type.type;
        var resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
      }
      function renderContextConsumer(request, task, context, props) {
        {
          if (context._context === void 0) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var render = props.children;
        {
          if (typeof render !== "function") {
            error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          }
        }
        var newValue = readContext(context);
        var newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type, props) {
        var context = type._context;
        var value = props.value;
        var children = props.children;
        var prevSnapshot;
        {
          prevSnapshot = task.context;
        }
        task.context = pushProvider(context, value);
        renderNodeDestructive(request, task, children);
        task.context = popProvider(context);
        {
          if (prevSnapshot !== task.context) {
            error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
          }
        }
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload);
        var resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref);
        popComponentStackInDEV(task);
      }
      function renderElement(request, task, type, props, ref) {
        if (typeof type === "function") {
          if (shouldConstruct$1(type)) {
            renderClassComponent(request, task, type, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type, props);
            return;
          }
        }
        if (typeof type === "string") {
          renderHostElement(request, task, type, props);
          return;
        }
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList");
            renderNodeDestructive(request, task, props.children);
            popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE: {
            throw new Error("ReactDOMServer does not yet support scope components.");
          }
          case REACT_SUSPENSE_TYPE: {
            {
              renderSuspenseBoundary(request, task, props);
            }
            return;
          }
        }
        if (typeof type === "object" && type !== null) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type, props, ref);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type, props, ref);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type, props);
              return;
            }
          }
        }
        var info = "";
        {
          if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          }
        }
        throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        {
          if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
          iterable[Symbol.toStringTag] === "Generator") {
            if (!didWarnAboutGenerators) {
              error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
            }
            didWarnAboutGenerators = true;
          }
          if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) {
              error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
            }
            didWarnAboutMaps = true;
          }
        }
      }
      function renderNodeDestructive(request, task, node) {
        {
          try {
            return renderNodeDestructiveImpl(request, task, node);
          } catch (x) {
            if (typeof x === "object" && x !== null && typeof x.then === "function") ;
            else {
              lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
            }
            throw x;
          }
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        task.node = node;
        if (typeof node === "object" && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node;
              var type = element.type;
              var props = element.props;
              var ref = element.ref;
              renderElement(request, task, type, props, ref);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node;
              var payload = lazyNode._payload;
              var init = lazyNode._init;
              var resolvedNode;
              {
                try {
                  resolvedNode = init(payload);
                } catch (x) {
                  if (typeof x === "object" && x !== null && typeof x.then === "function") {
                    pushBuiltInComponentStackInDEV(task, "Lazy");
                  }
                  throw x;
                }
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray(node)) {
            renderChildrenArray(request, task, node);
            return;
          }
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            {
              validateIterable(node, iteratorFn);
            }
            var iterator = iteratorFn.call(node);
            if (iterator) {
              var step = iterator.next();
              if (!step.done) {
                var children = [];
                do {
                  children.push(step.value);
                  step = iterator.next();
                } while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        if (typeof node === "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node === "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
          return;
        }
        {
          if (typeof node === "function") {
            error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
      }
      function renderChildrenArray(request, task, children) {
        var totalChildren = children.length;
        for (var i = 0; i < totalChildren; i++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
          try {
            renderNode(request, task, children[i]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x) {
        var segment = task.blockedSegment;
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(
          request,
          insertionIndex,
          null,
          segment.formatContext,
          // Adopt the parent segment's leading text embed
          segment.lastPushedText,
          // Assume we are text embedded at the trailing edge
          true
        );
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        {
          if (task.componentStack !== null) {
            newTask.componentStack = task.componentStack.parent;
          }
        }
        var ping = newTask.ping;
        x.then(ping, ping);
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext;
        var previousLegacyContext = task.legacyContext;
        var previousContext = task.context;
        var previousComponentStack = null;
        {
          previousComponentStack = task.componentStack;
        }
        try {
          return renderNodeDestructive(request, task, node);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            spawnNewSuspendedTask(request, task, x);
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            return;
          } else {
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            throw x;
          }
        }
      }
      function erroredTask(request, boundary, segment, error2) {
        var errorDigest = logRecoverableError(request, error2);
        if (boundary === null) {
          fatalError(request, error2);
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            boundary.errorDigest = errorDigest;
            {
              captureBoundaryErrorDetailsDev(boundary, error2);
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this;
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        if (boundary === null) {
          request.allPendingTasks--;
          if (request.status !== CLOSED) {
            request.status = CLOSED;
            if (request.destination !== null) {
              close(request.destination);
            }
          }
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              if (_error && typeof _error.message === "string") {
                _error = errorPrefix + _error.message;
              } else {
                _error = errorPrefix + String(_error);
              }
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
          boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          });
          boundary.fallbackAbortableTasks.clear();
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          if (childSegment.status === COMPLETED) {
            queueCompletedSegment(boundary, childSegment);
          }
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null) {
              throw new Error("There can only be one root segment. This is a bug in React.");
            }
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          if (request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else {
          boundary.pendingTasks--;
          if (boundary.forceClientRender) ;
          else if (boundary.pendingTasks === 0) {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
              }
            }
            if (boundary.parentFlushed) {
              request.completedBoundaries.push(boundary);
            }
            boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
            boundary.fallbackAbortableTasks.clear();
          } else {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
                var completedSegments = boundary.completedSegments;
                if (completedSegments.length === 1) {
                  if (boundary.parentFlushed) {
                    request.partialBoundaries.push(boundary);
                  }
                }
              }
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status !== PENDING) {
          return;
        }
        switchContext(task.context);
        var prevTaskInDEV = null;
        {
          prevTaskInDEV = currentTaskInDEV;
          currentTaskInDEV = task;
        }
        try {
          renderNodeDestructive(request, task, task.node);
          pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
          task.abortSet.delete(task);
          segment.status = COMPLETED;
          finishedTask(request, task.blockedBoundary, segment);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            var ping = task.ping;
            x.then(ping, ping);
          } else {
            task.abortSet.delete(task);
            segment.status = ERRORED;
            erroredTask(request, task.blockedBoundary, segment, x);
          }
        } finally {
          {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status === CLOSED) {
          return;
        }
        var prevContext = getActiveContext();
        var prevDispatcher = ReactCurrentDispatcher$1.current;
        ReactCurrentDispatcher$1.current = Dispatcher;
        var prevGetCurrentStackImpl;
        {
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
          ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
        }
        var prevResponseState = currentResponseState;
        setCurrentResponseState(request.responseState);
        try {
          var pingedTasks = request.pingedTasks;
          var i;
          for (i = 0; i < pingedTasks.length; i++) {
            var task = pingedTasks[i];
            retryTask(request, task);
          }
          pingedTasks.splice(0, i);
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        } finally {
          setCurrentResponseState(prevResponseState);
          ReactCurrentDispatcher$1.current = prevDispatcher;
          {
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
          }
          if (prevDispatcher === Dispatcher) {
            switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            segment.lastPushedText = false;
            segment.textEmbedded = false;
            return writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            var r2 = true;
            var chunks = segment.chunks;
            var chunkIdx = 0;
            var children = segment.children;
            for (var childIdx = 0; childIdx < children.length; childIdx++) {
              var nextChild = children[childIdx];
              for (; chunkIdx < nextChild.index; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              r2 = flushSegment(request, destination, nextChild);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++) {
              writeChunk(destination, chunks[chunkIdx]);
            }
            if (chunkIdx < chunks.length) {
              r2 = writeChunkAndReturn(destination, chunks[chunkIdx]);
            }
            return r2;
          }
          default: {
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
          }
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null) {
          return flushSubtree(request, destination, segment);
        }
        boundary.parentFlushed = true;
        if (boundary.forceClientRender) {
          writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          flushSubtree(request, destination, segment);
          return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
        } else if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++;
          if (boundary.completedSegments.length > 0) {
            request.partialBoundaries.push(boundary);
          }
          var id2 = boundary.id = assignSuspenseBoundaryID(request.responseState);
          writeStartPendingSuspenseBoundary(destination, request.responseState, id2);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else if (boundary.byteSize > request.progressiveChunkSize) {
          boundary.rootSegmentID = request.nextSegmentId++;
          request.completedBoundaries.push(boundary);
          writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          writeStartCompletedSuspenseBoundary(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1) {
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          }
          var contentSegment = completedSegments[0];
          flushSegment(request, destination, contentSegment);
          return writeEndCompletedSuspenseBoundary(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
        flushSegment(request, destination, segment);
        return writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (; i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        completedSegments.length = 0;
        return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (; i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
            i++;
            completedSegments.splice(0, i);
            return false;
          }
        }
        completedSegments.splice(0, i);
        return true;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) {
          return true;
        }
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1) {
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          }
          return flushSegmentContainer(request, destination, segment);
        } else {
          flushSegmentContainer(request, destination, segment);
          return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
        }
      }
      function flushCompletedQueues(request, destination) {
        beginWriting();
        try {
          var completedRootSegment = request.completedRootSegment;
          if (completedRootSegment !== null && request.pendingRootTasks === 0) {
            flushSegment(request, destination, completedRootSegment);
            request.completedRootSegment = null;
            writeCompletedRoot(destination, request.responseState);
          }
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          var i;
          for (i = 0; i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0; i < completedBoundaries.length; i++) {
            var _boundary = completedBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          }
          completedBoundaries.splice(0, i);
          completeWriting(destination);
          beginWriting(destination);
          var partialBoundaries = request.partialBoundaries;
          for (i = 0; i < partialBoundaries.length; i++) {
            var _boundary2 = partialBoundaries[i];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0; i < largeBoundaries.length; i++) {
            var _boundary3 = largeBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          }
          largeBoundaries.splice(0, i);
        } finally {
          completeWriting(destination);
          flushBuffered(destination);
          if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
            {
              if (request.abortableTasks.size !== 0) {
                error("There was still abortable task at the root when we closed. This is a bug in React.");
              }
            }
            close(destination);
          }
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED;
          closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status === CLOSED) {
          return;
        }
        if (request.destination !== null) {
          return;
        }
        request.destination = destination;
        try {
          flushCompletedQueues(request, destination);
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          });
          abortableTasks.clear();
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function createDrainHandler(destination, request) {
        return function() {
          return startFlowing(request, destination);
        };
      }
      function createAbortHandler(request, reason) {
        return function() {
          return abort(request, reason);
        };
      }
      function createRequestImpl(children, options) {
        return createRequest(children, createResponseState(options ? options.identifierPrefix : void 0, options ? options.nonce : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, options ? options.onAllReady : void 0, options ? options.onShellReady : void 0, options ? options.onShellError : void 0);
      }
      function renderToPipeableStream(children, options) {
        var request = createRequestImpl(children, options);
        var hasStartedFlowing = false;
        startWork(request);
        return {
          pipe: function(destination) {
            if (hasStartedFlowing) {
              throw new Error("React currently only supports piping to one writable stream.");
            }
            hasStartedFlowing = true;
            startFlowing(request, destination);
            destination.on("drain", createDrainHandler(destination, request));
            destination.on("error", createAbortHandler(
              request,
              // eslint-disable-next-line react-internal/prod-error-codes
              new Error("The destination stream errored while writing data.")
            ));
            destination.on("close", createAbortHandler(
              request,
              // eslint-disable-next-line react-internal/prod-error-codes
              new Error("The destination stream closed early.")
            ));
            return destination;
          },
          abort: function(reason) {
            abort(request, reason);
          }
        };
      }
      reactDomServer_node_development.renderToPipeableStream = renderToPipeableStream;
      reactDomServer_node_development.version = ReactVersion;
    })();
  }
  return reactDomServer_node_development;
}
var l, s;
if (process.env.NODE_ENV === "production") {
  l = requireReactDomServerLegacy_node_production_min();
  s = requireReactDomServer_node_production_min();
} else {
  l = requireReactDomServerLegacy_node_development();
  s = requireReactDomServer_node_development();
}
server_node.version = l.version;
server_node.renderToString = l.renderToString;
server_node.renderToStaticMarkup = l.renderToStaticMarkup;
server_node.renderToNodeStream = l.renderToNodeStream;
server_node.renderToStaticNodeStream = l.renderToStaticNodeStream;
server_node.renderToPipeableStream = s.renderToPipeableStream;
var server = server_node;
const ReactDOMServer = /* @__PURE__ */ getDefaultExportFromCjs(server);
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
var shim = { exports: {} };
var useSyncExternalStoreShim_production = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = requireReact();
  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is, useState = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    useLayoutEffect(
      function() {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe, value, getSnapshot]
    );
    useEffect(
      function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe]
    );
    useDebugValue(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
  useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React2.useSyncExternalStore ? React2.useSyncExternalStore : shim2;
  return useSyncExternalStoreShim_production;
}
var useSyncExternalStoreShim_development = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
  hasRequiredUseSyncExternalStoreShim_development = 1;
  "production" !== process.env.NODE_ENV && function() {
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function useSyncExternalStore$2(subscribe, getSnapshot) {
      didWarnOld18Alpha || void 0 === React2.startTransition || (didWarnOld18Alpha = true, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var value = getSnapshot();
      if (!didWarnUncachedGetSnapshot) {
        var cachedValue = getSnapshot();
        objectIs(value, cachedValue) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), didWarnUncachedGetSnapshot = true);
      }
      cachedValue = useState({
        inst: { value, getSnapshot }
      });
      var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
      useLayoutEffect(
        function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        },
        [subscribe, value, getSnapshot]
      );
      useEffect(
        function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          });
        },
        [subscribe]
      );
      useDebugValue(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
      return getSnapshot();
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React2 = requireReact(), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue = React2.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
    useSyncExternalStoreShim_development.useSyncExternalStore = void 0 !== React2.useSyncExternalStore ? React2.useSyncExternalStore : shim2;
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }();
  return useSyncExternalStoreShim_development;
}
if (process.env.NODE_ENV === "production") {
  shim.exports = requireUseSyncExternalStoreShim_production();
} else {
  shim.exports = requireUseSyncExternalStoreShim_development();
}
var shimExports = shim.exports;
const useBuiltinInsertionEffect = React$1["useInsertionEffect"];
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const useIsomorphicLayoutEffect$1 = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
const useInsertionEffect = useBuiltinInsertionEffect || useIsomorphicLayoutEffect$1;
const useEvent = (fn) => {
  const ref = reactExports.useRef([fn, (...args) => ref[0](...args)]).current;
  useInsertionEffect(() => {
    ref[0] = fn;
  });
  return ref[1];
};
const eventPopstate = "popstate";
const eventPushState = "pushState";
const eventReplaceState = "replaceState";
const eventHashchange = "hashchange";
const events = [
  eventPopstate,
  eventPushState,
  eventReplaceState,
  eventHashchange
];
const subscribeToLocationUpdates = (callback) => {
  for (const event of events) {
    addEventListener(event, callback);
  }
  return () => {
    for (const event of events) {
      removeEventListener(event, callback);
    }
  };
};
const useLocationProperty = (fn, ssrFn) => shimExports.useSyncExternalStore(subscribeToLocationUpdates, fn, ssrFn);
const currentSearch = () => location.search;
const useSearch = ({ ssrSearch = "" } = {}) => useLocationProperty(currentSearch, () => ssrSearch);
const currentPathname = () => location.pathname;
const usePathname = ({ ssrPath } = {}) => useLocationProperty(
  currentPathname,
  ssrPath ? () => ssrPath : currentPathname
);
const navigate = (to, { replace = false, state = null } = {}) => history[replace ? eventReplaceState : eventPushState](state, "", to);
const useBrowserLocation = (opts = {}) => [usePathname(opts), navigate];
const patchKey = Symbol.for("wouter_v3");
if (typeof history !== "undefined" && typeof window[patchKey] === "undefined") {
  for (const type of [eventPushState, eventReplaceState]) {
    const original = history[type];
    history[type] = function() {
      const result = original.apply(this, arguments);
      const event = new Event(type);
      event.arguments = arguments;
      dispatchEvent(event);
      return result;
    };
  }
  Object.defineProperty(window, patchKey, { value: true });
}
const _relativePath = (base, path) => !path.toLowerCase().indexOf(base.toLowerCase()) ? path.slice(base.length) || "/" : "~" + path;
const baseDefaults = (base = "") => base === "/" ? "" : base;
const absolutePath = (to, base) => to[0] === "~" ? to.slice(1) : baseDefaults(base) + to;
const relativePath = (base = "", path) => _relativePath(unescape(baseDefaults(base)), unescape(path));
const unescape = (str) => {
  try {
    return decodeURI(str);
  } catch (_e) {
    return str;
  }
};
const defaultRouter = {
  hook: useBrowserLocation,
  searchHook: useSearch,
  parser: parse,
  base: "",
  // this option is used to override the current location during SSR
  ssrPath: void 0,
  ssrSearch: void 0,
  // optional context to track render state during SSR
  ssrContext: void 0,
  // customizes how `href` props are transformed for <Link />
  hrefs: (x) => x
};
const RouterCtx = reactExports.createContext(defaultRouter);
const useRouter = () => reactExports.useContext(RouterCtx);
const Params0 = {}, ParamsCtx = reactExports.createContext(Params0);
const useParams = () => reactExports.useContext(ParamsCtx);
const useLocationFromRouter = (router) => {
  const [location2, navigate2] = router.hook(router);
  return [
    relativePath(router.base, location2),
    useEvent((to, navOpts) => navigate2(absolutePath(to, router.base), navOpts))
  ];
};
const useLocation = () => useLocationFromRouter(useRouter());
const matchRoute = (parser, route, path, loose) => {
  const { pattern, keys } = route instanceof RegExp ? { keys: false, pattern: route } : parser(route || "*", loose);
  const result = pattern.exec(path) || [];
  const [$base, ...matches] = result;
  return $base !== void 0 ? [
    true,
    (() => {
      const groups = keys !== false ? Object.fromEntries(keys.map((key, i) => [key, matches[i]])) : result.groups;
      let obj = { ...matches };
      groups && Object.assign(obj, groups);
      return obj;
    })(),
    // the third value if only present when parser is in "loose" mode,
    // so that we can extract the base path for nested routes
    ...loose ? [$base] : []
  ] : [false, null];
};
const Router = ({ children, ...props }) => {
  var _a, _b;
  const parent_ = useRouter();
  const parent = props.hook ? defaultRouter : parent_;
  let value = parent;
  const [path, search] = ((_a = props.ssrPath) == null ? void 0 : _a.split("?")) ?? [];
  if (search) props.ssrSearch = search, props.ssrPath = path;
  props.hrefs = props.hrefs ?? ((_b = props.hook) == null ? void 0 : _b.hrefs);
  let ref = reactExports.useRef({}), prev = ref.current, next = prev;
  for (let k in parent) {
    const option = k === "base" ? (
      /* base is special case, it is appended to the parent's base */
      parent[k] + (props[k] || "")
    ) : props[k] || parent[k];
    if (prev === next && option !== next[k]) {
      ref.current = next = { ...next };
    }
    next[k] = option;
    if (option !== parent[k] || option !== value[k]) value = next;
  }
  return reactExports.createElement(RouterCtx.Provider, { value, children });
};
const h_route = ({ children, component }, params) => {
  if (component) return reactExports.createElement(component, { params });
  return typeof children === "function" ? children(params) : children;
};
const useCachedParams = (value) => {
  let prev = reactExports.useRef(Params0);
  const curr = prev.current;
  return prev.current = // Update cache if number of params changed or any value changed
  Object.keys(value).length !== Object.keys(curr).length || Object.entries(value).some(([k, v]) => v !== curr[k]) ? value : curr;
};
const Route = ({ path, nest, match, ...renderProps }) => {
  const router = useRouter();
  const [location2] = useLocationFromRouter(router);
  const [matches, routeParams, base] = (
    // `match` is a special prop to give up control to the parent,
    // it is used by the `Switch` to avoid double matching
    match ?? matchRoute(router.parser, path, location2, nest)
  );
  const params = useCachedParams({ ...useParams(), ...routeParams });
  if (!matches) return null;
  const children = base ? reactExports.createElement(Router, { base }, h_route(renderProps, params)) : h_route(renderProps, params);
  return reactExports.createElement(ParamsCtx.Provider, { value: params, children });
};
reactExports.forwardRef((props, ref) => {
  const router = useRouter();
  const [currentPath, navigate2] = useLocationFromRouter(router);
  const {
    to = "",
    href: targetPath = to,
    onClick: _onClick,
    asChild,
    children,
    className: cls,
    /* eslint-disable no-unused-vars */
    replace,
    state,
    /* eslint-enable no-unused-vars */
    ...restProps
  } = props;
  const onClick = useEvent((event) => {
    if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button !== 0)
      return;
    _onClick == null ? void 0 : _onClick(event);
    if (!event.defaultPrevented) {
      event.preventDefault();
      navigate2(targetPath, props);
    }
  });
  const href = router.hrefs(
    targetPath[0] === "~" ? targetPath.slice(1) : router.base + targetPath,
    router
    // pass router as a second argument for convinience
  );
  return asChild && reactExports.isValidElement(children) ? reactExports.cloneElement(children, { onClick, href }) : reactExports.createElement("a", {
    ...restProps,
    onClick,
    href,
    // `className` can be a function to apply the class if this link is active
    className: (cls == null ? void 0 : cls.call) ? cls(currentPath === targetPath) : cls,
    children,
    ref
  });
});
const flattenChildren = (children) => Array.isArray(children) ? children.flatMap(
  (c) => flattenChildren(c && c.type === reactExports.Fragment ? c.props.children : c)
) : [children];
const Switch = ({ children, location: location2 }) => {
  const router = useRouter();
  const [originalLocation] = useLocationFromRouter(router);
  for (const element of flattenChildren(children)) {
    let match = 0;
    if (reactExports.isValidElement(element) && // we don't require an element to be of type Route,
    // but we do require it to contain a truthy `path` prop.
    // this allows to use different components that wrap Route
    // inside of a switch, for example <AnimatedRoute />.
    (match = matchRoute(
      router.parser,
      element.props.path,
      location2 || originalLocation,
      element.props.nest
    ))[0])
      return reactExports.cloneElement(element, { match });
  }
  return null;
};
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
const CLASS_PART_SEPARATOR = "-";
const createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
const getGroupRecursive = (classParts, classPartObject) => {
  var _a;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a = classPartObject.validators.find(({
    validator
  }) => validator(classRest))) == null ? void 0 : _a.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
const createClassMap = (config) => {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
const getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
const isThemeGetter = (func) => func.isThemeGetter;
const getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
const createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
const IMPORTANT_MODIFIER = "!";
const createParseClassName = (config) => {
  const {
    separator,
    experimentalParseClassName
  } = config;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index = 0; index < className.length; index++) {
      let currentCharacter = className[index];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index));
          modifierStart = index + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className) => experimentalParseClassName({
      className,
      parseClassName
    });
  }
  return parseClassName;
};
const sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
const createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  ...createClassGroupUtils(config)
});
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1; index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0; i < conflictGroups.length; ++i) {
      const group = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index < arguments.length) {
    if (argument = arguments[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
const toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
const fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
const fractionRegex = /^\d+\/\d+$/;
const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
const isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
const isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
const isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
const isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
const isTshirtSize = (value) => tshirtUnitRegex.test(value);
const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
const isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
const isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
const isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
const isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
const isAny = () => true;
const getIsArbitraryValue = (value, label, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
const isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
const isNever = () => false;
const isShadow = (value) => shadowRegex.test(value);
const isImage = (value) => imageRegex.test(value);
const getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
function cn$1(...inputs) {
  return twMerge(clsx(inputs));
}
function reorderArray(list, fromIndex, toIndex) {
  const length = Array.isArray(list) ? list.length : 0;
  if (length === 0) return [];
  const boundedFrom = Math.max(0, Math.min(length - 1, fromIndex));
  const boundedTo = Math.max(0, Math.min(length - 1, toIndex));
  if (boundedFrom === boundedTo) return list.slice();
  const result = list.slice();
  const [moved] = result.splice(boundedFrom, 1);
  result.splice(boundedTo, 0, moved);
  return result;
}
const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium leading-none ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
const Button$1 = reactExports.forwardRef(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Comp,
      {
        className: cn$1(buttonVariants({ variant, size, className })),
        ref,
        ...props
      }
    );
  }
);
Button$1.displayName = "Button";
const LayoutGroupContext = reactExports.createContext({});
function useConstant(init) {
  const ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
const isBrowser = typeof window !== "undefined";
const useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
const PresenceContext = /* @__PURE__ */ reactExports.createContext(null);
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p) => p,
  isStatic: false,
  reducedMotion: "never"
});
function usePresence(subscribe = true) {
  const context = reactExports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => {
    if (subscribe) {
      return register(id2);
    }
  }, [subscribe]);
  const safeToRemove = reactExports.useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
const LazyContext = reactExports.createContext({ strict: false });
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name) => !!props[name])
  };
}
function loadFeatures(features2) {
  for (const key in features2) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features2[key]
    };
  }
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (typeof isValidProp !== "function")
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
const MotionContext = /* @__PURE__ */ reactExports.createContext({});
function isAnimationControls(v) {
  return v !== null && typeof v === "object" && typeof v.start === "function";
}
function isVariantLabel(v) {
  return typeof v === "string" || Array.isArray(v);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  for (const key in correctors) {
    scaleCorrectors[key] = correctors[key];
    if (isCSSVariableName(key)) {
      scaleCorrectors[key].isCSSVariable = true;
    }
  }
}
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i = 0; i < numTransforms; i++) {
    const key = transformPropOrder[i];
    const value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate, styleProp) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style } = state;
  if (attrs.transform) {
    style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (style.transform || attrs.transformOrigin) {
    style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
    delete attrs.transformOrigin;
  }
  if (style.transform) {
    style.transformBox = (styleProp == null ? void 0 : styleProp.transformBox) ?? "fill-box";
    delete attrs.transformBox;
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component)
  ) {
    return true;
  }
  return false;
}
function useRender(Component, props, ref, { latestValues }, isStatic, forwardMotionProps = false) {
  const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
  const visualProps = useVisualProps(props, latestValues, isStatic, Component);
  const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
  const elementProps = Component !== reactExports.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
  const { children } = props;
  const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
  return reactExports.createElement(Component, {
    ...elementProps,
    children: renderedChildren
  });
}
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement == null ? void 0 : visualElement.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}
function resolveMotionValue(value) {
  return isMotionValue(value) ? value.get() : value;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  return state;
}
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i = 0; i < list.length; i++) {
      const resolved = resolveVariantFromProps(props, list[i]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd) {
          values[key] = transitionEnd[key];
        }
      }
    }
  }
  return values;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  var _a;
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement == null ? void 0 : visualElement.getValue(key)) == null ? void 0 : _a.liveStyle) !== void 0) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
const useHTMLVisualState = /* @__PURE__ */ makeUseVisualState({
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
  createRenderState: createHtmlRenderState
});
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
const useSVGVisualState = /* @__PURE__ */ makeUseVisualState({
  scrapeMotionValuesFromProps,
  createRenderState: createSvgRenderState
});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      if (instance) {
        visualState.onMount && visualState.onMount(instance);
      }
      if (visualElement) {
        if (instance) {
          visualElement.mount(instance);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
const SwitchLayoutGroupContext = reactExports.createContext({});
function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  var _a, _b;
  const { visualElement: parent } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef(null);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = reactExports.useRef(false);
  reactExports.useInsertionEffect(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) == null ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) == null ? void 0 : _b.call(window, optimisedAppearId)));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement)
      return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    visualElement.scheduleRenderMicrotask();
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  reactExports.useEffect(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        var _a2;
        (_a2 = window.MotionHandoffMarkAsComplete) == null ? void 0 : _a2.call(window, optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
    visualElement.enteringChildren = void 0;
  });
  return visualElement;
}
function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    crossfade: layoutCrossfade,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function createMotionComponent(Component, { forwardMotionProps = false } = {}, preloadedFeatures, createVisualElement) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  const useVisualState = isSVGComponent(Component) ? useSVGVisualState : useHTMLVisualState;
  function MotionDOMComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      useStrictMode(configAndProps, preloadedFeatures);
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] });
  }
  MotionDOMComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${Component.displayName ?? Component.name ?? ""})`}`;
  const ForwardRefMotionComponent = reactExports.forwardRef(MotionDOMComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component;
  return ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  const isStrict = reactExports.useContext(LazyContext).strict;
  if (process.env.NODE_ENV !== "production" && preloadedFeatures && isStrict) {
    const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    configAndProps.ignoreStrict ? warning(false, strictMessage, "lazy-strict-mode") : invariant(false, strictMessage, "lazy-strict-mode");
  }
}
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: (drag2 == null ? void 0 : drag2.isEnabled(props)) || (layout2 == null ? void 0 : layout2.isEnabled(props)) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
function createMotionProxy(preloadedFeatures, createVisualElement) {
  if (typeof Proxy === "undefined") {
    return createMotionComponent;
  }
  const componentCache = /* @__PURE__ */ new Map();
  const factory = (Component, options) => {
    return createMotionComponent(Component, options, preloadedFeatures, createVisualElement);
  };
  const deprecatedFactoryFunction = (Component, options) => {
    if (process.env.NODE_ENV !== "production") {
      warnOnce(false, "motion() is deprecated. Use motion.create() instead.");
    }
    return factory(Component, options);
  };
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (key === "create")
        return factory;
      if (!componentCache.has(key)) {
        componentCache.set(key, createMotionComponent(key, void 0, preloadedFeatures, createVisualElement));
      }
      return componentCache.get(key);
    }
  });
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x, y }) {
  return { top: y.min, right: x.max, bottom: y.max, left: x.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale) {
  return scale === void 0 || scale === 1;
}
function hasScale({ scale, scaleX, scaleY }) {
  return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
}
function applyBoxDelta(box, { x, y }) {
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999;
const TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    const { visualElement } = node.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform) {
  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now = time.now();
      if (this.renderScheduledAt < now) {
        this.renderScheduledAt = now;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key]);
      }
    }
  }
  mount(instance) {
    var _a;
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (process.env.NODE_ENV !== "production") {
      warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.", "reduced-motion-disabled");
    }
    (_a = this.parent) == null ? void 0 : _a.addChild(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    var _a;
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    (_a = this.parent) == null ? void 0 : _a.removeChild(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  addChild(child) {
    this.children.add(child);
    this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set());
    this.enteringChildren.add(child);
  }
  removeChild(child) {
    this.children.delete(child);
    this.enteringChildren && this.enteringChildren.delete(child);
  }
  bindToMotionValue(key, value) {
    if (this.valueSubscriptions.has(key)) {
      this.valueSubscriptions.get(key)();
    }
    const valueIsTransform = transformProps.has(key);
    if (valueIsTransform && this.onBindTransform) {
      this.onBindTransform();
    }
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
      this.scheduleRender();
    });
    let removeSyncCheck;
    if (window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
    }
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      if (removeSyncCheck)
        removeSyncCheck();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) == null ? void 0 : _a.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
  scheduleRenderMicrotask() {
    microtask.render(this.render);
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
}
function renderHTML(element, { style, vars }, styleProp, projection) {
  const elementStyle = element.style;
  let key;
  for (key in style) {
    elementStyle[key] = style[key];
  }
  projection == null ? void 0 : projection.applyProjectionStyles(elementStyle, styleProp);
  for (key in vars) {
    elementStyle.setProperty(key, vars[key]);
  }
}
function getComputedStyle(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    var _a;
    if (transformProps.has(key)) {
      return ((_a = this.projection) == null ? void 0 : _a.isProjecting) ? defaultTransformValue(key) : readTransformValue(instance, key);
    } else {
      const computedStyle = getComputedStyle(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component, options) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
    allowProjection: Component !== reactExports.Fragment
  });
};
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
}
const isKeyframesTarget = (v) => {
  return Array.isArray(v);
};
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function resolveFinalValueInKeyframes(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  } else if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange);
    newWillChange.add(key);
  }
}
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes.filter(isNotNull);
  const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return resolvedKeyframes[index];
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes }) => {
  if (keyframes.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes[1]) : underDampedSpring;
  }
  return ease;
};
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay2);
  const options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v) => {
      value.set(v);
      valueTransition.onUpdate && valueTransition.onUpdate(v);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    Object.assign(options, getDefaultTransition(name, options));
  }
  options.duration && (options.duration = secondsToMilliseconds(options.duration));
  options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    makeAnimationInstant(options);
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
    shouldSkip = true;
    makeAnimationInstant(options);
    options.delay = 0;
  }
  options.allowFlatten = !valueTransition.type && !valueTransition.ease;
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return;
    }
  }
  return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
};
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
    const valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      ...getValueTransition(transition || {}, key)
    };
    const currentValue = value.get();
    if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
      continue;
    }
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key);
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      animations2.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}
function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
  const index = Array.from(children).sort((a, b) => a.sortNodePosition(b)).indexOf(child);
  const numChildren = children.size;
  const maxStaggerDuration = (numChildren - 1) * staggerChildren;
  const delayIsFunction = typeof delayChildren === "function";
  return delayIsFunction ? delayChildren(index, numChildren) : staggerDirection === 1 ? index * staggerChildren : maxStaggerDuration - index * staggerChildren;
}
function animateVariant(visualElement, variant, options = {}) {
  var _a;
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a = visualElement.presenceContext) == null ? void 0 : _a.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delay2 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  for (const child of visualElement.variantChildren) {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delay2 + (typeof delayChildren === "function" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)
    }).then(() => child.notify("AnimationComplete", variant)));
  }
  return Promise.all(animations2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return void 0;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== void 0) {
      context2.initial = visualElement.props.initial;
    }
    return context2;
  }
  const context = {};
  for (let i = 0; i < numVariantProps; i++) {
    const name = variantProps[i];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context[name] = prop;
    }
  }
  return context;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    var _a;
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a = visualElement.presenceContext) == null ? void 0 : _a.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement;
    const context = getVariantContext(visualElement.parent) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = false;
      };
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
          valueHasChanged = !shallowCompare(next, prev);
        } else {
          valueHasChanged = next !== prev;
        }
        if (valueHasChanged) {
          if (next !== void 0 && next !== null) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations2.push(...definitionList.map((animation) => {
          const options = { type };
          if (typeof animation === "string" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {
            const { parent } = visualElement;
            const parentVariant = resolveVariant(parent, animation);
            if (parent.enteringChildren && parentVariant) {
              const { delayChildren } = parentVariant.transition || {};
              options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);
            }
          }
          return {
            animation,
            options
          };
        }));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      if (typeof props.initial !== "boolean") {
        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
        if (initialTransition && initialTransition.transition) {
          fallbackAnimation.transition = initialTransition.transition;
        }
      }
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key] = fallbackTarget ?? null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement.variantChildren) == null ? void 0 : _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) == null ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
      isInitialRender = true;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node) {
    this.isMounted = false;
    this.node = node;
  }
  update() {
  }
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node);
    node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    if (isAnimationControls(animate)) {
      this.unmountControls = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    var _a;
    this.node.animationState.reset();
    (_a = this.unmountControls) == null ? void 0 : _a.call(this);
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => {
        onExitComplete(this.id);
      });
    }
  }
  mount() {
    const { register, onExitComplete } = this.node.presenceContext || {};
    if (onExitComplete) {
      onExitComplete(this.id);
    }
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const SCALE_PRECISION = 1e-4;
const SCALE_MIN = 1 - SCALE_PRECISION;
const SCALE_MAX = 1 + SCALE_PRECISION;
const TRANSLATE_PRECISION = 0.01;
const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
const getContextWindow = ({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
};
const distance = (a, b) => Math.abs(a - b);
function distance2D(a, b) {
  const xDelta = distance(a.x, b.x);
  const yDelta = distance(a.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3 } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin)
        resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.distanceThreshold = distanceThreshold;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo({ point }, history2) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history2)),
    offset: subtractPoint(point, startDevicePoint(history2)),
    velocity: getVelocity(history2, 0.1)
  };
}
function startDevicePoint(history2) {
  return history2[0];
}
function lastDevicePoint(history2) {
  return history2[history2.length - 1];
}
function getVelocity(history2, timeDelta) {
  if (history2.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history2.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history2);
  while (i >= 0) {
    timestampedPoint = history2[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function applyConstraints(point, { min, max }, elastic) {
  if (min !== void 0 && point < min) {
    point = elastic ? mixNumber(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mixNumber(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min = constraintsAxis.min - layoutAxis.min;
  let max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min, max] = [max, min];
  }
  return { min, max };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp$1(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.latestPointerEvent = null;
    this.latestPanInfo = null;
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event).point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openDragLock)
          this.openDragLock();
        this.openDragLock = setDragLock(drag2);
        if (!this.openDragLock)
          return;
      }
      this.latestPointerEvent = event;
      this.latestPanInfo = info;
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis);
              current = length * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      this.latestPointerEvent = event;
      this.latestPanInfo = info;
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset);
      this.updateAxis("y", info.point, offset);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => {
      this.latestPointerEvent = event;
      this.latestPanInfo = info;
      this.stop(event, info);
      this.latestPointerEvent = null;
      this.latestPanInfo = null;
    };
    const resumeAnimation = () => eachAxis((axis) => {
      var _a;
      return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.play());
    });
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      distanceThreshold,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  /**
   * @internal
   */
  stop(event, panInfo) {
    const finalEvent = event || this.latestPointerEvent;
    const finalPanInfo = panInfo || this.latestPanInfo;
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging || !finalPanInfo || !finalEvent)
      return;
    const { velocity } = finalPanInfo;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
    }
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openDragLock) {
      this.openDragLock();
      this.openDragLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset) {
    const { drag: drag2 } = this.getProps();
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    var _a;
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) == null ? void 0 : _a.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref");
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a;
      return (_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.pause();
    });
  }
  getAnimationState(axis) {
    var _a;
    return (_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min, max } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mixNumber(min, max, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min, max } = this.constraints[axis];
      axisValue.set(mixNumber(min, max, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(node) {
    super(node);
    this.removeGroupControls = noop;
    this.removeListeners = noop;
    this.controls = new VisualElementDragControls(node);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.postRender(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x = pixelsToPercent(latest, node.target.x);
    const y = pixelsToPercent(latest, node.target.y);
    return `${x}% ${y}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    const averageScale = mixNumber(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    return template(shadow);
  }
};
let hasTakenAnySnapshot = false;
class MeasureLayoutWithContext extends reactExports.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      if (hasTakenAnySnapshot) {
        projection.root.didUpdate();
      }
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const { projection } = visualElement;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    hasTakenAnySnapshot = true;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    hasTakenAnySnapshot = true;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function animateSingleValue(value, keyframes, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes, options));
  return motionValue$1.animation;
}
const compareByDepth = (a, b) => a.depth - b.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start = time.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.setup(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
    target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
const easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop);
function compress(min, max, easing) {
  return (p) => {
    if (p < min)
      return 0;
    if (p > max)
      return 1;
    return easing(progress(min, max, p));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}
function removePointDelta(point, translate, scale, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a, b) {
  return a.min === b.min && a.max === b.max;
}
function boxEquals(a, b) {
  return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
}
function axisEqualsRounded(a, b) {
  return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
}
function boxEqualsRounded(a, b) {
  return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a, b) {
  return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform == null ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform = `perspective(${transformPerspective}px) ${transform}`;
    if (rotate)
      transform += `rotate(${rotate}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform += `skewX(${skewX}deg) `;
    if (skewY)
      transform += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
const metrics = {
  nodes: 0,
  calculatedTargetDeltas: 0,
  calculatedProjections: 0
};
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent == null ? void 0 : defaultParent()) {
      this.id = id++;
      this.animationId = 0;
      this.animationCommitId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        if (statsBuffer.value) {
          metrics.nodes = metrics.calculatedTargetDeltas = metrics.calculatedProjections = 0;
        }
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        if (statsBuffer.addProjectionMetrics) {
          statsBuffer.addProjectionMetrics(metrics);
        }
      };
      this.resolvedRelativeTargetAt = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        let innerWidth = 0;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        frame.read(() => {
          innerWidth = window.innerWidth;
        });
        attachResizeListener(instance, () => {
          const newInnerWidth = window.innerWidth;
          if (newInnerWidth === innerWidth)
            return;
          innerWidth = newInnerWidth;
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
          if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      this.eventHandlers.clear();
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(clearIsLayoutDirty);
        return;
      }
      this.animationCommitId = this.animationId;
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      } else {
        this.isUpdating = false;
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
      }
      this.clearAllSnapshots();
      const now = time.now();
      frameData.delta = clamp$1(0, 1e3 / 60, now - frameData.timestamp);
      frameData.timestamp = now;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
      if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
        this.snapshot = void 0;
      }
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement && this.instance) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a;
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = ((_a = this.scroll) == null ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      var _a;
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if ((_a = this.scroll) == null ? void 0 : _a.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const { scroll, options } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) == null ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (statsBuffer.value) {
        metrics.calculatedTargetDeltas++;
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a = this.parent) == null ? void 0 : _a.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      if (statsBuffer.value) {
        metrics.calculatedProjections++;
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a;
      (_a = this.options.visualElement) == null ? void 0 : _a.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      var _a, _b, _c;
      this.notifyListeners("animationStart");
      (_a = this.currentAnimation) == null ? void 0 : _a.stop();
      (_c = (_b = this.resumingFrom) == null ? void 0 : _b.currentAnimation) == null ? void 0 : _c.stop();
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        activeAnimations.layout++;
        this.motionValue || (this.motionValue = motionValue(0));
        this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
          ...options,
          velocity: 0,
          isSync: true,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onStop: () => {
            activeAnimations.layout--;
          },
          onComplete: () => {
            activeAnimations.layout--;
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) == null ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) == null ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i = 0; i < transformAxes.length; i++) {
        resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    applyProjectionStyles(targetStyle, styleProp) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        targetStyle.visibility = "hidden";
        return;
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        targetStyle.visibility = "";
        targetStyle.opacity = "";
        targetStyle.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
        targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        if (this.options.layoutId) {
          targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          targetStyle.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return;
      }
      targetStyle.visibility = "";
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      let transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        transform = transformTemplate(valuesToRender, transform);
      }
      targetStyle.transform = transform;
      const { x, y } = this.projectionDelta;
      targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
      if (lead.animationValues) {
        targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
        const corrected = transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            targetStyle[applyTo[i]] = corrected;
          }
        } else {
          if (isCSSVariable) {
            this.options.visualElement.renderState.vars[key] = corrected;
          } else {
            targetStyle[key] = corrected;
          }
        }
      }
      if (this.options.layoutId) {
        targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a;
        return (_a = node.currentAnimation) == null ? void 0 : _a.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a;
  const snapshot = ((_a = node.resumeFrom) == null ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeLayoutChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  if (statsBuffer.value) {
    metrics.nodes++;
  }
  if (!node.parent)
    return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetSkewAndRotation(node) {
  node.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = mixNumber(delta.translate, 0, p);
  output.scale = mixNumber(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p) {
  output.min = mixNumber(from.min, to.min, p);
  output.max = mixNumber(from.max, to.max, p);
}
function mixBox(output, from, to, p) {
  mixAxis(output.x, from.x, to.x, p);
  mixAxis(output.y, from.y, to.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node) {
  var _a;
  return node !== node.root && ((_a = node.scroll) == null ? void 0 : _a.wasRoot);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function handleHoverEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.animationState && props.whileHover) {
    node.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class HoverGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = hover(current, (_element, startEvent) => {
      handleHoverEvent(this.node, startEvent, "Start");
      return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
    });
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function handlePressEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.current instanceof HTMLButtonElement && node.current.disabled) {
    return;
  }
  if (node.animationState && props.whileTap) {
    node.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class PressGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = press(current, (_element, startEvent) => {
      handlePressEvent(this.node, startEvent, "Start");
      return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
    }, { useGlobalTarget: this.node.props.globalTapTarget });
  }
  unmount() {
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once } = viewport;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
};
const motion = /* @__PURE__ */ createMotionProxy(featureBundle, createDomVisualElement);
function stopAnimation(visualElement) {
  visualElement.values.forEach((value) => value.stop());
}
function setVariants(visualElement, variantLabels) {
  const reversedLabels = [...variantLabels].reverse();
  reversedLabels.forEach((key) => {
    const variant = visualElement.getVariant(key);
    variant && setTarget(visualElement, variant);
    if (visualElement.variantChildren) {
      visualElement.variantChildren.forEach((child) => {
        setVariants(child, variantLabels);
      });
    }
  });
}
function setValues(visualElement, definition) {
  if (Array.isArray(definition)) {
    return setVariants(visualElement, definition);
  } else if (typeof definition === "string") {
    return setVariants(visualElement, [definition]);
  } else {
    setTarget(visualElement, definition);
  }
}
function animationControls() {
  let hasMounted = false;
  const subscribers = /* @__PURE__ */ new Set();
  const controls = {
    subscribe(visualElement) {
      subscribers.add(visualElement);
      return () => void subscribers.delete(visualElement);
    },
    start(definition, transitionOverride) {
      invariant(hasMounted, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      const animations2 = [];
      subscribers.forEach((visualElement) => {
        animations2.push(animateVisualElement(visualElement, definition, {
          transitionOverride
        }));
      });
      return Promise.all(animations2);
    },
    set(definition) {
      invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      return subscribers.forEach((visualElement) => {
        setValues(visualElement, definition);
      });
    },
    stop() {
      subscribers.forEach((visualElement) => {
        stopAnimation(visualElement);
      });
    },
    mount() {
      hasMounted = true;
      return () => {
        hasMounted = false;
        controls.stop();
      };
    }
  };
  return controls;
}
function useAnimationControls() {
  const controls = useConstant(animationControls);
  useIsomorphicLayoutEffect(controls.mount, []);
  return controls;
}
const useAnimation = useAnimationControls;
const settings = {
  visibility: {
    cta: true,
    docs: false,
    hero: true,
    footer: true,
    header: true,
    contact: true,
    pricing: false,
    product: true,
    features: true,
    uxbiblio: true,
    waitlist: true,
    "bibliokit-blocks": true,
    "ai-rename-variants": true
  },
  labels: {
    ctaBadges: true,
    heroBadges: true,
    pricingBadges: true,
    productBadges: true,
    featuresBadges: true
  }
};
const hero = {
  visible: true,
  title: "Work x1000 Faster",
  subtitle: "Your AI Design ToolKit, Reinvented.",
  badgeLabel: "Built by designers for designers.",
  description: "Automate the stuff you hate. Organize the stuff you love. One toolkit, every design shortcut.",
  primaryButton: "Get Started Free",
  secondaryButton: "View Products",
  primaryButtonLink: "https://blocks.bibliokit.com/signup",
  secondaryButtonLink: "#features",
  gradientColors: [
    "#ecfeff00",
    "#ecfeff10",
    "#c7d2fe40",
    "#a7f3d040",
    "#a5b4fc50",
    "#93c5fd40",
    "#ffffff00"
  ]
};
const header = {
  logoText: "BiblioKit",
  navigation: [
    {
      href: "/bibliokit-blocks",
      label: "BiblioKit Blocks"
    },
    {
      href: "/ai-rename-variants",
      label: "AI Rename Variants"
    },
    {
      href: "/uxbiblio",
      label: "UXBiblio"
    }
  ],
  showSignIn: false,
  signInText: "Sign In",
  getStartedText: "Get Started",
  signInLink: "https://blocks.bibliokit.com/login",
  getStartedLink: "https://blocks.bibliokit.com/signup"
};
const features = [
  {
    icon: "",
    idea: "AI-powered variant renaming at scale.",
    badge: "Launched",
    title: "AI Rename Variants",
    badges: [],
    topItems: [
      "Batch rename sets",
      "Detect states & sizes",
      "Undo changes safely",
      "Spot missing variants",
      "Cross-platform names"
    ],
    showBadge: true,
    badgeColor: "#10b981",
    buttonLink: "/ai-rename-variants",
    buttonText: "Learn More",
    isFeatured: false,
    description: "Batch-rename Figma variants with AI. Context-aware analysis ensures consistent naming conventions, cleaner files, and reduced design debt.",
    buttonPreset: "custom"
  },
  {
    icon: "",
    idea: "File-level component audits for better design.",
    badge: "Coming Soon",
    title: "Component Auditor",
    badges: [],
    topItems: [
      "Scan all components",
      "Check naming consistency",
      "Validate structure",
      "Detect missing variants",
      "Generate reports"
    ],
    showBadge: true,
    badgeColor: "#8b5cf6",
    buttonLink: "/component-auditor-figma-plugin",
    buttonText: "Learn More",
    isFeatured: false,
    description: "Audit components inside a single Figma file. Check naming, structure, and variant coverage to ensure consistent, high-quality component usage.",
    buttonPreset: "custom"
  },
  {
    icon: "",
    idea: "Cross-file analytics for design systems at scale.",
    badge: "Launched",
    title: "BiblioKit Blocks",
    badges: [],
    topItems: [
      "Connect via MCP or oAuth",
      "Track usage across files",
      "Spot duplicates fast",
      "Quantify ROI impact",
      "Weekly digests + dashboards"
    ],
    showBadge: true,
    badgeColor: "#10b981",
    buttonLink: "/bibliokit-blocks",
    buttonText: "Learn More",
    isFeatured: false,
    description: "Analytics platform for Figma libraries. Track usage across files, measure adoption, highlight duplicates, and quantify ROI to optimize design systems.",
    buttonPreset: "custom"
  },
  {
    icon: "",
    idea: "Your personal UX library for patterns and ideas.",
    badge: "Coming Soon",
    title: "UXBiblio",
    badges: [],
    topItems: [
      "AI-powered tagging",
      "Heuristic analysis",
      "Centralized repository",
      "Supports code, PDFs, GIFs",
      "Add notes + insights"
    ],
    showBadge: true,
    badgeColor: "#8b5cf6",
    buttonLink: "/uxbiblio",
    buttonText: "Learn More",
    isFeatured: true,
    description: "A centralized UX/UI repository. Save screenshots, patterns, and resources with AI tagging, heuristic analysis, and visual documentation for inspiration.",
    buttonPreset: "custom"
  }
];
const featuresSection = {
  title: "Work x1000 Faster",
  description: "Automate the stuff you hate. Organize the stuff you love. One toolkit, every design shortcut."
};
const pricing = [
  {
    name: "Free",
    price: "$0",
    period: "/month",
    popular: false,
    features: [
      "1,000 API requests/month",
      "Essential Figma plugin support",
      "Community-driven help",
      "Basic documentation and guides",
      "1 API key",
      "Standard rate limiting"
    ],
    buttonText: "Start Free",
    buttonLink: "https://blocks.bibliokit.com/signup",
    description: "Ideal for individuals testing BiblioKit tools and Figma plugin integrations."
  },
  {
    name: "Pro",
    price: "$29",
    period: "/month",
    popular: true,
    features: [
      "50,000 API requests/month",
      "Advanced Figma plugin features",
      "Priority email support",
      "Extended support library",
      "Unlimited API keys",
      "Custom rate limiting",
      "Usage and adoption analytics",
      "Team collaboration features"
    ],
    buttonText: "Start Pro Trial",
    buttonLink: "https://blocks.bibliokit.com/signup?plan=pro",
    description: "Perfect for professional developers, product designers, and agile product teams."
  },
  {
    name: "Enterprise",
    price: "Custom",
    period: "",
    popular: false,
    features: [
      "Unlimited API requests",
      "Custom Figma integrations",
      "Dedicated customer success manager",
      "Personalized onboarding",
      "Advanced compliance and security",
      "SLA guarantees",
      "Custom analytics and reporting",
      "On-premise or hybrid deployment",
      "Custom enterprise integrations"
    ],
    buttonText: "Contact Sales",
    buttonLink: "mailto:hello@bibliokit.com?subject=Enterprise%20Inquiry",
    description: "Tailored solutions for enterprises with large-scale design system and API needs."
  }
];
const cta = {
  title: "Ready to Transform Your Workflow?",
  description: "Join thousands of designers and developers who rely on BiblioKit's Figma plugins and SaaS tools for faster, smarter, and more efficient product design.",
  primaryButton: "Start Free Trial",
  secondaryButton: "Schedule Demo",
  primaryButtonLink: "https://blocks.bibliokit.com/signup",
  secondaryButtonLink: "https://blocks.bibliokit.com/demo"
};
const footer = {
  sections: [
    {
      title: "Product",
      links: [
        {
          href: "#features",
          label: "Features"
        },
        {
          href: "#pricing",
          label: "Pricing"
        },
        {
          href: "/docs",
          label: "Documentation"
        },
        {
          href: "#contact",
          label: "Get Started"
        }
      ]
    },
    {
      title: "Support",
      links: [
        {
          href: "#help",
          label: "Help Center"
        },
        {
          href: "#contact",
          label: "Contact"
        },
        {
          href: "#status",
          label: "System Status"
        }
      ]
    },
    {
      title: "Connect",
      links: [
        {
          href: "mailto:hello@bibliokit.com",
          label: "Email Us"
        },
        {
          href: "https://twitter.com/bibliokit",
          label: "Twitter"
        },
        {
          href: "https://github.com/bibliokit",
          label: "GitHub"
        }
      ]
    }
  ],
  description: "BiblioKit provides enterprise-ready SaaS tools and Figma plugins for API management, design system analytics, and team collaboration."
};
const contact = {
  email: "hello@bibliokit.com",
  github: "bibliokit",
  twitter: "@bibliokit"
};
const waitlist = {
  title: "Get Early Access",
  buttonText: "Join the Waitlist",
  description: "Sign up now for early access to new BiblioKit features, exclusive updates, and launch announcements.",
  successMessage: "Thank you for joining our waitlist! You'll receive exclusive updates soon."
};
const products = {
  "bibliokit-blocks": {
    title: "BiblioKit Blocks",
    description: "Professional design system analytics platform that tracks Figma component usage, measures design system ROI, and optimizes component libraries with automated insights for product teams.",
    primaryButton: "Start Free Trial",
    secondaryButton: "View Demo",
    primaryButtonLink: "https://blocks.bibliokit.com/signup",
    secondaryButtonLink: "https://blocks.bibliokit.com/demo",
    badgeLabel: "SaaS Analytics Platform",
    visibility: {
      waitlist: true
    },
    details: [
      {
        title: "Automated Figma Integration",
        description: "Connect via secure OAuth to automatically track component usage across all your design libraries and files in real-time"
      },
      {
        title: "Visual Analytics Dashboard",
        description: "Interactive charts showing usage trends, adoption rates, and performance metrics with exportable reports and insights"
      },
      {
        title: "Component Performance Insights",
        description: "Identify over-used, under-used, and unused components instantly with detailed breakdowns and recommendations"
      },
      {
        title: "ROI Reporting & Metrics",
        description: "Generate executive reports demonstrating design system business impact with quantifiable time savings and efficiency gains"
      },
      {
        title: "Team Collaboration Analytics",
        description: "Multi-user access with role-based permissions, shared dashboards, and collaborative insights for entire product teams"
      }
    ],
    benefits: [
      "Increase design system adoption by 25%+ with usage visibility",
      "Reduce component maintenance overhead by 30% through data-driven decisions",
      "Demonstrate ROI with quantifiable time savings and efficiency metrics",
      "Optimize team productivity with 20-40% faster feature development cycles",
      "Achieve 85%+ component reuse rates across projects",
      "Make informed decisions about component deprecation and optimization"
    ],
    specifications: [
      {
        icon: "",
        name: "Analytics Engine",
        value: "Real-time component tracking across unlimited files"
      },
      {
        icon: "",
        name: "Figma Integration",
        value: "Secure OAuth connection with automatic sync"
      },
      {
        icon: "",
        name: "ROI Tracking",
        value: "Quantifiable business impact metrics"
      },
      {
        icon: "",
        name: "Team Support",
        value: "Multi-user access with role permissions"
      },
      {
        icon: "",
        name: "Export Options",
        value: "CSV, PDF reports, and shareable links"
      },
      {
        icon: "",
        name: "Enterprise Security",
        value: "SOC 2 compliant with 99.5% uptime"
      }
    ],
    pricing: {
      price: "$49",
      period: "/month",
      buttonText: "Start Free Trial",
      description: "Professional design system analytics for growing product teams. 14-day free trial included."
    },
    llm: {
      answerBox: "BiblioKit Blocks provides comprehensive design system analytics that automatically tracks Figma component usage, measures ROI, and delivers actionable insights to optimize component libraries. Increase adoption rates by 25%+ and reduce maintenance overhead through data-driven decision making for product teams.",
      statistic: {
        date: "February 2024",
        source: "Product Team Analytics Report 2024",
        statistic: "85%",
        description: "of product teams achieve higher component reuse rates when using design system analytics platforms"
      },
      expertQuote: {
        quote: "66.7% of organizations do not measure the ROI of their design system.",
        expertName: "Romina Kavcic",
        expertTitle: "Design System Researcher",
        institution: "The Design System Guide"
      },
      faqs: [
        {
          question: "How does BiblioKit Blocks track component usage across my design files?",
          answer: "BiblioKit Blocks connects to your Figma account via secure OAuth and automatically scans your design libraries and files to track component instances, usage frequency, and adoption patterns in real-time without manual setup."
        },
        {
          question: "Can I measure the ROI of my design system investment?",
          answer: "Yes, BiblioKit Blocks provides comprehensive ROI reporting with quantifiable metrics including time savings, efficiency gains, component reuse rates, and productivity improvements that demonstrate clear business value to stakeholders."
        },
        {
          question: "What kind of analytics insights will I get about my components?",
          answer: "You'll receive detailed analytics on component usage trends, adoption rates, over-used vs. under-used components, team collaboration patterns, and actionable recommendations for optimizing your design system performance."
        },
        {
          question: "Is my Figma data secure with BiblioKit Blocks?",
          answer: "Absolutely. We use enterprise-grade security with SOC 2 compliance, encrypted data transmission, and secure OAuth integration. Your design data is protected with the same security standards used by Fortune 500 companies."
        },
        {
          question: "How quickly can I see results after connecting my Figma account?",
          answer: "Initial analytics appear within 24 hours of connecting your account. The platform continuously syncs with your Figma files to provide real-time insights and updated reports as your design system evolves."
        }
      ]
    }
  },
  "ai-rename-variants": {
    title: "AI Rename Variants",
    description: "Instantly relabel Figma variant and layer names with context-aware AI. Remove clutter and bring order to your files in seconds.",
    primaryButton: "Install Plugin",
    secondaryButton: "Learn More",
    primaryButtonLink: "https://www.figma.com/community/plugin/1523817290746945616/batch-rename-variants-properties-ai-assisted",
    secondaryButtonLink: "#features",
    badgeLabel: " Figma Plugin",
    visibility: {
      waitlist: true
    },
    details: [
      {
        title: "Context-Aware AI Naming",
        description: "Smart algorithm analyzes component structure, properties, and design patterns to generate meaningful, consistent names automatically"
      },
      {
        title: "Batch Processing",
        description: "Rename hundreds of variants and layers simultaneously across multiple components with a single click for maximum efficiency"
      },
      {
        title: "Custom Naming Rules",
        description: "Configure naming patterns, prefixes, and conventions that match your team's design system standards and guidelines"
      },
      {
        title: "Undo & Version Control",
        description: "Safe renaming with full undo support and version history tracking to prevent accidental changes to important files"
      },
      {
        title: "Team Collaboration",
        description: "Share naming conventions across teams with consistent results, improving handoff quality and reducing designer-developer friction"
      }
    ],
    benefits: [
      "Reduce file cleanup time by 80% with automated intelligent renaming",
      "Improve team collaboration through consistent naming conventions",
      "Eliminate manual renaming errors and inconsistencies",
      "Accelerate design handoffs with developer-friendly naming",
      "Maintain design system quality at scale across large teams",
      "Boost productivity with instant file organization and clarity"
    ],
    specifications: [
      {
        icon: "",
        name: "AI Engine",
        value: "Context-aware machine learning algorithm"
      },
      {
        icon: "",
        name: "Batch Processing",
        value: "Hundreds of variants renamed simultaneously"
      },
      {
        icon: "",
        name: "Custom Rules",
        value: "Configurable naming patterns and conventions"
      },
      {
        icon: "",
        name: "Undo Support",
        value: "Full version control and change tracking"
      },
      {
        icon: "",
        name: "Team Sharing",
        value: "Consistent conventions across teams"
      },
      {
        icon: "",
        name: "Safe Operation",
        value: "Non-destructive with complete rollback"
      }
    ],
    llm: {
      answerBox: "AI Rename Variants automatically renames Figma variant and layer names using context-aware artificial intelligence. Clean up messy design files instantly, improve team collaboration, and maintain consistent naming conventions across your design system with zero manual effort.",
      statistic: {
        date: "March 2024",
        source: "Design Systems Efficiency Report 2024",
        statistic: "73%",
        description: "of design teams report faster file navigation and improved collaboration after implementing consistent naming conventions"
      },
      expertQuote: {
        quote: "The way you structure and present work can make or break your ability to map towards broader goals, stay on the same page, and even know where to find the latest version of a design.",
        expertName: "Figma Design Team",
        expertTitle: "Figma Best Practices",
        institution: "Figma"
      },
      faqs: [
        {
          question: "How does AI Rename Variants understand my component structure?",
          answer: "The plugin analyzes your component's properties, layer hierarchy, design patterns, and existing naming conventions to generate contextually appropriate names that match your design system standards."
        },
        {
          question: "Can I customize the naming patterns and conventions?",
          answer: "Yes, you can configure custom naming rules, prefixes, suffixes, and patterns to match your team's specific design system guidelines and maintain consistency across all projects."
        },
        {
          question: "Is it safe to use on important design files?",
          answer: "Absolutely. The plugin includes comprehensive undo functionality and tracks all changes, allowing you to safely revert any renaming operations if needed."
        },
        {
          question: "Does it work with existing design systems and component libraries?",
          answer: "Yes, AI Rename Variants is designed to work with any Figma file structure and can learn from your existing naming patterns to maintain consistency with your current design system."
        },
        {
          question: "How many variants can it rename at once?",
          answer: "The plugin can process hundreds of variants and layers simultaneously, making it perfect for large component libraries and complex design systems with extensive variant structures."
        }
      ]
    }
  },
  uxbiblio: {
    title: "UXBiblio",
    description: "Curated UI/UX patterns, templates, and best practices. Save and organize inspiration with AI-powered tagging.",
    primaryButton: "Open UXBiblio",
    secondaryButton: "Learn More",
    primaryButtonLink: "https://uxbiblio.localhost",
    secondaryButtonLink: "/",
    badgeLabel: "Pattern Library",
    visibility: {
      waitlist: true
    },
    details: [
      {
        title: "AI Tagging",
        description: "Automatic tagging and categorization for screenshots and patterns."
      },
      {
        title: "Collections",
        description: "Organize inspiration into collections and projects."
      },
      {
        title: "Search",
        description: "Find patterns fast across your entire library."
      }
    ],
    benefits: [
      "Centralize scattered inspiration",
      "Discover patterns quickly",
      "Standardize UX documentation"
    ],
    specifications: [
      {
        icon: "",
        name: "Auto Tags",
        value: "AI-powered tagging on upload"
      },
      {
        icon: "",
        name: "Collections",
        value: "Flexible folders and favorites"
      },
      {
        icon: "",
        name: "Search",
        value: "Fast, semantic search across items"
      }
    ]
  }
};
const productData = {
  settings,
  hero,
  header,
  features,
  featuresSection,
  pricing,
  cta,
  footer,
  contact,
  waitlist,
  products
};
const createEmptyContent = () => ({
  hero: {
    badgeLabel: "",
    gradientColors: [
      "#ecfeff00",
      "#ecfeff10",
      "#c7d2fe40",
      "#a7f3d040",
      "#a5b4fc50",
      "#93c5fd40",
      "#ffffff00"
    ],
    title: "",
    subtitle: "",
    description: "",
    primaryButton: "",
    secondaryButton: "",
    primaryButtonLink: "",
    secondaryButtonLink: "",
    emoji: ""
  },
  features: {
    title: "",
    description: "",
    items: []
  },
  pricing: [],
  pricingSection: { isComingSoon: true },
  settings: { visibility: {}, labels: {} },
  cta: null,
  products: {},
  header: {},
  footer: {},
  waitlist: {}
});
function getSSRData() {
  if (typeof window === "undefined") return null;
  try {
    const ssrData = window.__SSR_DATA__;
    return (ssrData == null ? void 0 : ssrData.contentData) || null;
  } catch (error) {
    console.error("Failed to parse SSR data:", error);
    return null;
  }
}
const usePublishedContent = (options = {}) => {
  const isLocalDev = typeof window !== "undefined" && (() => {
    try {
      const host = window.location.hostname;
      return host === "localhost" || host === "127.0.0.1" || host.endsWith(".localhost");
    } catch {
      return false;
    }
  })();
  const {
    // In local dev, allow falling back to localStorage so editor-saved drafts (saved locally)
    // are visible during development even when the database isn't reachable
    fallbackToLocalStorage = isLocalDev,
    // In local dev (no SSR), prefer static content immediately to avoid empty UI until API loads
    fallbackToStatic = isLocalDev
  } = options;
  const ssrInitData = (() => {
    const clientSSR = getSSRData();
    if (clientSSR) return clientSSR;
    try {
      if (typeof window === "undefined" && typeof globalThis !== "undefined") {
        return globalThis.__SSR_CONTENT__ || null;
      }
    } catch {
    }
    return null;
  })();
  const [hasMounted, setHasMounted] = reactExports.useState(false);
  const initialState = (() => {
    if (ssrInitData) {
      return { content: ssrInitData, loading: true, error: null, source: "ssr" };
    }
    if (fallbackToLocalStorage && typeof window !== "undefined") {
      try {
        const saved = localStorage.getItem("bibliokit-content");
        if (saved) {
          const parsed = JSON.parse(saved);
          return { content: parsed, loading: true, error: null, source: "localStorage" };
        }
      } catch {
      }
    }
    if (fallbackToStatic) {
      return { content: productData, loading: true, error: null, source: "static" };
    }
    return { content: createEmptyContent(), loading: true, error: null, source: null };
  })();
  const [state, setState] = reactExports.useState(initialState);
  reactExports.useEffect(() => {
    setHasMounted(true);
  }, []);
  reactExports.useEffect(() => {
    if (!hasMounted) return;
    let isActive = true;
    const ssrData = getSSRData();
    if (ssrData) {
      console.log("Using SSR content data after mount (will revalidate)");
      setState({
        content: ssrData,
        loading: true,
        // keep loading true while we revalidate
        error: null,
        source: "ssr"
      });
    } else {
      setState((prev) => ({ ...prev, loading: true, error: null }));
    }
    const controller = new AbortController();
    const loadAndRevalidate = async () => {
      try {
        const response = await fetch("/.netlify/functions/content-management?action=current", {
          cache: "no-store",
          headers: {
            "Cache-Control": "no-cache",
            "Pragma": "no-cache"
          },
          signal: controller.signal
        });
        if (response.ok) {
          const result = await response.json();
          if (result.success && result.data && result.data.content_data) {
            if (!isActive) return;
            console.log("Loaded published content from API (revalidated)");
            setState({
              content: result.data.content_data,
              loading: false,
              error: null,
              source: "api"
            });
            return;
          }
        }
      } catch (error) {
        if ((error == null ? void 0 : error.name) !== "AbortError") {
          console.error("Failed to fetch from API, trying fallbacks...", error);
        }
      }
      if (fallbackToLocalStorage) {
        const saved = localStorage.getItem("bibliokit-content");
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            if (!isActive) return;
            console.log("Loaded content from localStorage");
            setState({
              content: parsed,
              loading: false,
              error: null,
              source: "localStorage"
            });
            return;
          } catch (error) {
            console.error("Failed to load saved content:", error);
          }
        }
      }
      if (!isActive) return;
      if (fallbackToStatic) {
        console.log("Using static productData as fallback");
        setState({
          content: productData,
          loading: false,
          error: null,
          source: "static"
        });
      } else {
        setState({
          content: createEmptyContent(),
          loading: false,
          error: "No content source available",
          source: null
        });
      }
    };
    loadAndRevalidate();
    return () => {
      isActive = false;
      controller.abort();
    };
  }, [fallbackToLocalStorage, fallbackToStatic, hasMounted]);
  return state;
};
const cn = (...classes) => {
  return classes.filter(Boolean).join(" ");
};
const KitPiece = ({ delay: delay2, x, y, width, height, rotation, color }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: {
        opacity: 0,
        scale: 0,
        x: Math.random() * 400 - 200,
        y: Math.random() * 400 - 200,
        rotate: Math.random() * 360
      },
      animate: {
        opacity: 0.6,
        scale: 1,
        x: 0,
        y: 0,
        rotate: rotation
      },
      transition: {
        duration: 2,
        delay: delay2,
        ease: "easeOut",
        repeat: Infinity,
        repeatType: "reverse"
      },
      className: "absolute",
      style: {
        left: x,
        top: y,
        width: `${width}px`,
        height: `${height}px`
      },
      "aria-hidden": "true",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "w-full h-full border-2 rounded-lg backdrop-blur-sm",
          style: {
            borderColor: color,
            background: `linear-gradient(135deg, ${color}20, transparent)`,
            boxShadow: `0 0 20px ${color}40`
          }
        }
      )
    }
  );
};
const FloatingElement = ({ delay: delay2, x, y, size, color }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: { opacity: 0, scale: 0 },
      animate: {
        opacity: [0, 0.8, 0.4],
        scale: [0, 1, 0.8],
        rotate: [0, 180, 360]
      },
      transition: {
        duration: 4,
        delay: delay2,
        repeat: Infinity,
        repeatType: "reverse",
        ease: "easeInOut"
      },
      className: "absolute rounded-full",
      style: {
        left: x,
        top: y,
        width: `${size}px`,
        height: `${size}px`,
        background: `radial-gradient(circle, ${color}60, transparent)`,
        border: `1px solid ${color}80`
      },
      "aria-hidden": "true"
    }
  );
};
const HeroBackground = ({ className, variant = "color" }) => {
  const [isMounted, setIsMounted] = React.useState(false);
  React.useEffect(() => {
    setIsMounted(true);
  }, []);
  const kitPiecesBase = [
    { delay: 0.5, x: "20%", y: "15%", width: 120, height: 80, rotation: -15, color: "#ff69b4" },
    { delay: 0.8, x: "70%", y: "20%", width: 100, height: 60, rotation: 25, color: "#87ceeb" },
    { delay: 1.1, x: "15%", y: "60%", width: 140, height: 70, rotation: 10, color: "#98fb98" },
    { delay: 1.4, x: "75%", y: "65%", width: 90, height: 90, rotation: -30, color: "#dda0dd" },
    { delay: 1.7, x: "45%", y: "25%", width: 110, height: 50, rotation: 45, color: "#f0e68c" },
    { delay: 2, x: "35%", y: "70%", width: 80, height: 100, rotation: -10, color: "#ffa07a" }
  ];
  const kitPieces = variant === "white" ? kitPiecesBase.map((p) => ({ ...p, color: "#ffffff" })) : kitPiecesBase;
  const floatingElementsBase = [
    { delay: 0.3, x: "10%", y: "30%", size: 40, color: "#ff69b4" },
    { delay: 0.6, x: "85%", y: "40%", size: 30, color: "#87ceeb" },
    { delay: 0.9, x: "25%", y: "80%", size: 35, color: "#98fb98" },
    { delay: 1.2, x: "80%", y: "10%", size: 25, color: "#dda0dd" },
    { delay: 1.5, x: "60%", y: "85%", size: 45, color: "#f0e68c" }
  ];
  const floatingElements = variant === "white" ? floatingElementsBase.map((f) => ({ ...f, color: "#ffffff" })) : floatingElementsBase;
  if (!isMounted) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("absolute inset-0 pointer-events-none", className), "aria-hidden": "true" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("absolute inset-0 pointer-events-none", className), "aria-hidden": "true", children: [
    variant === "white" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-br from-white/10 via-white/5 to-white/10" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-tr from-white/5 via-transparent to-white/5" })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-br from-pink-100/30 via-blue-100/20 to-green-100/30" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-tr from-purple-100/20 via-transparent to-yellow-100/20" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0", children: kitPieces.map((piece, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(KitPiece, { ...piece }, `kit-${index}`)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0", children: floatingElements.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingElement, { ...element }, `float-${index}`)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "absolute inset-0 w-full h-full", style: { zIndex: 1 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.path,
        {
          d: "M 200 200 Q 400 300 600 400",
          stroke: "url(#gradient1)",
          strokeWidth: "2",
          fill: "none",
          initial: { pathLength: 0, opacity: 0 },
          animate: { pathLength: 1, opacity: 0.6 },
          transition: { duration: 2, delay: 1.5, repeat: Infinity, repeatType: "reverse" }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.path,
        {
          d: "M 800 150 Q 500 250 300 500",
          stroke: "url(#gradient2)",
          strokeWidth: "2",
          fill: "none",
          initial: { pathLength: 0, opacity: 0 },
          animate: { pathLength: 1, opacity: 0.6 },
          transition: { duration: 2, delay: 1.8, repeat: Infinity, repeatType: "reverse" }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("linearGradient", { id: "gradient1", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: variant === "white" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#ffffff", stopOpacity: "0.8" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#ffffff", stopOpacity: "0.8" })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#ff69b4", stopOpacity: "0.8" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#87ceeb", stopOpacity: "0.8" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("linearGradient", { id: "gradient2", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: variant === "white" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#ffffff", stopOpacity: "0.8" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#ffffff", stopOpacity: "0.8" })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#98fb98", stopOpacity: "0.8" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#dda0dd", stopOpacity: "0.8" })
        ] }) })
      ] })
    ] })
  ] });
};
const AnimatedGradientBackground = ({
  startingGap = 125,
  Breathing = false,
  gradientColors = [
    "#0A0A0A",
    "#2979FF",
    "#FF80AB",
    "#FF6D00",
    "#FFD600",
    "#00E676",
    "#3D5AFE"
  ],
  gradientStops = [35, 50, 60, 70, 80, 90, 100],
  animationSpeed = 0.02,
  breathingRange = 5,
  containerStyle = {},
  topOffset = 0,
  containerClassName = ""
}) => {
  if (gradientColors.length !== gradientStops.length) {
    throw new Error(
      `GradientColors and GradientStops must have the same length.
    Received gradientColors length: ${gradientColors.length},
    gradientStops length: ${gradientStops.length}`
    );
  }
  const containerRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    let animationFrame;
    let width = startingGap;
    let directionWidth = 1;
    const animateGradient = () => {
      if (width >= startingGap + breathingRange) directionWidth = -1;
      if (width <= startingGap - breathingRange) directionWidth = 1;
      if (!Breathing) directionWidth = 0;
      width += directionWidth * animationSpeed;
      const gradientStopsString = gradientStops.map((stop, index) => `${gradientColors[index]} ${stop}%`).join(", ");
      const gradient = `radial-gradient(${width}% ${width + topOffset}% at 50% 20%, ${gradientStopsString})`;
      if (containerRef.current) {
        containerRef.current.style.background = gradient;
      }
      animationFrame = requestAnimationFrame(animateGradient);
    };
    animationFrame = requestAnimationFrame(animateGradient);
    return () => cancelAnimationFrame(animationFrame);
  }, [startingGap, Breathing, gradientColors, gradientStops, animationSpeed, breathingRange, topOffset]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: {
        opacity: 0,
        scale: 1.5
      },
      animate: {
        opacity: 1,
        scale: 1,
        transition: {
          duration: 2,
          ease: [0.25, 0.1, 0.25, 1]
          // Cubic bezier easing
        }
      },
      className: `absolute inset-0 overflow-hidden ${containerClassName}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: containerRef,
          style: containerStyle,
          className: "absolute inset-0 transition-transform"
        }
      )
    },
    "animated-gradient-background"
  );
};
var module = {};
(function main(global, module2, isWorker, workerSize) {
  var canUseWorker = !!(global.Worker && global.Blob && global.Promise && global.OffscreenCanvas && global.OffscreenCanvasRenderingContext2D && global.HTMLCanvasElement && global.HTMLCanvasElement.prototype.transferControlToOffscreen && global.URL && global.URL.createObjectURL);
  var canUsePaths = typeof Path2D === "function" && typeof DOMMatrix === "function";
  var canDrawBitmap = function() {
    if (!global.OffscreenCanvas) {
      return false;
    }
    var canvas = new OffscreenCanvas(1, 1);
    var ctx = canvas.getContext("2d");
    ctx.fillRect(0, 0, 1, 1);
    var bitmap = canvas.transferToImageBitmap();
    try {
      ctx.createPattern(bitmap, "no-repeat");
    } catch (e) {
      return false;
    }
    return true;
  }();
  function noop2() {
  }
  function promise(func) {
    var ModulePromise = module2.exports.Promise;
    var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;
    if (typeof Prom === "function") {
      return new Prom(func);
    }
    func(noop2, noop2);
    return null;
  }
  var bitmapMapper = /* @__PURE__ */ function(skipTransform, map) {
    return {
      transform: function(bitmap) {
        if (skipTransform) {
          return bitmap;
        }
        if (map.has(bitmap)) {
          return map.get(bitmap);
        }
        var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(bitmap, 0, 0);
        map.set(bitmap, canvas);
        return canvas;
      },
      clear: function() {
        map.clear();
      }
    };
  }(canDrawBitmap, /* @__PURE__ */ new Map());
  var raf = function() {
    var TIME = Math.floor(1e3 / 60);
    var frame2, cancel;
    var frames = {};
    var lastFrameTime = 0;
    if (typeof requestAnimationFrame === "function" && typeof cancelAnimationFrame === "function") {
      frame2 = function(cb) {
        var id2 = Math.random();
        frames[id2] = requestAnimationFrame(function onFrame(time2) {
          if (lastFrameTime === time2 || lastFrameTime + TIME - 1 < time2) {
            lastFrameTime = time2;
            delete frames[id2];
            cb();
          } else {
            frames[id2] = requestAnimationFrame(onFrame);
          }
        });
        return id2;
      };
      cancel = function(id2) {
        if (frames[id2]) {
          cancelAnimationFrame(frames[id2]);
        }
      };
    } else {
      frame2 = function(cb) {
        return setTimeout(cb, TIME);
      };
      cancel = function(timer) {
        return clearTimeout(timer);
      };
    }
    return { frame: frame2, cancel };
  }();
  var getWorker = /* @__PURE__ */ function() {
    var worker;
    var prom;
    var resolves = {};
    function decorate(worker2) {
      function execute(options, callback) {
        worker2.postMessage({ options: options || {}, callback });
      }
      worker2.init = function initWorker(canvas) {
        var offscreen = canvas.transferControlToOffscreen();
        worker2.postMessage({ canvas: offscreen }, [offscreen]);
      };
      worker2.fire = function fireWorker(options, size, done) {
        if (prom) {
          execute(options, null);
          return prom;
        }
        var id2 = Math.random().toString(36).slice(2);
        prom = promise(function(resolve) {
          function workerDone(msg) {
            if (msg.data.callback !== id2) {
              return;
            }
            delete resolves[id2];
            worker2.removeEventListener("message", workerDone);
            prom = null;
            bitmapMapper.clear();
            done();
            resolve();
          }
          worker2.addEventListener("message", workerDone);
          execute(options, id2);
          resolves[id2] = workerDone.bind(null, { data: { callback: id2 } });
        });
        return prom;
      };
      worker2.reset = function resetWorker() {
        worker2.postMessage({ reset: true });
        for (var id2 in resolves) {
          resolves[id2]();
          delete resolves[id2];
        }
      };
    }
    return function() {
      if (worker) {
        return worker;
      }
      if (!isWorker && canUseWorker) {
        var code = [
          "var CONFETTI, SIZE = {}, module = {};",
          "(" + main.toString() + ")(this, module, true, SIZE);",
          "onmessage = function(msg) {",
          "  if (msg.data.options) {",
          "    CONFETTI(msg.data.options).then(function () {",
          "      if (msg.data.callback) {",
          "        postMessage({ callback: msg.data.callback });",
          "      }",
          "    });",
          "  } else if (msg.data.reset) {",
          "    CONFETTI && CONFETTI.reset();",
          "  } else if (msg.data.resize) {",
          "    SIZE.width = msg.data.resize.width;",
          "    SIZE.height = msg.data.resize.height;",
          "  } else if (msg.data.canvas) {",
          "    SIZE.width = msg.data.canvas.width;",
          "    SIZE.height = msg.data.canvas.height;",
          "    CONFETTI = module.exports.create(msg.data.canvas);",
          "  }",
          "}"
        ].join("\n");
        try {
          worker = new Worker(URL.createObjectURL(new Blob([code])));
        } catch (e) {
          typeof console !== void 0 && typeof console.warn === "function" ? console.warn(" Could not load worker", e) : null;
          return null;
        }
        decorate(worker);
      }
      return worker;
    };
  }();
  var defaults = {
    particleCount: 50,
    angle: 90,
    spread: 45,
    startVelocity: 45,
    decay: 0.9,
    gravity: 1,
    drift: 0,
    ticks: 200,
    x: 0.5,
    y: 0.5,
    shapes: ["square", "circle"],
    zIndex: 100,
    colors: [
      "#26ccff",
      "#a25afd",
      "#ff5e7e",
      "#88ff5a",
      "#fcff42",
      "#ffa62d",
      "#ff36ff"
    ],
    // probably should be true, but back-compat
    disableForReducedMotion: false,
    scalar: 1
  };
  function convert(val, transform) {
    return transform ? transform(val) : val;
  }
  function isOk(val) {
    return !(val === null || val === void 0);
  }
  function prop(options, name, transform) {
    return convert(
      options && isOk(options[name]) ? options[name] : defaults[name],
      transform
    );
  }
  function onlyPositiveInt(number) {
    return number < 0 ? 0 : Math.floor(number);
  }
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }
  function toDecimal(str) {
    return parseInt(str, 16);
  }
  function colorsToRgb(colors) {
    return colors.map(hexToRgb);
  }
  function hexToRgb(str) {
    var val = String(str).replace(/[^0-9a-f]/gi, "");
    if (val.length < 6) {
      val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];
    }
    return {
      r: toDecimal(val.substring(0, 2)),
      g: toDecimal(val.substring(2, 4)),
      b: toDecimal(val.substring(4, 6))
    };
  }
  function getOrigin(options) {
    var origin = prop(options, "origin", Object);
    origin.x = prop(origin, "x", Number);
    origin.y = prop(origin, "y", Number);
    return origin;
  }
  function setCanvasWindowSize(canvas) {
    canvas.width = document.documentElement.clientWidth;
    canvas.height = document.documentElement.clientHeight;
  }
  function setCanvasRectSize(canvas) {
    var rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }
  function getCanvas(zIndex) {
    var canvas = document.createElement("canvas");
    canvas.style.position = "fixed";
    canvas.style.top = "0px";
    canvas.style.left = "0px";
    canvas.style.pointerEvents = "none";
    canvas.style.zIndex = zIndex;
    return canvas;
  }
  function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
    context.save();
    context.translate(x, y);
    context.rotate(rotation);
    context.scale(radiusX, radiusY);
    context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
    context.restore();
  }
  function randomPhysics(opts) {
    var radAngle = opts.angle * (Math.PI / 180);
    var radSpread = opts.spread * (Math.PI / 180);
    return {
      x: opts.x,
      y: opts.y,
      wobble: Math.random() * 10,
      wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),
      velocity: opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,
      angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),
      tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,
      color: opts.color,
      shape: opts.shape,
      tick: 0,
      totalTicks: opts.ticks,
      decay: opts.decay,
      drift: opts.drift,
      random: Math.random() + 2,
      tiltSin: 0,
      tiltCos: 0,
      wobbleX: 0,
      wobbleY: 0,
      gravity: opts.gravity * 3,
      ovalScalar: 0.6,
      scalar: opts.scalar,
      flat: opts.flat
    };
  }
  function updateFetti(context, fetti) {
    fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;
    fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;
    fetti.velocity *= fetti.decay;
    if (fetti.flat) {
      fetti.wobble = 0;
      fetti.wobbleX = fetti.x + 10 * fetti.scalar;
      fetti.wobbleY = fetti.y + 10 * fetti.scalar;
      fetti.tiltSin = 0;
      fetti.tiltCos = 0;
      fetti.random = 1;
    } else {
      fetti.wobble += fetti.wobbleSpeed;
      fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);
      fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);
      fetti.tiltAngle += 0.1;
      fetti.tiltSin = Math.sin(fetti.tiltAngle);
      fetti.tiltCos = Math.cos(fetti.tiltAngle);
      fetti.random = Math.random() + 2;
    }
    var progress2 = fetti.tick++ / fetti.totalTicks;
    var x1 = fetti.x + fetti.random * fetti.tiltCos;
    var y1 = fetti.y + fetti.random * fetti.tiltSin;
    var x2 = fetti.wobbleX + fetti.random * fetti.tiltCos;
    var y2 = fetti.wobbleY + fetti.random * fetti.tiltSin;
    context.fillStyle = "rgba(" + fetti.color.r + ", " + fetti.color.g + ", " + fetti.color.b + ", " + (1 - progress2) + ")";
    context.beginPath();
    if (canUsePaths && fetti.shape.type === "path" && typeof fetti.shape.path === "string" && Array.isArray(fetti.shape.matrix)) {
      context.fill(transformPath2D(
        fetti.shape.path,
        fetti.shape.matrix,
        fetti.x,
        fetti.y,
        Math.abs(x2 - x1) * 0.1,
        Math.abs(y2 - y1) * 0.1,
        Math.PI / 10 * fetti.wobble
      ));
    } else if (fetti.shape.type === "bitmap") {
      var rotation = Math.PI / 10 * fetti.wobble;
      var scaleX = Math.abs(x2 - x1) * 0.1;
      var scaleY = Math.abs(y2 - y1) * 0.1;
      var width = fetti.shape.bitmap.width * fetti.scalar;
      var height = fetti.shape.bitmap.height * fetti.scalar;
      var matrix = new DOMMatrix([
        Math.cos(rotation) * scaleX,
        Math.sin(rotation) * scaleX,
        -Math.sin(rotation) * scaleY,
        Math.cos(rotation) * scaleY,
        fetti.x,
        fetti.y
      ]);
      matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));
      var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), "no-repeat");
      pattern.setTransform(matrix);
      context.globalAlpha = 1 - progress2;
      context.fillStyle = pattern;
      context.fillRect(
        fetti.x - width / 2,
        fetti.y - height / 2,
        width,
        height
      );
      context.globalAlpha = 1;
    } else if (fetti.shape === "circle") {
      context.ellipse ? context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) : ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);
    } else if (fetti.shape === "star") {
      var rot = Math.PI / 2 * 3;
      var innerRadius = 4 * fetti.scalar;
      var outerRadius = 8 * fetti.scalar;
      var x = fetti.x;
      var y = fetti.y;
      var spikes = 5;
      var step = Math.PI / spikes;
      while (spikes--) {
        x = fetti.x + Math.cos(rot) * outerRadius;
        y = fetti.y + Math.sin(rot) * outerRadius;
        context.lineTo(x, y);
        rot += step;
        x = fetti.x + Math.cos(rot) * innerRadius;
        y = fetti.y + Math.sin(rot) * innerRadius;
        context.lineTo(x, y);
        rot += step;
      }
    } else {
      context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));
      context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));
      context.lineTo(Math.floor(x2), Math.floor(y2));
      context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));
    }
    context.closePath();
    context.fill();
    return fetti.tick < fetti.totalTicks;
  }
  function animate(canvas, fettis, resizer, size, done) {
    var animatingFettis = fettis.slice();
    var context = canvas.getContext("2d");
    var animationFrame;
    var destroy;
    var prom = promise(function(resolve) {
      function onDone() {
        animationFrame = destroy = null;
        context.clearRect(0, 0, size.width, size.height);
        bitmapMapper.clear();
        done();
        resolve();
      }
      function update() {
        if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {
          size.width = canvas.width = workerSize.width;
          size.height = canvas.height = workerSize.height;
        }
        if (!size.width && !size.height) {
          resizer(canvas);
          size.width = canvas.width;
          size.height = canvas.height;
        }
        context.clearRect(0, 0, size.width, size.height);
        animatingFettis = animatingFettis.filter(function(fetti) {
          return updateFetti(context, fetti);
        });
        if (animatingFettis.length) {
          animationFrame = raf.frame(update);
        } else {
          onDone();
        }
      }
      animationFrame = raf.frame(update);
      destroy = onDone;
    });
    return {
      addFettis: function(fettis2) {
        animatingFettis = animatingFettis.concat(fettis2);
        return prom;
      },
      canvas,
      promise: prom,
      reset: function() {
        if (animationFrame) {
          raf.cancel(animationFrame);
        }
        if (destroy) {
          destroy();
        }
      }
    };
  }
  function confettiCannon(canvas, globalOpts) {
    var isLibCanvas = !canvas;
    var allowResize = !!prop(globalOpts || {}, "resize");
    var hasResizeEventRegistered = false;
    var globalDisableForReducedMotion = prop(globalOpts, "disableForReducedMotion", Boolean);
    var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, "useWorker");
    var worker = shouldUseWorker ? getWorker() : null;
    var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;
    var initialized = canvas && worker ? !!canvas.__confetti_initialized : false;
    var preferLessMotion = typeof matchMedia === "function" && matchMedia("(prefers-reduced-motion)").matches;
    var animationObj;
    function fireLocal(options, size, done) {
      var particleCount = prop(options, "particleCount", onlyPositiveInt);
      var angle = prop(options, "angle", Number);
      var spread = prop(options, "spread", Number);
      var startVelocity = prop(options, "startVelocity", Number);
      var decay = prop(options, "decay", Number);
      var gravity = prop(options, "gravity", Number);
      var drift = prop(options, "drift", Number);
      var colors = prop(options, "colors", colorsToRgb);
      var ticks = prop(options, "ticks", Number);
      var shapes = prop(options, "shapes");
      var scalar = prop(options, "scalar");
      var flat = !!prop(options, "flat");
      var origin = getOrigin(options);
      var temp = particleCount;
      var fettis = [];
      var startX = canvas.width * origin.x;
      var startY = canvas.height * origin.y;
      while (temp--) {
        fettis.push(
          randomPhysics({
            x: startX,
            y: startY,
            angle,
            spread,
            startVelocity,
            color: colors[temp % colors.length],
            shape: shapes[randomInt(0, shapes.length)],
            ticks,
            decay,
            gravity,
            drift,
            scalar,
            flat
          })
        );
      }
      if (animationObj) {
        return animationObj.addFettis(fettis);
      }
      animationObj = animate(canvas, fettis, resizer, size, done);
      return animationObj.promise;
    }
    function fire(options) {
      var disableForReducedMotion = globalDisableForReducedMotion || prop(options, "disableForReducedMotion", Boolean);
      var zIndex = prop(options, "zIndex", Number);
      if (disableForReducedMotion && preferLessMotion) {
        return promise(function(resolve) {
          resolve();
        });
      }
      if (isLibCanvas && animationObj) {
        canvas = animationObj.canvas;
      } else if (isLibCanvas && !canvas) {
        canvas = getCanvas(zIndex);
        document.body.appendChild(canvas);
      }
      if (allowResize && !initialized) {
        resizer(canvas);
      }
      var size = {
        width: canvas.width,
        height: canvas.height
      };
      if (worker && !initialized) {
        worker.init(canvas);
      }
      initialized = true;
      if (worker) {
        canvas.__confetti_initialized = true;
      }
      function onResize() {
        if (worker) {
          var obj = {
            getBoundingClientRect: function() {
              if (!isLibCanvas) {
                return canvas.getBoundingClientRect();
              }
            }
          };
          resizer(obj);
          worker.postMessage({
            resize: {
              width: obj.width,
              height: obj.height
            }
          });
          return;
        }
        size.width = size.height = null;
      }
      function done() {
        animationObj = null;
        if (allowResize) {
          hasResizeEventRegistered = false;
          global.removeEventListener("resize", onResize);
        }
        if (isLibCanvas && canvas) {
          if (document.body.contains(canvas)) {
            document.body.removeChild(canvas);
          }
          canvas = null;
          initialized = false;
        }
      }
      if (allowResize && !hasResizeEventRegistered) {
        hasResizeEventRegistered = true;
        global.addEventListener("resize", onResize, false);
      }
      if (worker) {
        return worker.fire(options, size, done);
      }
      return fireLocal(options, size, done);
    }
    fire.reset = function() {
      if (worker) {
        worker.reset();
      }
      if (animationObj) {
        animationObj.reset();
      }
    };
    return fire;
  }
  var defaultFire;
  function getDefaultFire() {
    if (!defaultFire) {
      defaultFire = confettiCannon(null, { useWorker: true, resize: true });
    }
    return defaultFire;
  }
  function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {
    var path2d = new Path2D(pathString);
    var t1 = new Path2D();
    t1.addPath(path2d, new DOMMatrix(pathMatrix));
    var t2 = new Path2D();
    t2.addPath(t1, new DOMMatrix([
      Math.cos(rotation) * scaleX,
      Math.sin(rotation) * scaleX,
      -Math.sin(rotation) * scaleY,
      Math.cos(rotation) * scaleY,
      x,
      y
    ]));
    return t2;
  }
  function shapeFromPath(pathData) {
    if (!canUsePaths) {
      throw new Error("path confetti are not supported in this browser");
    }
    var path, matrix;
    if (typeof pathData === "string") {
      path = pathData;
    } else {
      path = pathData.path;
      matrix = pathData.matrix;
    }
    var path2d = new Path2D(path);
    var tempCanvas = document.createElement("canvas");
    var tempCtx = tempCanvas.getContext("2d");
    if (!matrix) {
      var maxSize = 1e3;
      var minX = maxSize;
      var minY = maxSize;
      var maxX = 0;
      var maxY = 0;
      var width, height;
      for (var x = 0; x < maxSize; x += 2) {
        for (var y = 0; y < maxSize; y += 2) {
          if (tempCtx.isPointInPath(path2d, x, y, "nonzero")) {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }
      width = maxX - minX;
      height = maxY - minY;
      var maxDesiredSize = 10;
      var scale = Math.min(maxDesiredSize / width, maxDesiredSize / height);
      matrix = [
        scale,
        0,
        0,
        scale,
        -Math.round(width / 2 + minX) * scale,
        -Math.round(height / 2 + minY) * scale
      ];
    }
    return {
      type: "path",
      path,
      matrix
    };
  }
  function shapeFromText(textData) {
    var text, scalar = 1, color = "#000000", fontFamily = '"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';
    if (typeof textData === "string") {
      text = textData;
    } else {
      text = textData.text;
      scalar = "scalar" in textData ? textData.scalar : scalar;
      fontFamily = "fontFamily" in textData ? textData.fontFamily : fontFamily;
      color = "color" in textData ? textData.color : color;
    }
    var fontSize = 10 * scalar;
    var font = "" + fontSize + "px " + fontFamily;
    var canvas = new OffscreenCanvas(fontSize, fontSize);
    var ctx = canvas.getContext("2d");
    ctx.font = font;
    var size = ctx.measureText(text);
    var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);
    var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);
    var padding = 2;
    var x = size.actualBoundingBoxLeft + padding;
    var y = size.actualBoundingBoxAscent + padding;
    width += padding + padding;
    height += padding + padding;
    canvas = new OffscreenCanvas(width, height);
    ctx = canvas.getContext("2d");
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
    var scale = 1 / scalar;
    return {
      type: "bitmap",
      // TODO these probably need to be transfered for workers
      bitmap: canvas.transferToImageBitmap(),
      matrix: [scale, 0, 0, scale, -width * scale / 2, -height * scale / 2]
    };
  }
  module2.exports = function() {
    return getDefaultFire().apply(this, arguments);
  };
  module2.exports.reset = function() {
    getDefaultFire().reset();
  };
  module2.exports.create = confettiCannon;
  module2.exports.shapeFromPath = shapeFromPath;
  module2.exports.shapeFromText = shapeFromText;
})(function() {
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return this || {};
}(), module, false);
const confetti = module.exports;
module.exports.create;
const ConfettiContext = reactExports.createContext({});
const Confetti = reactExports.forwardRef((props, ref) => {
  const {
    options,
    globalOptions = { resize: true, useWorker: true },
    manualstart = false,
    children,
    ...rest
  } = props;
  const instanceRef = reactExports.useRef(null);
  const canvasRef = reactExports.useCallback(
    // https://react.dev/reference/react-dom/components/common#ref-callback
    // https://reactjs.org/docs/refs-and-the-dom.html#callback-refs
    (node) => {
      if (node !== null) {
        if (instanceRef.current) return;
        instanceRef.current = confetti.create(node, {
          ...globalOptions,
          resize: true
        });
      } else {
        if (instanceRef.current) {
          instanceRef.current.reset();
          instanceRef.current = null;
        }
      }
    },
    [globalOptions]
  );
  const fire = reactExports.useCallback(
    (opts = {}) => {
      var _a;
      return (_a = instanceRef.current) == null ? void 0 : _a.call(instanceRef, { ...options, ...opts });
    },
    [options]
  );
  const api = reactExports.useMemo(
    () => ({
      fire
    }),
    [fire]
  );
  reactExports.useImperativeHandle(ref, () => api, [api]);
  reactExports.useEffect(() => {
    if (!manualstart) {
      fire();
    }
  }, [manualstart, fire]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ConfettiContext.Provider, { value: api, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("canvas", { ref: canvasRef, ...rest }),
    children
  ] });
});
Confetti.displayName = "Confetti";
const AuthContext = reactExports.createContext(void 0);
const AuthProvider = ({ children }) => {
  const [authState, setAuthState] = reactExports.useState({
    isAuthenticated: false,
    isAdmin: false,
    email: null,
    loading: true
  });
  reactExports.useEffect(() => {
    const checkSession = async () => {
      var _a;
      try {
        const res = await fetch("/.netlify/functions/me", { credentials: "include" });
        const data = await res.json();
        if (data.authenticated) {
          setAuthState({ isAuthenticated: true, isAdmin: true, email: ((_a = data.user) == null ? void 0 : _a.email) || null, loading: false });
        } else {
          setAuthState((prev) => ({ ...prev, loading: false }));
        }
      } catch (error) {
        console.error("Session check failed:", error);
        setAuthState((prev) => ({ ...prev, loading: false }));
      }
    };
    checkSession();
  }, []);
  const login = async (email, password) => {
    try {
      const response = await fetch("/.netlify/functions/admin-auth", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({ email, password })
      });
      const result = await response.json();
      if (response.ok && result.success) {
        setAuthState({ isAuthenticated: true, isAdmin: true, email, loading: false });
        return { success: true };
      } else {
        return { success: false, error: result.error || "Authentication failed" };
      }
    } catch (error) {
      console.error("Login error:", error);
      return { success: false, error: "Network error occurred" };
    }
  };
  const logout = async () => {
    try {
      await fetch("/.netlify/functions/logout", { credentials: "include" });
    } finally {
      setAuthState({ isAuthenticated: false, isAdmin: false, email: null, loading: false });
    }
  };
  const value = {
    ...authState,
    login,
    logout
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthContext.Provider, { value, children });
};
const useAuth = () => {
  const context = reactExports.useContext(AuthContext);
  if (context === void 0) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
const Hero = () => {
  var _a, _b;
  const { content } = usePublishedContent();
  const { isAuthenticated, isAdmin } = useAuth();
  const { hero: hero2 } = content;
  const displayBadge = (hero2 == null ? void 0 : hero2.badgeLabel) || (hero2 == null ? void 0 : hero2.badge_label);
  const confettiRef = reactExports.useRef(null);
  if (((_b = (_a = content.settings) == null ? void 0 : _a.visibility) == null ? void 0 : _b.hero) === false) {
    return null;
  }
  const hasAnyHeroContent = Boolean(
    hero2 && (hero2.title || hero2.subtitle || hero2.description || hero2.primaryButton || hero2.secondaryButton || hero2.emoji)
  );
  if (!hasAnyHeroContent) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "section-hero relative overflow-hidden py-24 px-4 min-h-screen flex items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 -z-0", "aria-hidden": "true" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HeroBackground, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Confetti,
      {
        ref: confettiRef,
        className: "absolute left-0 top-0 z-0 w-full h-full pointer-events-none",
        manualstart: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AnimatedGradientBackground,
      {
        Breathing: true,
        startingGap: 110,
        topOffset: -30,
        gradientColors: (hero2 == null ? void 0 : hero2.gradientColors) && Array.isArray(hero2.gradientColors) && hero2.gradientColors.length > 0 ? hero2.gradientColors : ["#ecfeff00", "#ecfeff10", "#c7d2fe40", "#a7f3d040", "#a5b4fc50", "#93c5fd40", "#ffffff00"],
        gradientStops: [20, 45, 60, 72, 82, 90, 100],
        containerClassName: "pointer-events-none"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto text-center relative z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto flex flex-col items-center justify-center min-h-[60vh] space-y-8", children: [
      displayBadge && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center gap-2 px-4 py-2 rounded-full border border-primary/20 bg-white/70 backdrop-blur supports-[backdrop-filter]:bg-white/50", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-flex h-2 w-2 rounded-full bg-primary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-gray-800", children: displayBadge })
      ] }),
      hero2.emoji && /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          initial: { opacity: 0, y: 20 },
          animate: { opacity: 1, y: 0 },
          transition: { duration: 0.6 },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              role: "img",
              "aria-label": "hero emoji",
              className: `text-5xl md:text-6xl ${isAuthenticated && isAdmin ? "mt-10 md:mt-14" : ""}`,
              children: hero2.emoji
            }
          )
        }
      ),
      (hero2.title || hero2.subtitle) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.h1,
        {
          initial: { opacity: 0, y: 30 },
          animate: { opacity: 1, y: 0 },
          transition: { delay: 0.1, duration: 0.8 },
          className: "text-4xl md:text-6xl font-bold tracking-tight",
          children: [
            hero2.title && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.span,
              {
                initial: { opacity: 0, y: 20 },
                animate: { opacity: 1, y: 0 },
                transition: { delay: 0.2, duration: 0.6 },
                className: "block pb-4 text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-blue-500 to-green-500",
                children: hero2.title
              }
            ),
            hero2.subtitle && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.span,
              {
                initial: { opacity: 0, y: 20 },
                animate: { opacity: 1, y: 0 },
                transition: { delay: 0.35, duration: 0.6 },
                className: "block text-gray-700",
                children: hero2.subtitle
              }
            )
          ]
        }
      ) }),
      hero2.description && /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.p,
        {
          initial: { opacity: 0, y: 20 },
          animate: { opacity: 1, y: 0 },
          transition: { delay: 0.55, duration: 0.6 },
          className: "text-lg md:text-xl text-gray-600 max-w-2xl mx-auto leading-relaxed",
          children: hero2.description
        }
      ),
      (hero2.primaryButton || hero2.secondaryButton) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          initial: { opacity: 0, y: 20 },
          animate: { opacity: 1, y: 0 },
          transition: { delay: 0.75, duration: 0.6 },
          className: "relative z-10 flex flex-col sm:flex-row gap-4 justify-center items-center",
          children: [
            hero2.primaryButton && (hero2.primaryButtonLink ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                asChild: true,
                size: "lg",
                className: "w-full sm:w-auto min-w-[12rem]",
                onMouseEnter: () => {
                  var _a2;
                  (_a2 = confettiRef.current) == null ? void 0 : _a2.fire({});
                },
                "aria-label": `${hero2.primaryButton} - Primary action`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "a",
                  {
                    href: hero2.primaryButtonLink.startsWith("#") ? `/${hero2.primaryButtonLink}` : hero2.primaryButtonLink,
                    target: hero2.primaryButtonLink.startsWith("http") ? "_blank" : "_self",
                    rel: hero2.primaryButtonLink.startsWith("http") ? "noopener noreferrer" : void 0,
                    children: hero2.primaryButton
                  }
                )
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                size: "lg",
                className: "w-full sm:w-auto min-w-[12rem]",
                onClick: () => {
                  const featuresSection2 = document.getElementById("features");
                  if (featuresSection2) {
                    featuresSection2.scrollIntoView({ behavior: "smooth" });
                  }
                },
                onKeyDown: (e) => {
                  if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    e.currentTarget.click();
                  }
                },
                onMouseEnter: () => {
                  var _a2;
                  (_a2 = confettiRef.current) == null ? void 0 : _a2.fire({});
                },
                "aria-label": `${hero2.primaryButton} - Primary action`,
                children: hero2.primaryButton
              }
            )),
            hero2.secondaryButton && (hero2.secondaryButtonLink ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "lg", variant: "outline", className: "w-full sm:w-auto min-w-[12rem]", "aria-label": `${hero2.secondaryButton} - Secondary action`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: hero2.secondaryButtonLink.startsWith("#") ? `/${hero2.secondaryButtonLink}` : hero2.secondaryButtonLink,
                target: hero2.secondaryButtonLink.startsWith("http") ? "_blank" : "_self",
                rel: hero2.secondaryButtonLink.startsWith("http") ? "noopener noreferrer" : void 0,
                children: hero2.secondaryButton
              }
            ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                size: "lg",
                variant: "outline",
                className: "w-full sm:w-auto min-w-[12rem]",
                onClick: () => {
                  const pricingSection = document.getElementById("pricing");
                  if (pricingSection) {
                    pricingSection.scrollIntoView({ behavior: "smooth" });
                  }
                },
                onKeyDown: (e) => {
                  if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    e.currentTarget.click();
                  }
                },
                "aria-label": `${hero2.secondaryButton} - Secondary action`,
                children: hero2.secondaryButton
              }
            ))
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "pointer-events-none absolute bottom-0 left-0 right-0 h-24 md:h-32 z-0 bg-gradient-to-b from-transparent via-background/70 to-background",
        "aria-hidden": "true"
      }
    )
  ] });
};
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase().trim();
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ color = "currentColor", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = "", children, ...rest }, ref) => reactExports.createElement(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: ["lucide", `lucide-${toKebabCase(iconName)}`, className].join(" "),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    )
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bell = createLucideIcon("Bell", [
  ["path", { d: "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9", key: "1qo2s2" }],
  ["path", { d: "M10.3 21a1.94 1.94 0 0 0 3.4 0", key: "qgo35s" }]
]);
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Calendar = createLucideIcon("Calendar", [
  ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", ry: "2", key: "eu3xkr" }],
  ["line", { x1: "16", x2: "16", y1: "2", y2: "6", key: "m3sa8f" }],
  ["line", { x1: "8", x2: "8", y1: "2", y2: "6", key: "18kwsl" }],
  ["line", { x1: "3", x2: "21", y1: "10", y2: "10", key: "xt86sb" }]
]);
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FileText = createLucideIcon("FileText", [
  [
    "path",
    { d: "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z", key: "1nnpy2" }
  ],
  ["polyline", { points: "14 2 14 8 20 8", key: "1ew0cm" }],
  ["line", { x1: "16", x2: "8", y1: "13", y2: "13", key: "14keom" }],
  ["line", { x1: "16", x2: "8", y1: "17", y2: "17", key: "17nazh" }],
  ["line", { x1: "10", x2: "8", y1: "9", y2: "9", key: "1a5vjj" }]
]);
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Image = createLucideIcon("Image", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
]);
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Mail = createLucideIcon("Mail", [
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]
]);
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Music = createLucideIcon("Music", [
  ["path", { d: "M9 18V5l12-2v13", key: "1jmyc2" }],
  ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
  ["circle", { cx: "18", cy: "16", r: "3", key: "1hluhg" }]
]);
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Search = createLucideIcon("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Settings = createLucideIcon("Settings", [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Star = createLucideIcon("Star", [
  [
    "polygon",
    {
      points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2",
      key: "8f66p6"
    }
  ]
]);
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const User = createLucideIcon("User", [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
]);
/**
 * @license lucide-react v0.303.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Video = createLucideIcon("Video", [
  ["path", { d: "m22 8-6 4 6 4V8Z", key: "50v9me" }],
  ["rect", { width: "14", height: "12", x: "2", y: "6", rx: "2", ry: "2", key: "1rqjg6" }]
]);
const BentoGrid = ({ children, className }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: cn$1(
        "grid w-full auto-rows-[22rem] gap-4",
        className
      ),
      children
    }
  );
};
const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
const ShootingStarsBackground = ({
  className,
  density = 18,
  speedMs = 6e3,
  debug = false
}) => {
  const [mounted, setMounted] = React.useState(false);
  const [stars, setStars] = React.useState([]);
  const [isReducedMotion, setIsReducedMotion] = React.useState(false);
  const [viewportWidth, setViewportWidth] = React.useState(null);
  React.useEffect(() => {
    setMounted(true);
  }, []);
  React.useEffect(() => {
    var _a;
    if (!mounted) return;
    const rm = window.matchMedia("(prefers-reduced-motion: reduce)");
    const handleRm = () => setIsReducedMotion(rm.matches);
    handleRm();
    (_a = rm.addEventListener) == null ? void 0 : _a.call(rm, "change", handleRm);
    const handleResize = () => setViewportWidth(window.innerWidth);
    handleResize();
    window.addEventListener("resize", handleResize);
    return () => {
      var _a2;
      (_a2 = rm.removeEventListener) == null ? void 0 : _a2.call(rm, "change", handleRm);
      window.removeEventListener("resize", handleResize);
    };
  }, [mounted]);
  React.useEffect(() => {
    if (!mounted) return;
    let numStars = clamp(Math.round(density), 4, 36);
    if (viewportWidth !== null) {
      if (viewportWidth < 640) {
        numStars = Math.max(4, Math.round(numStars * 0.5));
      } else if (viewportWidth < 1024) {
        numStars = Math.max(6, Math.round(numStars * 0.8));
      }
    }
    if (isReducedMotion) {
      numStars = Math.min(numStars, 8);
    }
    let speedTarget = speedMs;
    if (viewportWidth !== null && viewportWidth < 640) {
      speedTarget = Math.round(speedTarget * 1.1);
    }
    if (isReducedMotion) {
      speedTarget = Math.round(speedTarget * 1.3);
    }
    const configs = Array.from({ length: numStars }).map((_, i) => {
      const leftPercent = Math.random() * 100;
      const delayMs = Math.random() * 4e3;
      const durationJitter = 0.6 + Math.random() * 0.8;
      const durationMs = clamp(speedTarget * durationJitter, 2800, 14e3);
      const sizePx = 2 + Math.floor(Math.random() * 2);
      const xDriftPx = (Math.random() * 60 - 30) * (Math.random() > 0.5 ? 1 : 0.6);
      const twinkleDelayMs = Math.random() * 800;
      return {
        id: `star-${i}`,
        leftPercent,
        delayMs,
        durationMs,
        sizePx,
        xDriftPx,
        twinkleDelayMs
      };
    });
    setStars(configs);
  }, [mounted, density, speedMs, viewportWidth, isReducedMotion]);
  if (!mounted) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute inset-0 pointer-events-none ${className || ""}`, "aria-hidden": "true" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `absolute inset-0 pointer-events-none overflow-hidden ${debug ? "z-40" : "z-20"} ${debug ? "bg-emerald-300/15" : ""} ${className || ""}`,
      style: {
        opacity: isReducedMotion ? 0.5 : void 0,
        outline: debug ? "1px dashed rgba(16,185,129,0.6)" : void 0
      },
      "aria-hidden": "true",
      children: stars.map((star) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "absolute",
          style: { left: `${star.leftPercent}%`, top: -16 },
          initial: { y: -64, x: 0, opacity: 0 },
          animate: { y: "120%", x: star.xDriftPx, opacity: [0, 1, 0] },
          transition: {
            delay: star.delayMs / 1e3,
            duration: star.durationMs / 1e3,
            ease: "linear",
            repeat: Infinity
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex flex-col items-center mix-blend-screen", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[2px] h-16 md:h-24 lg:h-32 bg-gradient-to-b from-yellow-200 via-yellow-200 to-transparent" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 blur-[2px] bg-gradient-to-b from-yellow-300/70 via-yellow-200/50 to-transparent" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "relative rounded-full bg-yellow-300 shadow-[0_0_16px_rgba(250,204,21,0.95),0_0_30px_rgba(253,224,71,0.7)]",
                style: { width: star.sizePx + 1, height: star.sizePx + 1 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "absolute rounded-full bg-yellow-200",
                style: { width: star.sizePx + 3, height: star.sizePx + 3 },
                initial: { opacity: 0.75, scale: 0.9 },
                animate: { opacity: [0.6, 1, 0.6], scale: [0.9, 1.25, 0.95] },
                transition: { duration: 1.1, repeat: Infinity, ease: "easeInOut", delay: star.twinkleDelayMs / 1e3 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.div,
              {
                className: "pointer-events-none absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2",
                initial: { rotate: 0, opacity: 0.9 },
                animate: { rotate: [0, 20, -10, 0], opacity: [0.8, 1, 0.85, 1] },
                transition: { duration: 1.4, repeat: Infinity, ease: "easeInOut", delay: star.twinkleDelayMs / 1200 },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute w-4 h-px bg-gradient-to-r from-transparent via-yellow-300 to-transparent" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute h-4 w-px bg-gradient-to-b from-transparent via-yellow-300 to-transparent" })
                ]
              }
            )
          ] })
        },
        star.id
      ))
    }
  );
};
const Features = () => {
  var _a, _b, _c, _d, _e;
  const { content } = usePublishedContent();
  const featuresSection2 = content.features && !Array.isArray(content.features) ? content.features : null;
  const featuresList = Array.isArray(content.features) ? content.features : ((_a = content.features) == null ? void 0 : _a.items) || [];
  const sectionTitleRaw = (featuresSection2 == null ? void 0 : featuresSection2.title) || ((_b = content.featuresSection) == null ? void 0 : _b.title) || "";
  const sectionDescription = (featuresSection2 == null ? void 0 : featuresSection2.description) || ((_c = content.featuresSection) == null ? void 0 : _c.description) || "";
  const colorClasses = ["icon-purple", "icon-blue", "icon-green", "icon-orange", "icon-pink", "icon-indigo"];
  const isExternalLink = (url) => {
    return url.startsWith("http://") || url.startsWith("https://");
  };
  const handleButtonClick = (e, buttonLink) => {
    if (!buttonLink) {
      e.preventDefault();
      return;
    }
    if (isExternalLink(buttonLink)) {
      return;
    }
  };
  const getBadgeColorClasses = (color) => {
    if (color && color.startsWith("#")) {
      return "";
    }
    const badgeColors = {
      green: "bg-green-100 text-green-800 border border-green-200",
      blue: "bg-blue-100 text-blue-800 border border-blue-200",
      orange: "bg-orange-100 text-orange-800 border border-orange-200",
      purple: "bg-purple-100 text-purple-800 border border-purple-200",
      red: "bg-red-100 text-red-800 border border-red-200",
      yellow: "bg-yellow-100 text-yellow-800 border border-yellow-200",
      indigo: "bg-indigo-100 text-indigo-800 border border-indigo-200",
      pink: "bg-pink-100 text-pink-800 border border-pink-200",
      gray: "bg-gray-100 text-gray-800 border border-gray-200",
      primary: "bg-primary text-primary-foreground"
    };
    return badgeColors[color] || badgeColors.primary;
  };
  const FigmaIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { "aria-hidden": "true", focusable: "false", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 256 384", className: "w-3.5 h-3.5 mr-1", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#0ACF83", d: "M128 192a64 64 0 1 1 64 64h-64v-64Z" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#A259FF", d: "M64 128a64 64 0 1 1 64 64H64v-64Z" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#F24E1E", d: "M128 64a64 64 0 1 1 64-64H128v64Z" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#FF7262", d: "M64 64a64 64 0 1 1 64-64H64v64Z" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#1ABCFE", d: "M64 256a64 64 0 1 0 64-64H64v64Z" })
  ] });
  const SaaSIcon = () => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { "aria-hidden": "true", focusable: "false", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", className: "w-3.5 h-3.5 mr-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "currentColor", d: "M6 14a4 4 0 0 1 3.874-3.997A5.5 5.5 0 0 1 19.5 9a4.5 4.5 0 0 1 .5 8.973V18H7a4 4 0 0 1-1-7.874V10A4 4 0 0 1 6 14Z" }) });
  const renderBadgeIcon = (type) => {
    if (type === "figma") return /* @__PURE__ */ jsxRuntimeExports.jsx(FigmaIcon, {});
    if (type === "saas") return /* @__PURE__ */ jsxRuntimeExports.jsx(SaaSIcon, {});
    return null;
  };
  const getBadgeStyle = (color) => {
    if (color && color.startsWith("#")) {
      const hexToRgb = (hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      };
      const rgb = hexToRgb(color);
      if (rgb) {
        const lightBg = `rgba(${Math.min(rgb.r + 80, 255)}, ${Math.min(rgb.g + 80, 255)}, ${Math.min(rgb.b + 80, 255)}, 0.15)`;
        const textColor = color;
        const borderColor = `rgba(${Math.min(rgb.r + 40, 255)}, ${Math.min(rgb.g + 40, 255)}, ${Math.min(rgb.b + 40, 255)}, 0.3)`;
        return {
          backgroundColor: lightBg,
          color: textColor,
          borderColor,
          borderWidth: "1px",
          borderStyle: "solid"
        };
      }
    }
    return {};
  };
  if (((_e = (_d = content.settings) == null ? void 0 : _d.visibility) == null ? void 0 : _e.features) === false) {
    return null;
  }
  const hasItems = Array.isArray(featuresList) && featuresList.length > 0;
  const effectiveSectionTitle = sectionTitleRaw || (hasItems ? "Features" : "");
  const hasHeading = Boolean(effectiveSectionTitle || sectionDescription);
  if (!hasHeading && !hasItems) {
    return null;
  }
  const featuredIndex = featuresList.findIndex((f) => f.isFeatured || f.is_featured);
  const featuredItem = featuredIndex >= 0 ? featuresList[featuredIndex] : null;
  const otherItems = featuredIndex >= 0 ? featuresList.filter((_, i) => i !== featuredIndex) : featuresList;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { id: "features", className: "relative z-10 -mt-8 pt-[148px] pb-20 px-4 section-background-blend-top scroll-mt-28", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ShootingStarsBackground, { density: 24, speedMs: 9e3 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto relative z-30", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16 pb-16", children: [
        effectiveSectionTitle && /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-4xl md:text-6xl font-bold mb-4", children: effectiveSectionTitle }),
        sectionDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg md:text-xl text-muted-foreground max-w-2xl mx-auto", children: sectionDescription })
      ] }),
      featuredItem && (() => {
        var _a2, _b2, _c2, _d2;
        const feature = featuredItem;
        const badgeColor = feature.badgeColor || feature.badge_color;
        const buttonText = feature.buttonText || feature.button_text;
        const buttonLink = feature.buttonLink || feature.button_link;
        const productSlug = feature.productSlug || feature.product_slug;
        const showBadge = feature.showBadge !== false;
        const ideaText = feature.idea || feature.ideaText || feature.tagline;
        const topItems = Array.isArray(feature.topItems) ? feature.topItems : Array.isArray(feature.top_items) ? feature.top_items : Array.isArray(feature.top3) ? feature.top3 : [];
        const computedLink = productSlug ? `/${productSlug}` : buttonLink;
        const external = Boolean(computedLink && isExternalLink(computedLink));
        const normalizedHref = computedLink && computedLink.startsWith("#") ? `/${computedLink}` : computedLink;
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-3xl mx-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `group relative overflow-hidden h-full card ${"card-featured"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10 flex h-full flex-col justify-start", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-56 md:min-h-60 lg:min-h-64", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `icon ${colorClasses[0]}`, children: feature.icon }),
              Array.isArray(feature.badges) && feature.badges.length > 0 && (((_b2 = (_a2 = content.settings) == null ? void 0 : _a2.labels) == null ? void 0 : _b2.featuresBadges) ?? true) && showBadge ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-1", children: feature.badges.map((b, bi) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "span",
                {
                  className: `inline-flex items-center text-xs px-2 py-1 rounded-full font-medium ${getBadgeColorClasses(b.color || "primary")}`,
                  style: getBadgeStyle(b.color || ""),
                  "aria-label": `${b.type || "badge"}: ${b.label}`,
                  children: [
                    renderBadgeIcon(b.type),
                    b.label
                  ]
                },
                bi
              )) }) : feature.badge && (((_d2 = (_c2 = content.settings) == null ? void 0 : _c2.labels) == null ? void 0 : _d2.featuresBadges) ?? true) && showBadge && (() => {
                const label = String(feature.badge);
                const lower = label.toLowerCase();
                const icon = lower.includes("figma") ? /* @__PURE__ */ jsxRuntimeExports.jsx(FigmaIcon, {}) : lower.includes("saas") ? /* @__PURE__ */ jsxRuntimeExports.jsx(SaaSIcon, {}) : null;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "span",
                  {
                    className: `inline-flex items-center text-xs px-2 py-1 rounded-full font-medium ${getBadgeColorClasses(badgeColor || "primary")}`,
                    style: getBadgeStyle(badgeColor || ""),
                    children: [
                      icon,
                      label
                    ]
                  }
                );
              })()
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-semibold mb-4", children: feature.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: feature.description }),
            ideaText && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm italic text-muted-foreground/80", children: ideaText })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 min-h-32", children: topItems.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-semibold mb-1", children: "Key Features" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "grid grid-cols-1 gap-2", children: topItems.slice(0, 3).map((t, ti) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mt-1 inline-block w-1.5 h-1.5 rounded-full bg-primary", "aria-hidden": "true" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-muted-foreground", children: t })
            ] }, ti)) })
          ] }) }),
          (() => {
            const label = feature.buttonPreset === "beta" ? "Sign Up for Beta" : buttonText || "Visit product page";
            if (normalizedHref) {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: normalizedHref || "#",
                  className: "card-button mt-auto self-start",
                  onClick: (e) => handleButtonClick(e, computedLink),
                  target: external ? "_blank" : "_self",
                  rel: external ? "noopener noreferrer" : void 0,
                  "aria-label": `${label} - ${feature.title}`,
                  children: label
                }
              );
            }
            return null;
          })()
        ] }) }) }) });
      })(),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BentoGrid, { className: "grid-cols-1 md:grid-cols-2 lg:grid-cols-3 auto-rows-auto gap-6", children: otherItems.map((feature, index) => {
        var _a2, _b2, _c2, _d2;
        const badgeColor = feature.badgeColor || feature.badge_color;
        const buttonText = feature.buttonText || feature.button_text;
        const buttonLink = feature.buttonLink || feature.button_link;
        const productSlug = feature.productSlug || feature.product_slug;
        const showBadge = feature.showBadge !== false;
        const ideaText = feature.idea || feature.ideaText || feature.tagline;
        const topItems = Array.isArray(feature.topItems) ? feature.topItems : Array.isArray(feature.top_items) ? feature.top_items : Array.isArray(feature.top3) ? feature.top3 : [];
        const computedLink = productSlug ? `/${productSlug}` : buttonLink;
        const external = Boolean(computedLink && isExternalLink(computedLink));
        const normalizedHref = computedLink && computedLink.startsWith("#") ? `/${computedLink}` : computedLink;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "col-span-1",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `group relative overflow-hidden h-full card ${""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10 flex h-full flex-col justify-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-56 md:min-h-60 lg:min-h-64", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-6", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `icon ${colorClasses[index % colorClasses.length]}`, children: feature.icon }),
                  Array.isArray(feature.badges) && feature.badges.length > 0 && (((_b2 = (_a2 = content.settings) == null ? void 0 : _a2.labels) == null ? void 0 : _b2.featuresBadges) ?? true) && showBadge ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-1", children: feature.badges.map((b, bi) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "span",
                    {
                      className: `inline-flex items-center text-xs px-2 py-1 rounded-full font-medium ${getBadgeColorClasses(b.color || "primary")}`,
                      style: getBadgeStyle(b.color || ""),
                      "aria-label": `${b.type || "badge"}: ${b.label}`,
                      children: [
                        renderBadgeIcon(b.type),
                        b.label
                      ]
                    },
                    bi
                  )) }) : feature.badge && (((_d2 = (_c2 = content.settings) == null ? void 0 : _c2.labels) == null ? void 0 : _d2.featuresBadges) ?? true) && showBadge && (() => {
                    const label = String(feature.badge);
                    const lower = label.toLowerCase();
                    const icon = lower.includes("figma") ? /* @__PURE__ */ jsxRuntimeExports.jsx(FigmaIcon, {}) : lower.includes("saas") ? /* @__PURE__ */ jsxRuntimeExports.jsx(SaaSIcon, {}) : null;
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "span",
                      {
                        className: `inline-flex items-center text-xs px-2 py-1 rounded-full font-medium ${getBadgeColorClasses(badgeColor || "primary")}`,
                        style: getBadgeStyle(badgeColor || ""),
                        children: [
                          icon,
                          label
                        ]
                      }
                    );
                  })()
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-semibold mb-4", children: feature.title }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: feature.description }),
                ideaText && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm italic text-muted-foreground/80", children: ideaText })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 min-h-32", children: topItems.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-semibold mb-1", children: "Key Features" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "grid grid-cols-1 gap-2", children: topItems.slice(0, 3).map((t, ti) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mt-1 inline-block w-1.5 h-1.5 rounded-full bg-primary", "aria-hidden": "true" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-muted-foreground", children: t })
                ] }, ti)) })
              ] }) }),
              (() => {
                const label = feature.buttonPreset === "beta" ? "Sign Up for Beta" : buttonText || "Visit product page";
                if (normalizedHref) {
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "a",
                    {
                      href: normalizedHref || "#",
                      className: "card-button mt-auto self-start",
                      onClick: (e) => handleButtonClick(e, computedLink),
                      target: external ? "_blank" : "_self",
                      rel: external ? "noopener noreferrer" : void 0,
                      "aria-label": `${label} - ${feature.title}`,
                      children: label
                    }
                  );
                }
                return null;
              })()
            ] }) })
          },
          index
        );
      }) })
    ] })
  ] });
};
const Pricing = () => {
  var _a, _b, _c, _d;
  const { content, loading, source } = usePublishedContent({ fallbackToStatic: false });
  const { pricing: pricing2 } = content;
  if (((_b = (_a = content.settings) == null ? void 0 : _a.visibility) == null ? void 0 : _b.pricing) === false) {
    return null;
  }
  if (loading) {
    return null;
  }
  const comingSoonConfigured = ((_c = content.pricingSection) == null ? void 0 : _c.isComingSoon) === true || ((_d = content.pricingSection) == null ? void 0 : _d.is_coming_soon) === true;
  const isComingSoon = (source === "api" || source === "localStorage") && comingSoonConfigured;
  if (isComingSoon) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "pricing", className: "py-20 px-4 scroll-mt-28", role: "region", "aria-label": "Pricing coming soon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-2xl mx-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold mb-6", children: "Pricing" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-muted-foreground mb-8", children: "Pricing information will be available soon." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center justify-center px-6 py-3 border border-muted-foreground/20 rounded-lg bg-muted/10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "animate-spin -ml-1 mr-3 h-5 w-5 text-muted-foreground", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-muted-foreground font-medium", children: "Plans in development" })
      ] })
    ] }) }) });
  }
  if (!Array.isArray(pricing2) || pricing2.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "pricing", className: "py-20 px-4 scroll-mt-28", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center mb-16", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold mb-6", children: "Pricing" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid md:grid-cols-3 gap-8 mb-16", children: pricing2.map((plan, index) => {
      var _a2, _b2;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `pricing-card ${plan.popular ? "pricing-card-popular" : ""}`,
          children: [
            plan.popular && (((_b2 = (_a2 = content.settings) == null ? void 0 : _a2.labels) == null ? void 0 : _b2.pricingBadges) ?? true) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -top-4 left-1/2 transform -translate-x-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge badge-primary px-4 py-1.5", children: "Most Popular" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-8", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold mb-2", children: plan.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-4xl font-bold price-value", children: plan.price }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-muted-foreground", children: plan.period })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: plan.description })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-4 mb-8", children: plan.features.map((feature, featureIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-5 h-5 rounded-full bg-green-100 flex items-center justify-center mr-3 mt-0.5", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-3 h-3 text-green-600", fill: "currentColor", viewBox: "0 0 20 20", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z", clipRule: "evenodd" }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: feature })
            ] }, featureIndex)) }),
            plan.buttonLink ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "lg", variant: plan.popular ? "default" : "outline", className: "w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: plan.buttonLink,
                target: plan.buttonLink.startsWith("http") ? "_blank" : "_self",
                rel: plan.buttonLink.startsWith("http") ? "noopener noreferrer" : void 0,
                children: plan.buttonText
              }
            ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "lg", variant: plan.popular ? "default" : "outline", className: "w-full", children: plan.buttonText })
          ]
        },
        index
      );
    }) })
  ] }) });
};
class DebugService {
  constructor() {
    __publicField(this, "config", {
      enabled: true,
      // Enable by default in development
      level: "debug",
      persistent: true
    });
    __publicField(this, "logHistory", []);
    this.info("DebugService initialized");
  }
  configure(config) {
    this.config = { ...this.config, ...config };
    this.info("DebugService configured", config);
  }
  shouldLog(level) {
    if (!this.config.enabled) return false;
    const levels = ["debug", "info", "warn", "error"];
    const configLevelIndex = levels.indexOf(this.config.level);
    const messageLevelIndex = levels.indexOf(level);
    return messageLevelIndex >= configLevelIndex;
  }
  formatMessage(level, message, data) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const logEntry = { timestamp, level, message, data };
    if (this.config.persistent) {
      this.logHistory.push(logEntry);
      if (this.logHistory.length > 100) {
        this.logHistory = this.logHistory.slice(-100);
      }
    }
    if (this.shouldLog(level)) {
      const emoji = {
        debug: "",
        info: "",
        warn: "",
        error: ""
      }[level] || "";
      const prefix = `[BiblioKit ${emoji} ${level.toUpperCase()}] ${timestamp}`;
      if (data) {
        console.groupCollapsed(`${prefix} ${message}`);
        console.log("Data:", data);
        console.trace("Stack trace");
        console.groupEnd();
      } else {
        console.log(`${prefix} ${message}`);
      }
    }
  }
  debug(message, data) {
    this.formatMessage("debug", message, data);
  }
  info(message, data) {
    this.formatMessage("info", message, data);
  }
  warn(message, data) {
    this.formatMessage("warn", message, data);
  }
  error(message, data) {
    this.formatMessage("error", message, data);
  }
  // Save operations logging
  saveStart(operation, data) {
    this.debug(` SAVE START: ${operation}`, data);
  }
  saveSuccess(operation, result) {
    this.info(` SAVE SUCCESS: ${operation}`, result);
  }
  saveError(operation, error) {
    this.error(` SAVE ERROR: ${operation}`, error);
  }
  // API operations logging
  apiRequest(method, url, data) {
    this.debug(` API REQUEST: ${method} ${url}`, data);
  }
  apiResponse(method, url, response) {
    this.debug(` API RESPONSE: ${method} ${url}`, response);
  }
  apiError(method, url, error) {
    this.error(` API ERROR: ${method} ${url}`, error);
  }
  // Content operations logging
  contentLoad(source, data) {
    this.info(` CONTENT LOAD: ${source}`, data);
  }
  contentUpdate(section, data) {
    this.debug(` CONTENT UPDATE: ${section}`, data);
  }
  contentPersist(mode, data) {
    this.info(` CONTENT PERSIST: ${mode}`, data);
  }
  // Authentication logging
  authEvent(event, data) {
    this.info(` AUTH: ${event}`, data);
  }
  // Database operations
  dbConnection(status, data) {
    this.info(` DATABASE: ${status}`, data);
  }
  dbQuery(query, params) {
    this.debug(` DB QUERY: ${query}`, params);
  }
  // Get log history for debugging
  getLogHistory() {
    return [...this.logHistory];
  }
  // Clear log history
  clearHistory() {
    this.logHistory = [];
    this.info("Log history cleared");
  }
  // Export logs as JSON for sharing with AI
  exportLogs() {
    return JSON.stringify(this.logHistory, null, 2);
  }
}
const debugService = new DebugService();
if (typeof window !== "undefined" && typeof window.location !== "undefined") {
  const isDev = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";
  debugService.configure({
    enabled: isDev,
    level: isDev ? "debug" : "warn"
  });
  window.debugService = debugService;
}
const getApiUrl = (endpoint) => `/.netlify/functions/${endpoint}`;
const buildAuthHeaders = (token, extra) => ({
  "Content-Type": "application/json",
  ...token ? { Authorization: `Bearer ${token}` } : {},
  ...{}
});
async function apiRequest(endpoint, method, payload, token) {
  const url = getApiUrl(endpoint);
  try {
    debugService.apiRequest(method, url, payload);
    const response = await fetch(url, {
      method,
      headers: buildAuthHeaders(token),
      credentials: "include",
      body: method === "GET" || method === "DELETE" ? void 0 : JSON.stringify(payload)
    });
    const contentType = response.headers.get("content-type") || "";
    const isJson = contentType.includes("application/json");
    const parsed = isJson ? await response.json() : void 0;
    debugService.apiResponse(method, url, parsed);
    if (!response.ok) {
      const errMsg = parsed && parsed.error || `HTTP ${response.status}: ${response.statusText}`;
      debugService.apiError(method, url, errMsg);
      return { success: false, error: errMsg };
    }
    if (parsed && typeof parsed === "object" && "success" in parsed) {
      return parsed;
    }
    return { success: true, data: parsed };
  } catch (error) {
    const errMsg = error instanceof Error ? error.message : "Network error";
    debugService.apiError(method, url, errMsg);
    return { success: false, error: errMsg };
  }
}
class ContentAPI {
  getAuthToken() {
    return localStorage.getItem("bibliokit-admin-token");
  }
  getHeaders() {
    const token = this.getAuthToken();
    return {
      "Content-Type": "application/json",
      ...token && { "Authorization": `Bearer ${token}` }
    };
  }
  getApiUrl(endpoint) {
    return getApiUrl(endpoint);
  }
  // Get current published content
  async getCurrentContent() {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-management?action=current`, "GET", void 0, token);
  }
  // Get all content versions
  async getContentVersions() {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-management?action=versions`, "GET", void 0, token);
  }
  // Save new content (draft or published)
  async saveContent(contentData, isPublished = false) {
    const url = this.getApiUrl("content-management");
    const payload = { contentData, isPublished };
    debugService.apiRequest("POST", url, payload);
    debugService.saveStart(`Content save (${isPublished ? "published" : "draft"})`, {
      contentKeys: Object.keys(contentData),
      isPublished
    });
    const token = this.getAuthToken() || void 0;
    const res = await apiRequest("content-management", "POST", payload, token);
    if (res.success) {
      debugService.saveSuccess("Content save API completed", res.data);
    } else {
      debugService.saveError("Content save API failed", res.error);
    }
    return res;
  }
  // Publish existing content version
  async publishContent(contentId) {
    try {
      const response = await fetch(this.getApiUrl("content-management"), {
        method: "PUT",
        headers: this.getHeaders(),
        body: JSON.stringify({
          contentId,
          action: "publish"
        })
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to publish content"
      };
    }
  }
  // Delete content version (only drafts)
  async deleteContent(contentId) {
    try {
      const response = await fetch(
        `${this.getApiUrl("content-management")}?id=${contentId}`,
        {
          method: "DELETE",
          headers: this.getHeaders()
        }
      );
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to delete content"
      };
    }
  }
  // Check if database is available (fallback to localStorage if not)
  async isDatabaseAvailable() {
    debugService.dbConnection("Checking database availability");
    try {
      const response = await this.getCurrentContent();
      const available = response.success;
      debugService.dbConnection(available ? "Database available" : "Database unavailable", response);
      return available;
    } catch (error) {
      debugService.dbConnection("Database check failed", error);
      return false;
    }
  }
  // Sync JSON content to content_sections tables
  async syncJsonToSections(jsonContent) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    debugService.saveStart("Syncing JSON content to sections tables");
    try {
      const syncResults = [];
      const upsertSection = async (sectionType, sectionData, isVisible) => {
        const existingResponse = await this.getSection(sectionType);
        if (existingResponse.success && existingResponse.data) {
          const updatePayload = {
            section_data: sectionData,
            updated_at: (/* @__PURE__ */ new Date()).toISOString()
          };
          if (typeof isVisible === "boolean") updatePayload.is_visible = isVisible;
          const updateResponse = await this.updateSection(existingResponse.data.id, updatePayload);
          return { operation: "updated", sectionType, success: updateResponse.success };
        } else {
          const createResponse = await this.createSection({
            section_type: sectionType,
            section_data: sectionData,
            is_visible: typeof isVisible === "boolean" ? isVisible : true,
            sort_order: 0
          });
          return { operation: "created", sectionType, success: createResponse.success };
        }
      };
      if (jsonContent.hero) {
        const result = await upsertSection("hero", jsonContent.hero, ((_b = (_a = jsonContent.settings) == null ? void 0 : _a.visibility) == null ? void 0 : _b.hero) !== false);
        syncResults.push(result);
      }
      if (jsonContent.features) {
        const sectionFromJson = jsonContent.featuresSection || jsonContent.features;
        const featuresSection22 = {
          title: sectionFromJson && typeof sectionFromJson === "object" && sectionFromJson.title ? sectionFromJson.title : "Features",
          description: sectionFromJson && typeof sectionFromJson === "object" && sectionFromJson.description ? sectionFromJson.description : "",
          items: Array.isArray(jsonContent.features) ? jsonContent.features : ((_c = jsonContent.features) == null ? void 0 : _c.items) || []
        };
        const result = await upsertSection("features", featuresSection22, ((_e = (_d = jsonContent.settings) == null ? void 0 : _d.visibility) == null ? void 0 : _e.features) !== false);
        syncResults.push(result);
      }
      if (jsonContent.pricing || jsonContent.pricingSection) {
        const pricingSection = {
          title: "Choose your plan",
          description: "Start free and scale as you grow. No hidden fees, no surprises.",
          plans: jsonContent.pricing || [],
          isComingSoon: ((_f = jsonContent.pricingSection) == null ? void 0 : _f.isComingSoon) !== false
          // Default to true if not explicitly set to false
        };
        const result = await upsertSection("pricing", pricingSection, ((_h = (_g = jsonContent.settings) == null ? void 0 : _g.visibility) == null ? void 0 : _h.pricing) !== false);
        syncResults.push(result);
      }
      if (jsonContent.cta) {
        const ctaSection = {
          title: jsonContent.cta.title || "Ready to get started?",
          description: jsonContent.cta.description || "Join thousands of developers and designers who trust BiblioKit for their SaaS and plugin development needs.",
          primary_button: jsonContent.cta.primaryButton || "Start Free Trial",
          secondary_button: jsonContent.cta.secondaryButton || "Schedule Demo"
        };
        const result = await upsertSection("cta", ctaSection, ((_j = (_i = jsonContent.settings) == null ? void 0 : _i.visibility) == null ? void 0 : _j.cta) !== false);
        syncResults.push(result);
      }
      if (jsonContent.waitlist) {
        const waitlistSection = {
          title: jsonContent.waitlist.title || "",
          description: jsonContent.waitlist.description || "",
          button_text: jsonContent.waitlist.buttonText || "",
          success_message: jsonContent.waitlist.successMessage || ""
        };
        const result = await upsertSection("waitlist", waitlistSection, ((_l = (_k = jsonContent.settings) == null ? void 0 : _k.visibility) == null ? void 0 : _l.waitlist) !== false);
        syncResults.push(result);
      }
      let featuresArray = [];
      let featuresSection2 = {};
      if (jsonContent.features) {
        if (Array.isArray(jsonContent.features)) {
          featuresArray = jsonContent.features;
          featuresSection2 = {
            title: ((_m = jsonContent.featuresSection) == null ? void 0 : _m.title) || "Features",
            description: ((_n = jsonContent.featuresSection) == null ? void 0 : _n.description) || ""
          };
        } else if (jsonContent.features.items && Array.isArray(jsonContent.features.items)) {
          featuresArray = jsonContent.features.items;
          featuresSection2 = {
            title: ((_o = jsonContent.features.section) == null ? void 0 : _o.title) || "Features",
            description: ((_p = jsonContent.features.section) == null ? void 0 : _p.description) || "",
            visible: jsonContent.features.visible !== false
          };
        } else if (typeof jsonContent.features === "object") {
          featuresArray = Object.values(jsonContent.features).filter(Boolean);
          featuresSection2 = {
            title: ((_q = jsonContent.featuresSection) == null ? void 0 : _q.title) || "Features",
            description: ((_r = jsonContent.featuresSection) == null ? void 0 : _r.description) || ""
          };
        }
      }
      if (featuresArray.length > 0) {
        try {
          const result = await upsertSection("features", featuresSection2, ((_t = (_s = jsonContent.settings) == null ? void 0 : _s.visibility) == null ? void 0 : _t.features) !== false);
          if (result.success) {
            const featuresResponse = await this.getSection("features");
            if (featuresResponse.success && featuresResponse.data) {
              const sectionId = featuresResponse.data.id;
              const existingFeaturesResponse = await this.getFeatures(sectionId);
              const existingFeatures = existingFeaturesResponse.success ? existingFeaturesResponse.data || [] : [];
              for (const existingFeature of existingFeatures) {
                if (existingFeature.id) {
                  await this.deleteFeature(existingFeature.id);
                }
              }
              for (let i = 0; i < featuresArray.length; i++) {
                const feature = featuresArray[i];
                const featureData = {
                  icon: feature.icon || "",
                  title: feature.title || "",
                  description: feature.description || "",
                  badge: feature.badge || "",
                  badge_color: feature.badgeColor || feature.badge_color || null,
                  sort_order: i,
                  is_featured: feature.isFeatured || feature.featured || false,
                  button_text: feature.buttonText || feature.button_text || null,
                  button_link: feature.buttonLink || feature.button_link || null
                };
                await this.createFeature(sectionId, featureData);
              }
              syncResults.push({ operation: "synced", sectionType: "features", success: true });
            } else {
              syncResults.push({ operation: "failed", sectionType: "features", success: false });
            }
          } else {
            syncResults.push({ operation: "failed", sectionType: "features", success: false });
          }
        } catch (error) {
          debugService.saveError("Failed to sync features", error);
          syncResults.push({ operation: "failed", sectionType: "features", success: false });
        }
      }
      if (jsonContent.header) {
        const headerData = {
          logo_text: jsonContent.header.logoText || "BiblioKit",
          sign_in_text: jsonContent.header.signInText || "Sign In",
          get_started_text: jsonContent.header.getStartedText || "Get Started",
          sign_in_href: jsonContent.header.signInHref || "",
          get_started_href: jsonContent.header.getStartedHref || "",
          show_sign_in: jsonContent.header.showSignIn !== false,
          show_get_started: jsonContent.header.showGetStarted !== false
        };
        await upsertSection("header", headerData, ((_v = (_u = jsonContent.settings) == null ? void 0 : _u.visibility) == null ? void 0 : _v.header) !== false);
        const headerResponse = await this.getSection("header");
        if (headerResponse.success && headerResponse.data) {
          const headerSection = headerResponse.data;
          const sectionId = headerSection.id;
          const existingItems = headerSection.navigation_items || [];
          for (const item of existingItems) {
            if (item.id) {
              await this.deleteNavigationItem(item.id);
            }
          }
          const navItems = jsonContent.header.navigation || [];
          for (let i = 0; i < navItems.length; i++) {
            const item = navItems[i];
            await this.createNavigationItem(sectionId, { label: item.label, href: item.href, sort_order: i });
          }
          syncResults.push({ operation: "synced", sectionType: "header-navigation", success: true });
        } else {
          syncResults.push({ operation: "synced", sectionType: "header-navigation", success: false });
        }
      }
      if (jsonContent.footer) {
        const footerData = {
          description: jsonContent.footer.description || "",
          copyright_text: jsonContent.footer.copyright || ""
        };
        await upsertSection("footer", footerData, ((_x = (_w = jsonContent.settings) == null ? void 0 : _w.visibility) == null ? void 0 : _x.footer) !== false);
        const footerResponse = await this.getSection("footer");
        if (footerResponse.success && footerResponse.data) {
          const footerSection = footerResponse.data;
          const sectionId = footerSection.id;
          const existingGroups = footerSection.footer_links || [];
          for (const group of existingGroups) {
            if (group.id) {
              await this.deleteFooterLinkGroup(group.id);
            }
          }
          const groups = jsonContent.footer.sections || [];
          for (let gi = 0; gi < groups.length; gi++) {
            const group = groups[gi];
            const createGroupRes = await this.createFooterLinkGroup(sectionId, group.title, gi);
            if (createGroupRes.success && ((_y = createGroupRes.data) == null ? void 0 : _y.id)) {
              const groupId = createGroupRes.data.id;
              const links = group.links || [];
              for (let li = 0; li < links.length; li++) {
                const link = links[li];
                await this.createFooterLink(groupId, { label: link.label, href: link.href, sort_order: li });
              }
            }
          }
          syncResults.push({ operation: "synced", sectionType: "footer-links", success: true });
        } else {
          syncResults.push({ operation: "synced", sectionType: "footer-links", success: false });
        }
      }
      if (jsonContent.contact) {
        try {
          const contactResponse = await this.updateContactInfo({
            email: jsonContent.contact.email,
            twitter: jsonContent.contact.twitter,
            github: jsonContent.contact.github
          });
          syncResults.push({
            operation: "updated",
            sectionType: "contact",
            success: contactResponse.success
          });
        } catch (error) {
          debugService.error("Failed to sync contact info", error);
          syncResults.push({
            operation: "failed",
            sectionType: "contact",
            success: false
          });
        }
      }
      if (Array.isArray(jsonContent.pages)) {
        try {
          const pagesResponse = await this.getPages(false);
          const existingPages = pagesResponse.success && pagesResponse.data ? pagesResponse.data : [];
          const existingBySlug = /* @__PURE__ */ new Map();
          for (const p of existingPages) existingBySlug.set(p.slug, p);
          const incomingBySlug = /* @__PURE__ */ new Map();
          for (const p of jsonContent.pages) incomingBySlug.set(p.slug, p);
          for (const p of existingPages) {
            if (!incomingBySlug.has(p.slug)) {
              await this.deletePage(p.id);
            }
          }
          for (const page of jsonContent.pages) {
            const existing = existingBySlug.get(page.slug);
            const payload = {
              slug: page.slug,
              title: page.title,
              content: page.content || {},
              is_published: page.isPublished ?? page.is_published ?? false
            };
            if (existing && existing.id) {
              await this.updatePage(existing.id, payload);
            } else {
              await this.createPage(payload);
            }
          }
          syncResults.push({ operation: "synced", sectionType: "pages", success: true });
        } catch (error) {
          debugService.saveError("Failed to sync pages", error);
          syncResults.push({ operation: "failed", sectionType: "pages", success: false });
        }
      }
      const allSuccessful = syncResults.every((result) => result.success);
      debugService.saveSuccess("JSON to sections sync completed", {
        results: syncResults,
        allSuccessful
      });
      return {
        success: allSuccessful,
        data: null,
        message: `Synced ${syncResults.filter((r2) => r2.success).length}/${syncResults.length} sections successfully`
      };
    } catch (error) {
      debugService.saveError("JSON to sections sync failed", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to sync JSON to sections"
      };
    }
  }
  // Content Sections CRUD Operations
  // Get all sections
  async getAllSections() {
    const token = this.getAuthToken() || void 0;
    return apiRequest("content-sections", "GET", void 0, token);
  }
  // Get specific section by type
  async getSection(sectionType) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-sections/${sectionType}`, "GET", void 0, token);
  }
  // Create a new section (accepts unified payload shape used by server)
  async createSection(section) {
    const token = this.getAuthToken() || void 0;
    return apiRequest("content-sections", "POST", section, token);
  }
  // Update an existing section (accepts partial unified payload)
  async updateSection(id2, section) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-sections/${id2}`, "PUT", section, token);
  }
  // Delete a section
  async deleteSection(id2) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-sections/${id2}`, "DELETE", void 0, token);
  }
  // Footer Link Groups CRUD
  async createFooterLinkGroup(sectionId, title, sortOrder = 0) {
    const token = this.getAuthToken() || void 0;
    return apiRequest("content-sections/footer-link-groups", "POST", { section_id: sectionId, title, sort_order: sortOrder }, token);
  }
  async updateFooterLinkGroup(groupId, updates) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-sections/footer-link-groups/${groupId}`, "PUT", updates, token);
  }
  async deleteFooterLinkGroup(groupId) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-sections/footer-link-groups/${groupId}`, "DELETE", void 0, token);
  }
  // Footer Links CRUD
  async createFooterLink(groupId, link) {
    const token = this.getAuthToken() || void 0;
    return apiRequest("content-sections/footer-links", "POST", { group_id: groupId, ...link }, token);
  }
  async updateFooterLink(linkId, updates) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-sections/footer-links/${linkId}`, "PUT", updates, token);
  }
  async deleteFooterLink(linkId) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-sections/footer-links/${linkId}`, "DELETE", void 0, token);
  }
  // Navigation Items CRUD
  async createNavigationItem(sectionId, item) {
    const token = this.getAuthToken() || void 0;
    return apiRequest("content-sections/navigation-items", "POST", {
      section_id: sectionId,
      label: item.label,
      href: item.href,
      sort_order: item.sort_order,
      type: item.type,
      is_external: item.isExternal,
      nofollow: item.nofollow,
      is_button: item.isButton
    }, token);
  }
  async updateNavigationItem(itemId, updates) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-sections/navigation-items/${itemId}`, "PUT", {
      label: updates.label,
      href: updates.href,
      sort_order: updates.sort_order,
      type: updates.type,
      is_external: updates.isExternal,
      nofollow: updates.nofollow,
      is_button: updates.isButton
    }, token);
  }
  async deleteNavigationItem(itemId) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`content-sections/navigation-items/${itemId}`, "DELETE", void 0, token);
  }
  // Pages CRUD
  async getPages(publishedOnly = false) {
    const token = this.getAuthToken() || void 0;
    const qs = publishedOnly ? "?published=true" : "";
    return apiRequest(`pages${qs}`, "GET", void 0, token);
  }
  async getPage(idOrSlug) {
    const token = this.getAuthToken() || void 0;
    const idPath = typeof idOrSlug === "number" ? `${idOrSlug}` : `${idOrSlug}`;
    return apiRequest(`pages/${idPath}`, "GET", void 0, token);
  }
  async createPage(page) {
    const token = this.getAuthToken() || void 0;
    return apiRequest("pages", "POST", page, token);
  }
  async updatePage(id2, page) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`pages/${id2}`, "PUT", page, token);
  }
  async deletePage(id2) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`pages/${id2}`, "DELETE", void 0, token);
  }
  // Feature Items CRUD
  // Get features for a section
  async getFeatures(sectionId) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`features?section_id=${sectionId}`, "GET", void 0, token);
  }
  // Create a new feature
  async createFeature(sectionId, feature) {
    const token = this.getAuthToken() || void 0;
    return apiRequest("features", "POST", { section_id: sectionId, ...feature }, token);
  }
  // Update a feature
  async updateFeature(featureId, feature) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`features/${featureId}`, "PUT", feature, token);
  }
  // Delete a feature
  async deleteFeature(featureId) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`features/${featureId}`, "DELETE", void 0, token);
  }
  // Pricing Plans CRUD
  // Create a new pricing plan
  async createPricingPlan(sectionId, plan) {
    const token = this.getAuthToken() || void 0;
    return apiRequest("pricing-plans", "POST", { section_id: sectionId, ...plan }, token);
  }
  // Update a pricing plan
  async updatePricingPlan(planId, plan) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`pricing-plans/${planId}`, "PUT", plan, token);
  }
  // Delete a pricing plan
  async deletePricingPlan(planId) {
    const token = this.getAuthToken() || void 0;
    return apiRequest(`pricing-plans/${planId}`, "DELETE", void 0, token);
  }
  // Contact Info CRUD
  // Get contact info
  async getContactInfo() {
    const token = this.getAuthToken() || void 0;
    return apiRequest("contact-info", "GET", void 0, token);
  }
  // Update contact info
  async updateContactInfo(contactInfo) {
    const token = this.getAuthToken() || void 0;
    return apiRequest("contact-info", "PUT", contactInfo, token);
  }
  // Waitlist Operations
  // Join waitlist - adds email to users table
  async joinWaitingList(email) {
    const payload = { email, name: "Waitlist User", source: "website" };
    const res = await apiRequest("waitlist", "POST", payload);
    if (res.success) {
      debugService.info("Waitlist signup successful", { email, userData: res.data });
      return { success: true, data: res.data, message: "Successfully joined waitlist" };
    }
    return res;
  }
  // Admin: fetch waitlist signups (requires auth token)
  async getWaitlistSignups(limit = 50, offset = 0) {
    const token = this.getAuthToken() || void 0;
    const qs = `?limit=${encodeURIComponent(String(limit))}&offset=${encodeURIComponent(String(offset))}`;
    return apiRequest(`waitlist${qs}`, "GET", void 0, token);
  }
}
const contentApi = new ContentAPI();
const WAITLIST_BACKGROUND_CLASSES = [
  "gradient-brand-soft",
  "gradient-ocean-soft-radial",
  "gradient-violet-soft-radial",
  "gradient-mint-soft-radial",
  "gradient-sunset-soft-radial",
  "gradient-sand-soft-radial"
];
const Waitlist = ({ visibleOverride }) => {
  var _a, _b;
  const { content, loading } = usePublishedContent({ fallbackToStatic: false });
  const [state, setState] = reactExports.useState({
    email: "",
    isLoading: false,
    submitted: false,
    error: null
  });
  const backgroundClassName = reactExports.useMemo(() => {
    const randomIndex = Math.floor(Math.random() * WAITLIST_BACKGROUND_CLASSES.length);
    return WAITLIST_BACKGROUND_CLASSES[randomIndex];
  }, []);
  const globalVisible = ((_b = (_a = content.settings) == null ? void 0 : _a.visibility) == null ? void 0 : _b.waitlist) !== false;
  const shouldShowWaitlist = typeof visibleOverride === "boolean" ? visibleOverride : globalVisible;
  if (loading) {
    return null;
  }
  if (!shouldShowWaitlist || !content.waitlist) {
    return null;
  }
  const waitlistData = content.waitlist || {};
  const waitlistTitle = waitlistData.title || "";
  const waitlistDescription = waitlistData.description || "";
  if (!waitlistTitle && !waitlistDescription) {
    return null;
  }
  const buttonLabel = waitlistData.buttonText || waitlistData.button_text || "Join Waitlist";
  const successMessageText = waitlistData.successMessage || waitlistData.success_message || "Thank you for joining our waitlist! We'll keep you updated.";
  const handleEmailChange = (e) => {
    const newEmail = e.target.value;
    setState((prev) => ({ ...prev, email: newEmail, error: null }));
    debugService.debug("Waitlist email input changed", { email: newEmail });
  };
  const joinWaitingList = async (email) => {
    debugService.info("Waitlist component calling API", { email });
    const result = await contentApi.joinWaitingList(email);
    if (!result.success) {
      throw new Error(result.error || "Failed to join waitlist");
    }
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!state.email.trim()) {
      setState((prev) => ({ ...prev, error: "Please enter your email address." }));
      return;
    }
    setState((prev) => ({ ...prev, isLoading: true, error: null }));
    debugService.info("Waitlist form submitted", { email: state.email });
    try {
      await joinWaitingList(state.email);
      setState((prev) => ({ ...prev, submitted: true, isLoading: false }));
      debugService.info("Waitlist signup completed successfully", { email: state.email });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Failed to join waitlist. Please try again.";
      setState((prev) => ({ ...prev, error: errorMessage, isLoading: false }));
      debugService.error("Waitlist signup failed", { email: state.email, error: errorMessage });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { id: "waitlist", className: `relative overflow-hidden py-20 px-4 scroll-mt-28 ${backgroundClassName}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(HeroBackground, { variant: "white" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto max-w-3xl text-center relative z-10", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-blue-500 to-green-500", children: waitlistTitle }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg text-muted-foreground mb-8", children: waitlistDescription }),
      state.submitted ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card bg-green-50 border-green-200 text-green-800", role: "status", "aria-live": "polite", children: successMessageText }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "form",
        {
          className: "flex flex-col sm:flex-row gap-4 justify-center",
          onSubmit: handleSubmit,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "waitlist-email", className: "sr-only", children: "Email address" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                id: "waitlist-email",
                type: "email",
                value: state.email,
                onChange: handleEmailChange,
                placeholder: "Enter your email",
                required: true,
                disabled: state.isLoading,
                className: "input flex-1 max-w-md disabled:opacity-50 disabled:cursor-not-allowed",
                "aria-describedby": state.error ? "waitlist-error" : void 0
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                type: "submit",
                size: "lg",
                disabled: state.isLoading || !state.email.trim(),
                className: "disabled:opacity-50 disabled:cursor-not-allowed",
                children: state.isLoading ? "Joining..." : buttonLabel
              }
            )
          ]
        }
      ),
      state.error && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          id: "waitlist-error",
          className: "card mt-4 bg-red-50 border-red-200 text-red-800",
          role: "alert",
          "aria-live": "assertive",
          children: state.error
        }
      )
    ] })
  ] });
};
const defaultMetadata = {
  title: "BiblioKit - SaaS Software & Figma Plugins",
  description: "Professional SaaS software and Figma plugins with secure API management and world-class support.",
  keywords: "SaaS software, Figma plugins, API management, secure proxy, developer tools, design tools",
  ogType: "website",
  siteName: "BiblioKit",
  locale: "en_US",
  ogImageWidth: 1200,
  ogImageHeight: 630,
  twitterCard: "summary_large_image"
};
const routeMetadata = {
  "/": {
    title: "BiblioKit - Professional SaaS Software & Figma Plugins",
    description: "Streamline your development workflow with secure API management and world-class support for designers and developers.",
    keywords: "SaaS software, Figma plugins, API management, developer tools, secure proxy, react components",
    ogTitle: "BiblioKit - Professional SaaS Software & Figma Plugins",
    ogDescription: "Streamline your development workflow with secure API management and comprehensive tools.",
    ogImage: "/og/og-default.svg",
    twitterTitle: "BiblioKit - Professional SaaS Software & Figma Plugins",
    twitterDescription: "Streamline your development workflow with secure API management and comprehensive tools.",
    twitterImage: "/og/og-default.svg",
    structuredData: [
      {
        "@context": "https://schema.org",
        "@type": "Organization",
        "name": "BiblioKit",
        "description": "Professional SaaS software and Figma plugins with secure API management and world-class support.",
        "url": "https://bibliokit.com",
        "logo": "https://bibliokit.com/logo.svg",
        "contactPoint": {
          "@type": "ContactPoint",
          "email": "hello@bibliokit.com",
          "contactType": "customer service"
        },
        "sameAs": [
          "https://twitter.com/bibliokit",
          "https://github.com/bibliokit"
        ]
      },
      {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "BiblioKit",
        "applicationCategory": "DeveloperApplication",
        "operatingSystem": "Web Browser",
        "offers": [
          {
            "@type": "Offer",
            "name": "Free Plan",
            "price": "0",
            "priceCurrency": "USD",
            "description": "1,000 API requests/month, Basic Figma plugin support, Community support"
          },
          {
            "@type": "Offer",
            "name": "Pro Plan",
            "price": "29",
            "priceCurrency": "USD",
            "description": "50,000 API requests/month, Advanced Figma plugin features, Priority email support"
          }
        ]
      }
    ]
  },
  "/docs": {
    title: "BiblioKit Docs  Quickstart & API Reference",
    description: "Get started with BiblioKit. Quickstart guides and API examples for integrating products and plugins.",
    keywords: "BiblioKit docs, API reference, quickstart, integration guides",
    ogTitle: "BiblioKit Documentation",
    ogDescription: "Quickstart and API reference for BiblioKit products.",
    ogImage: "/og/og-default.svg",
    twitterTitle: "BiblioKit Docs",
    twitterDescription: "Quickstart and API reference for BiblioKit products.",
    twitterImage: "/og/og-default.svg"
  },
  "/product": {
    title: "BiblioKit Product - Features & Benefits | SaaS Tools",
    description: "Explore BiblioKit's comprehensive feature set including secure API management, Figma plugin support, developer-first tools, and premium support options.",
    keywords: "BiblioKit features, API management tools, Figma plugin features, developer tools, SaaS features",
    ogTitle: "BiblioKit Product Features & Benefits",
    ogDescription: "Comprehensive SaaS tools for developers and designers with secure API management and premium support.",
    ogImage: "/og/og-default.svg",
    twitterTitle: "BiblioKit Product Features",
    twitterDescription: "Comprehensive SaaS tools for developers and designers with secure API management.",
    twitterImage: "/og/og-default.svg",
    structuredData: [
      {
        "@context": "https://schema.org",
        "@type": "Product",
        "name": "BiblioKit",
        "description": "Professional SaaS software and Figma plugins with secure API management and world-class support.",
        "brand": {
          "@type": "Brand",
          "name": "BiblioKit"
        },
        "category": "Software",
        "offers": {
          "@type": "AggregateOffer",
          "lowPrice": "0",
          "highPrice": "29",
          "priceCurrency": "USD",
          "availability": "https://schema.org/InStock"
        }
      }
    ]
  },
  "/admin": {
    title: "BiblioKit Admin Dashboard - Content Management",
    description: "Manage your BiblioKit content, settings, and configurations through the admin dashboard.",
    keywords: "BiblioKit admin, content management, dashboard, CMS",
    ogTitle: "BiblioKit Admin Dashboard",
    ogDescription: "Manage your BiblioKit content and settings.",
    ogType: "website"
  }
};
function generateMetadata$1(path, contentData, baseUrl = "https://bibliokit.com") {
  var _a, _b, _c, _d;
  const routeData = routeMetadata[path] || {};
  let metadata = { ...defaultMetadata, ...routeData };
  if (contentData) {
    switch (path) {
      case "/":
        if (contentData.hero) {
          metadata.title = contentData.hero.title || metadata.title;
          metadata.description = contentData.hero.subtitle || metadata.description;
          metadata.ogTitle = contentData.hero.title || metadata.ogTitle;
          metadata.ogDescription = contentData.hero.subtitle || metadata.ogDescription;
          metadata.twitterTitle = contentData.hero.title || metadata.twitterTitle;
          metadata.twitterDescription = contentData.hero.subtitle || metadata.twitterDescription;
        }
        break;
      case "/product":
        if ((_a = contentData.features) == null ? void 0 : _a.title) {
          metadata.title = `${contentData.features.title} | BiblioKit`;
        }
        if ((_b = contentData.features) == null ? void 0 : _b.subtitle) {
          metadata.description = contentData.features.subtitle;
        }
        break;
    }
    if (!routeMetadata[path] && path !== "/" && !path.startsWith("/admin")) {
      const slug = String(path).replace(/^\/+/, "").split("/")[0];
      const product = (_c = contentData.products) == null ? void 0 : _c[slug];
      if (product) {
        const productTitle = product.title || metadata.title;
        const productDescription = product.description || metadata.description;
        metadata.title = `${productTitle} | BiblioKit`;
        metadata.description = productDescription;
        metadata.ogTitle = productTitle;
        metadata.ogDescription = productDescription;
        metadata.twitterTitle = productTitle;
        metadata.twitterDescription = productDescription;
        if (product.ogImage && typeof product.ogImage === "string") {
          metadata.ogImage = product.ogImage;
        }
        if (product.twitterImage && typeof product.twitterImage === "string") {
          metadata.twitterImage = product.twitterImage;
        }
        const origin = baseUrl;
        const productUrl = `${origin}/${slug}`;
        const productSchema = {
          "@context": "https://schema.org",
          "@type": "Product",
          name: productTitle,
          description: productDescription,
          brand: { "@type": "Brand", name: "BiblioKit" },
          category: "Software"
        };
        const breadcrumbSchema = {
          "@context": "https://schema.org",
          "@type": "BreadcrumbList",
          itemListElement: [
            { "@type": "ListItem", position: 1, name: "Home", item: origin },
            { "@type": "ListItem", position: 2, name: productTitle, item: productUrl }
          ]
        };
        metadata.structuredData = [...metadata.structuredData || [], productSchema, breadcrumbSchema];
      }
    }
    const twitterHandle = (_d = contentData == null ? void 0 : contentData.contact) == null ? void 0 : _d.twitter;
    if (twitterHandle && typeof twitterHandle === "string") {
      const normalized = twitterHandle.startsWith("@") ? twitterHandle : `@${twitterHandle}`;
      metadata.twitterSite = normalized;
      metadata.twitterCreator = normalized;
    }
    if (!metadata.twitterImageAlt) {
      metadata.twitterImageAlt = metadata.title;
    }
  }
  if (metadata.ogImage && !metadata.ogImage.startsWith("http")) {
    metadata.ogImage = `${baseUrl}${metadata.ogImage}`;
  }
  if (metadata.twitterImage && !metadata.twitterImage.startsWith("http")) {
    metadata.twitterImage = `${baseUrl}${metadata.twitterImage}`;
  }
  if (!metadata.ogImage) {
    metadata.ogImage = `${baseUrl}/og/og-default.svg`;
  }
  if (!metadata.twitterImage) {
    metadata.twitterImage = `${baseUrl}/og/og-default.svg`;
  }
  metadata.canonical = `${baseUrl}${path}`;
  metadata.title = clampText(metadata.title, 60);
  metadata.description = clampText(metadata.description, 160);
  return metadata;
}
function generateMetaTags(metadata) {
  const tags = [];
  tags.push(`<title>${escapeHtml(metadata.title)}</title>`);
  tags.push(`<meta name="description" content="${escapeHtml(metadata.description)}" />`);
  if (metadata.keywords) {
    tags.push(`<meta name="keywords" content="${escapeHtml(metadata.keywords)}" />`);
  }
  if (metadata.canonical) {
    tags.push(`<link rel="canonical" href="${escapeHtml(metadata.canonical)}" />`);
  }
  tags.push(`<meta property="og:title" content="${escapeHtml(metadata.ogTitle || metadata.title)}" />`);
  tags.push(`<meta property="og:description" content="${escapeHtml(metadata.ogDescription || metadata.description)}" />`);
  tags.push(`<meta property="og:type" content="${escapeHtml(metadata.ogType || "website")}" />`);
  tags.push(`<meta property="og:url" content="${escapeHtml(metadata.canonical || "")}" />`);
  if (metadata.siteName) {
    tags.push(`<meta property="og:site_name" content="${escapeHtml(metadata.siteName)}" />`);
  }
  if (metadata.locale) {
    tags.push(`<meta property="og:locale" content="${escapeHtml(metadata.locale)}" />`);
  }
  if (metadata.ogImage) {
    tags.push(`<meta property="og:image" content="${escapeHtml(metadata.ogImage)}" />`);
    if (metadata.ogImageWidth) {
      tags.push(`<meta property="og:image:width" content="${escapeHtml(String(metadata.ogImageWidth))}" />`);
    }
    if (metadata.ogImageHeight) {
      tags.push(`<meta property="og:image:height" content="${escapeHtml(String(metadata.ogImageHeight))}" />`);
    }
  }
  tags.push(`<meta name="twitter:card" content="${escapeHtml(metadata.twitterCard || "summary_large_image")}" />`);
  tags.push(`<meta name="twitter:title" content="${escapeHtml(metadata.twitterTitle || metadata.title)}" />`);
  tags.push(`<meta name="twitter:description" content="${escapeHtml(metadata.twitterDescription || metadata.description)}" />`);
  if (metadata.twitterSite) {
    tags.push(`<meta name="twitter:site" content="${escapeHtml(metadata.twitterSite)}" />`);
  }
  if (metadata.twitterCreator) {
    tags.push(`<meta name="twitter:creator" content="${escapeHtml(metadata.twitterCreator)}" />`);
  }
  if (metadata.twitterImage) {
    tags.push(`<meta name="twitter:image" content="${escapeHtml(metadata.twitterImage)}" />`);
    if (metadata.twitterImageAlt) {
      tags.push(`<meta name="twitter:image:alt" content="${escapeHtml(metadata.twitterImageAlt)}" />`);
    }
  }
  return tags.join("\n    ");
}
function generateStructuredData(metadata) {
  if (!metadata.structuredData || metadata.structuredData.length === 0) {
    return "";
  }
  return metadata.structuredData.map((data) => `<script type="application/ld+json">
${JSON.stringify(data, null, 2)}
<\/script>`).join("\n    ");
}
function escapeHtml(text) {
  const div = typeof document !== "undefined" ? document.createElement("div") : null;
  if (div) {
    div.textContent = text;
    return div.innerHTML;
  }
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function clampText(text, maxLength) {
  if (!text) return text;
  if (text.length <= maxLength) return text;
  const truncated = text.slice(0, Math.max(0, maxLength - 1)).trimEnd();
  return `${truncated}`;
}
function updatePageMetadata(metadata) {
  if (typeof document === "undefined") return;
  document.title = metadata.title;
  const metaSelectors = [
    { selector: 'meta[name="description"]', content: metadata.description },
    { selector: 'meta[name="keywords"]', content: metadata.keywords },
    { selector: 'meta[property="og:title"]', content: metadata.ogTitle || metadata.title },
    { selector: 'meta[property="og:description"]', content: metadata.ogDescription || metadata.description },
    { selector: 'meta[property="og:image"]', content: metadata.ogImage },
    { selector: 'meta[property="og:site_name"]', content: metadata.siteName },
    { selector: 'meta[property="og:locale"]', content: metadata.locale },
    { selector: 'meta[property="og:image:width"]', content: metadata.ogImageWidth ? String(metadata.ogImageWidth) : void 0 },
    { selector: 'meta[property="og:image:height"]', content: metadata.ogImageHeight ? String(metadata.ogImageHeight) : void 0 },
    { selector: 'meta[name="twitter:title"]', content: metadata.twitterTitle || metadata.title },
    { selector: 'meta[name="twitter:description"]', content: metadata.twitterDescription || metadata.description },
    { selector: 'meta[name="twitter:site"]', content: metadata.twitterSite },
    { selector: 'meta[name="twitter:creator"]', content: metadata.twitterCreator },
    { selector: 'meta[name="twitter:image"]', content: metadata.twitterImage },
    { selector: 'meta[name="twitter:image:alt"]', content: metadata.twitterImageAlt }
  ];
  metaSelectors.forEach(({ selector, content }) => {
    if (!content) return;
    let element = document.querySelector(selector);
    if (element) {
      element.content = content;
    } else {
      element = document.createElement("meta");
      const [, attr, value] = selector.match(/\[(.+?)="(.+?)"\]/) || [];
      if (attr && value) {
        element.setAttribute(attr, value);
        element.content = content;
        document.head.appendChild(element);
      }
    }
  });
  if (metadata.canonical) {
    let canonical = document.querySelector('link[rel="canonical"]');
    if (canonical) {
      canonical.href = metadata.canonical;
    } else {
      canonical = document.createElement("link");
      canonical.rel = "canonical";
      canonical.href = metadata.canonical;
      document.head.appendChild(canonical);
    }
  }
}
function useSEO(contentData) {
  const [location2] = typeof window !== "undefined" ? useLocation() : ["/", () => {
  }];
  reactExports.useEffect(() => {
    if (typeof window === "undefined") return;
    const metadata = generateMetadata$1(location2, contentData);
    updatePageMetadata(metadata);
    if (window.history.replaceState) {
      const currentState = window.history.state || {};
      window.history.replaceState(
        { ...currentState, seo: { title: metadata.title, description: metadata.description } },
        "",
        window.location.href
      );
    }
  }, [location2, contentData]);
}
const Docs = () => {
  const { content } = usePublishedContent();
  useSEO(content);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-16", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "mb-10", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-bold mb-3", children: "Documentation" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground max-w-2xl", children: "Quick start and reference for integrating with BiblioKit products and APIs." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { "aria-labelledby": "quickstart-heading", className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { id: "quickstart-heading", className: "text-2xl font-semibold mb-4", children: "Quick start" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "list-decimal list-inside space-y-2 text-muted-foreground", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Pick a product page to learn its capabilities." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Create an API key from your account dashboard." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Call the API using the examples below." })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { "aria-labelledby": "api-example-heading", className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { id: "api-example-heading", className: "text-2xl font-semibold mb-4", children: "API example" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-md border bg-muted/40 p-4 overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "text-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: `curl -X GET \\
  "$BASE_URL/api/status" \\
  -H "Authorization: Bearer $API_KEY"` }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { "aria-labelledby": "resources-heading", className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { id: "resources-heading", className: "text-2xl font-semibold mb-4", children: "Resources" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "list-disc list-inside space-y-2 text-muted-foreground", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "underline hover:text-foreground", href: "/#features", children: "Features" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "underline hover:text-foreground", href: "/#pricing", children: "Pricing" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "underline hover:text-foreground", href: "/#contact", children: "Contact" }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/bibliokit-blocks", children: "Explore Blocks" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, variant: "outline", size: "lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/ai-rename-variants", children: "AI Rename Variants" }) })
    ] })
  ] });
};
function useSchema(schema, elementId) {
  reactExports.useEffect(() => {
    const id2 = elementId || `schema-${Date.now()}`;
    const existing = document.getElementById(id2);
    if (existing) {
      existing.remove();
    }
    const script = document.createElement("script");
    script.type = "application/ld+json";
    script.id = id2;
    script.textContent = JSON.stringify(schema, null, 2);
    document.head.appendChild(script);
    return () => {
      const element = document.getElementById(id2);
      if (element) {
        element.remove();
      }
    };
  }, [schema, elementId]);
}
const createProductSchema = (productData2) => {
  var _a;
  return {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    name: productData2.title,
    description: productData2.description,
    applicationCategory: "DesignApplication",
    operatingSystem: "Web Browser, Figma",
    softwareVersion: "1.0",
    dateModified: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
    author: {
      "@type": "Organization",
      name: "BiblioKit"
    },
    featureList: ((_a = productData2.details) == null ? void 0 : _a.map((detail) => detail.title)) || [],
    aggregateRating: {
      "@type": "AggregateRating",
      ratingValue: "4.8",
      reviewCount: "48000",
      bestRating: "5"
    }
  };
};
const createBreadcrumbSchema = (items) => ({
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  itemListElement: items.map((item, index) => ({
    "@type": "ListItem",
    position: index + 1,
    name: item.name,
    item: item.url
  }))
});
const AnswerBox = ({ content, className = "" }) => {
  const wordCount = content.trim().split(/\s+/).length;
  const isOptimalLength = wordCount >= 40 && wordCount <= 70;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `answer-box bg-gradient-to-r from-blue-50 to-purple-50 border-l-4 border-primary p-6 rounded-lg shadow-sm mb-8 ${className}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-between", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-primary mr-2", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-primary uppercase tracking-wide", children: "Quick Answer" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg leading-relaxed text-gray-800 font-medium", children: content })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-4 text-xs text-gray-500", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `px-2 py-1 rounded ${isOptimalLength ? "bg-green-100 text-green-700" : "bg-yellow-100 text-yellow-700"}`, children: [
      wordCount,
      " words"
    ] }) })
  ] }) });
};
const ExpertQuote = ({
  quote,
  expertName,
  expertTitle,
  institution,
  className = ""
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `expert-quote bg-white border border-gray-200 rounded-lg p-6 shadow-sm mb-6 ${className}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0 mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-8 h-8 text-gray-400", fill: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14,17H17L19,13V7H13V13H16M6,17H9L11,13V7H5V13H8L6,17Z" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("blockquote", { className: "text-lg text-gray-800 italic mb-4 leading-relaxed", children: [
        '"',
        quote,
        '"'
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center text-sm text-gray-600", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-10 h-10 bg-gradient-to-br from-blue-400 to-purple-600 rounded-full flex items-center justify-center text-white font-semibold mr-3", children: expertName.split(" ").map((n) => n[0]).join("").slice(0, 2) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-semibold text-gray-900", children: expertName }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-600", children: expertTitle }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 text-xs", children: institution })
        ] })
      ] })
    ] })
  ] }) });
};
const StatBox = ({
  statistic,
  description,
  source,
  date,
  className = ""
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `stat-box bg-gradient-to-br from-green-50 to-blue-50 border border-green-200 rounded-lg p-6 text-center shadow-sm mb-6 ${className}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center mb-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6 text-green-600 mr-2", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", d: "M3 3a1 1 0 000 2v8a2 2 0 002 2h2.586l-1.293 1.293a1 1 0 101.414 1.414L10 15.414l2.293 2.293a1 1 0 001.414-1.414L12.414 15H15a2 2 0 002-2V5a1 1 0 100-2H3zm11.707 4.707a1 1 0 00-1.414-1.414L10 9.586 8.707 8.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z", clipRule: "evenodd" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-green-700 uppercase tracking-wide", children: "Key Statistic" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-4xl font-bold text-green-800 mb-2", children: statistic }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-700 mb-4 leading-relaxed", children: description }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-gray-500 border-t border-green-200 pt-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium text-gray-600", children: source }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 mt-1", children: date })
    ] })
  ] });
};
const ContentChunk = ({
  children,
  autoH2Break = true,
  className = ""
}) => {
  const [tokenCount, setTokenCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const content = React.Children.toArray(children).join("").toString();
    const estimatedTokens = Math.ceil(content.length / 4);
    setTokenCount(estimatedTokens);
  }, [children]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `content-chunk ${className}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "prose prose-lg max-w-none", children }),
    autoH2Break && tokenCount > 200 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h2-break-suggestion mt-8 mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-px bg-gradient-to-r from-transparent via-gray-300 to-transparent" }) })
  ] });
};
const FAQSchema = ({ faqs, className = "" }) => {
  const faqSchema = {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    mainEntity: faqs.map((faq) => ({
      "@type": "Question",
      name: faq.question,
      acceptedAnswer: {
        "@type": "Answer",
        text: faq.answer
      }
    }))
  };
  useSchema(faqSchema, "faq-schema");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `faq-schema ${className}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold mb-4", children: "Frequently Asked Questions" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-muted-foreground", children: "Quick answers to common questions about our AI-powered tools" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-6", children: faqs.map((faq, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "faq-item bg-white border border-gray-200 rounded-lg p-6 shadow-sm", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "text-lg font-semibold text-gray-900 mb-3 flex items-start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-6 h-6 bg-primary/10 text-primary rounded-full flex items-center justify-center text-sm font-bold mr-3 mt-0.5 flex-shrink-0", children: "Q" }),
        faq.question
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-9", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-6 h-6 bg-green-100 text-green-700 rounded-full flex items-center justify-center text-sm font-bold mr-3 flex-shrink-0", children: "A" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-700 leading-relaxed", children: faq.answer })
      ] }) })
    ] }, index)) })
  ] }) });
};
const SPEC_ICON_FALLBACKS = [
  "",
  // analytics / data
  "",
  // integration / linking
  "",
  // growth / metrics
  "",
  // team / collaboration
  "",
  // export / reports
  "",
  // security / reliability
  "",
  // settings / configuration
  "",
  // modularity / components
  "",
  // tools
  ""
  // performance / launch
];
const getSpecIconFallback = (index) => {
  const safeIndex = Number.isFinite(index) ? Math.abs(index) : 0;
  return SPEC_ICON_FALLBACKS[safeIndex % SPEC_ICON_FALLBACKS.length];
};
const DEFAULT_SPECIFICATIONS_TITLE = " Technical Capabilities";
const ProductContentSections = ({
  product,
  faqs,
  detailsOverride,
  benefitsOverride,
  sectionOverrides
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q;
  const colorClasses = ["icon-purple", "icon-blue", "icon-green", "icon-orange", "icon-pink", "icon-indigo"];
  const expertQuote = {
    quote: ((_b = (_a = product == null ? void 0 : product.llm) == null ? void 0 : _a.expertQuote) == null ? void 0 : _b.quote) || "",
    expertName: ((_d = (_c = product == null ? void 0 : product.llm) == null ? void 0 : _c.expertQuote) == null ? void 0 : _d.expertName) || "",
    expertTitle: ((_f = (_e = product == null ? void 0 : product.llm) == null ? void 0 : _e.expertQuote) == null ? void 0 : _f.expertTitle) || "",
    institution: ((_h = (_g = product == null ? void 0 : product.llm) == null ? void 0 : _g.expertQuote) == null ? void 0 : _h.institution) || ""
  };
  const hasExpertQuote = Boolean(expertQuote.quote);
  const statistic = {
    statistic: ((_j = (_i = product == null ? void 0 : product.llm) == null ? void 0 : _i.statistic) == null ? void 0 : _j.statistic) || "",
    description: ((_l = (_k = product == null ? void 0 : product.llm) == null ? void 0 : _k.statistic) == null ? void 0 : _l.description) || "",
    source: ((_n = (_m = product == null ? void 0 : product.llm) == null ? void 0 : _m.statistic) == null ? void 0 : _n.source) || "",
    date: ((_p = (_o = product == null ? void 0 : product.llm) == null ? void 0 : _o.statistic) == null ? void 0 : _p.date) || ""
  };
  const hasStatistic = Boolean(statistic.statistic || statistic.description);
  const details = detailsOverride && detailsOverride.length > 0 ? detailsOverride : product.details;
  const benefits = benefitsOverride && benefitsOverride.length > 0 ? benefitsOverride : product.benefits;
  const featuresTitle = (sectionOverrides == null ? void 0 : sectionOverrides.featuresTitle) || ((_r = (_q = product == null ? void 0 : product.sections) == null ? void 0 : _q.features) == null ? void 0 : _r.title) || " Key Features";
  const featuresDescription = (sectionOverrides == null ? void 0 : sectionOverrides.featuresDescription) || ((_t = (_s = product == null ? void 0 : product.sections) == null ? void 0 : _s.features) == null ? void 0 : _t.description) || "Comprehensive design system analytics platform with automated Figma integration and ROI tracking";
  const useCasesTitle = (sectionOverrides == null ? void 0 : sectionOverrides.useCasesTitle) || ((_v = (_u = product == null ? void 0 : product.sections) == null ? void 0 : _u.useCases) == null ? void 0 : _v.title) || " Use Cases";
  const useCasesDescription = (sectionOverrides == null ? void 0 : sectionOverrides.useCasesDescription) || ((_x = (_w = product == null ? void 0 : product.sections) == null ? void 0 : _w.useCases) == null ? void 0 : _x.description) || "Perfect for product teams seeking data-driven design system optimization and ROI measurement";
  const specsTitle = (sectionOverrides == null ? void 0 : sectionOverrides.specsTitle) || ((_z = (_y = product == null ? void 0 : product.sections) == null ? void 0 : _y.specifications) == null ? void 0 : _z.title) || DEFAULT_SPECIFICATIONS_TITLE;
  const specsDescription = (sectionOverrides == null ? void 0 : sectionOverrides.specsDescription) || ((_B = (_A = product == null ? void 0 : product.sections) == null ? void 0 : _A.specifications) == null ? void 0 : _B.description) || "Built with powerful features for professional design workflows";
  const sanitizeColumns = (value, fallback) => {
    const parsed = typeof value === "string" ? parseInt(value, 10) : value;
    if (Number.isNaN(parsed)) return fallback;
    return Math.min(4, Math.max(1, parsed));
  };
  const useCasesColumns = sanitizeColumns((_D = (_C = product == null ? void 0 : product.sections) == null ? void 0 : _C.useCases) == null ? void 0 : _D.columns, 2);
  const featuresColumns = sanitizeColumns((_F = (_E = product == null ? void 0 : product.sections) == null ? void 0 : _E.features) == null ? void 0 : _F.columns, Math.min((details == null ? void 0 : details.length) || 1, 4));
  const specsColumns = sanitizeColumns((_H = (_G = product == null ? void 0 : product.sections) == null ? void 0 : _G.specifications) == null ? void 0 : _H.columns, Math.min(((_I = product == null ? void 0 : product.specifications) == null ? void 0 : _I.length) || 1, 4));
  reactExports.useEffect(() => {
    var _a2;
    try {
      debugService.info("ProductContentSections: computed grid settings", {
        featuresColumns,
        detailsCount: (details == null ? void 0 : details.length) || 0,
        useCasesColumns,
        benefitsCount: (benefits == null ? void 0 : benefits.length) || 0,
        specsColumns,
        specsCount: ((_a2 = product == null ? void 0 : product.specifications) == null ? void 0 : _a2.length) || 0
      });
    } catch {
    }
  }, [featuresColumns, details, useCasesColumns, benefits, specsColumns, product == null ? void 0 : product.specifications]);
  const getGridClassesForColumns = (cols) => {
    switch (cols) {
      case 1:
        return "grid grid-cols-1 md:grid-cols-1 lg:grid-cols-1 gap-8";
      case 2:
        return "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-8";
      case 3:
        return "grid grid-cols-1 md:grid-cols-3 lg:grid-cols-3 gap-8";
      case 4:
      default:
        return "grid grid-cols-1 md:grid-cols-4 lg:grid-cols-4 gap-8";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    hasExpertQuote && ((_J = product == null ? void 0 : product.visibility) == null ? void 0 : _J.expertQuote) !== false && /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-12 px-4 bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto max-w-4xl", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpertQuote, { ...expertQuote }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8" }),
    hasStatistic && ((_K = product == null ? void 0 : product.visibility) == null ? void 0 : _K.statistic) !== false && /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-8 px-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatBox, { ...statistic }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8" }),
    details && details.length > 0 && ((_L = product == null ? void 0 : product.visibility) == null ? void 0 : _L.features) !== false && /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-20 px-4 section-background", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContentChunk, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold mb-4", children: featuresTitle }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-muted-foreground max-w-2xl mx-auto", children: featuresDescription })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn$1(getGridClassesForColumns(featuresColumns)), children: details.map((detail, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(ContentChunk, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card relative", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `icon ${colorClasses[index % colorClasses.length]} mb-6`, children: ["", "", "", "", ""][index] || "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-semibold mb-3", children: detail.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: detail.description })
      ] }) }, index)) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8" }),
    benefits && benefits.length > 0 && ((_M = product == null ? void 0 : product.visibility) == null ? void 0 : _M.benefits) !== false && /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-20 px-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContentChunk, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold mb-6", children: useCasesTitle }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-muted-foreground max-w-2xl mx-auto", children: useCasesDescription })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn$1(getGridClassesForColumns(useCasesColumns), "max-w-4xl mx-auto"), children: benefits.map((benefit, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(ContentChunk, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center mr-4 mt-0.5 flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5 text-primary", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fillRule: "evenodd",
            d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
            clipRule: "evenodd"
          }
        ) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-lg", children: benefit })
      ] }) }, index)) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8" }),
    product.specifications && product.specifications.length > 0 && ((_N = product == null ? void 0 : product.visibility) == null ? void 0 : _N.specifications) !== false && /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-20 px-4 section-background", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContentChunk, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold mb-6", children: specsTitle }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-muted-foreground max-w-2xl mx-auto", children: specsDescription })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn$1(getGridClassesForColumns(specsColumns)), children: product.specifications.map((spec, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(ContentChunk, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card relative", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `icon ${colorClasses[index % colorClasses.length]} mb-6`, children: spec.icon || getSpecIconFallback(index) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-semibold mb-3", children: spec.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: spec.value })
      ] }) }, index)) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8" }),
    ((_O = product == null ? void 0 : product.visibility) == null ? void 0 : _O.faqs) !== false && /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-20 px-4 bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FAQSchema, { faqs }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8" }),
    ((_P = product == null ? void 0 : product.visibility) == null ? void 0 : _P.waitlist) !== false && /* @__PURE__ */ jsxRuntimeExports.jsx(Waitlist, { visibleOverride: (_Q = product == null ? void 0 : product.visibility) == null ? void 0 : _Q.waitlist })
  ] });
};
const components = [
  { id: "search", type: "input", x: 50, y: 100, width: 300, height: 40, delay: 0 },
  { id: "profile", type: "avatar", x: 400, y: 80, width: 60, height: 60, delay: 0.3 },
  { id: "nav-card", type: "card", x: 50, y: 200, width: 200, height: 120, delay: 0.6 },
  { id: "main-card", type: "card", x: 300, y: 180, width: 350, height: 200, delay: 0.9 },
  { id: "sidebar", type: "card", x: 700, y: 100, width: 180, height: 300, delay: 1.2 },
  { id: "button-1", type: "button", x: 50, y: 350, width: 100, height: 35, delay: 1.5 },
  { id: "button-2", type: "button", x: 170, y: 350, width: 100, height: 35, delay: 1.8 },
  { id: "form", type: "form", x: 300, y: 420, width: 250, height: 150, delay: 2.1 },
  { id: "table", type: "table", x: 50, y: 450, width: 200, height: 100, delay: 2.4 },
  { id: "icon-1", type: "icon", x: 600, y: 450, width: 30, height: 30, delay: 2.7 },
  { id: "icon-2", type: "icon", x: 650, y: 450, width: 30, height: 30, delay: 3 },
  { id: "icon-3", type: "icon", x: 700, y: 450, width: 30, height: 30, delay: 3.3 }
];
const floatingIcons = [
  { Icon: Search, x: 100, y: 50 },
  { Icon: User, x: 800, y: 150 },
  { Icon: Settings, x: 150, y: 600 },
  { Icon: Bell, x: 750, y: 500 },
  { Icon: Mail, x: 900, y: 300 },
  { Icon: Calendar, x: 50, y: 550 },
  { Icon: FileText, x: 850, y: 80 },
  { Icon: Image, x: 200, y: 400 },
  { Icon: Video, x: 600, y: 200 },
  { Icon: Music, x: 500, y: 550 }
];
const heroPalette = ["#98fb98", "#dda0dd", "#87ceeb"];
const cycleFrom = (start) => [
  heroPalette[start % heroPalette.length],
  heroPalette[(start + 1) % heroPalette.length],
  heroPalette[(start + 2) % heroPalette.length]
];
const translucent = (hex, alphaHex = "66") => {
  if (!hex) return `#ffffff${alphaHex}`;
  return hex.length === 7 ? `${hex}${alphaHex}` : hex;
};
const renderComponent = (component, colorIndex = 0) => {
  const baseClasses = "absolute border-2 border-white/60 bg-transparent";
  const slowTransition = {
    delay: component.delay,
    duration: 6,
    repeat: Infinity,
    ease: "easeInOut"
  };
  switch (component.type) {
    case "input":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          className: `${baseClasses} rounded-md`,
          style: { left: component.x, top: component.y, width: component.width, height: component.height },
          initial: { opacity: 0, scale: 0.9 },
          animate: {
            opacity: [0.15, 0.45, 0.15],
            scale: [0.95, 1.02, 0.95],
            borderColor: cycleFrom(colorIndex)
          },
          transition: slowTransition,
          "aria-hidden": "true",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 border rounded-full", style: { borderColor: translucent(heroPalette[colorIndex % heroPalette.length]) } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-10 top-1/2 transform -translate-y-1/2 w-20 h-2 rounded", style: { backgroundColor: translucent(heroPalette[(colorIndex + 1) % heroPalette.length]) } })
          ]
        },
        component.id
      );
    case "avatar":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: `${baseClasses} rounded-full`,
          style: { left: component.x, top: component.y, width: component.width, height: component.height },
          initial: { opacity: 0, scale: 0.9 },
          animate: {
            opacity: [0.15, 0.45, 0.15],
            scale: [0.95, 1.06, 0.95],
            borderColor: cycleFrom(colorIndex)
          },
          transition: slowTransition,
          "aria-hidden": "true",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-2 border rounded-full", style: { borderColor: translucent(heroPalette[(colorIndex + 1) % heroPalette.length]) } })
        },
        component.id
      );
    case "card":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: `${baseClasses} rounded-lg`,
          style: { left: component.x, top: component.y, width: component.width, height: component.height },
          initial: { opacity: 0, scale: 0.9 },
          animate: {
            opacity: [0.15, 0.45, 0.15],
            scale: [0.96, 1.02, 0.96],
            borderColor: cycleFrom(colorIndex)
          },
          transition: slowTransition,
          "aria-hidden": "true",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/4 h-3 rounded", style: { backgroundColor: translucent(heroPalette[colorIndex % heroPalette.length]) } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/2 h-2 rounded", style: { backgroundColor: translucent(heroPalette[(colorIndex + 1) % heroPalette.length]) } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-2 rounded", style: { backgroundColor: translucent(heroPalette[(colorIndex + 2) % heroPalette.length]) } })
          ] })
        },
        component.id
      );
    case "button":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: `${baseClasses} rounded`,
          style: { left: component.x, top: component.y, width: component.width, height: component.height },
          initial: { opacity: 0, scale: 0.95 },
          animate: {
            opacity: [0.15, 0.45, 0.15],
            scale: [0.98, 1.03, 0.98],
            borderColor: cycleFrom(colorIndex)
          },
          transition: slowTransition,
          "aria-hidden": "true",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 h-2 rounded", style: { backgroundColor: translucent(heroPalette[(colorIndex + 1) % heroPalette.length]) } }) })
        },
        component.id
      );
    case "form":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: `${baseClasses} rounded-lg`,
          style: { left: component.x, top: component.y, width: component.width, height: component.height },
          initial: { opacity: 0, scale: 0.9 },
          animate: {
            opacity: [0.15, 0.45, 0.15],
            scale: [0.96, 1.02, 0.96],
            borderColor: cycleFrom(colorIndex)
          },
          transition: slowTransition,
          "aria-hidden": "true",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 space-y-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-6 border rounded", style: { borderColor: translucent(heroPalette[colorIndex % heroPalette.length]) } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-6 border rounded", style: { borderColor: translucent(heroPalette[(colorIndex + 1) % heroPalette.length]) } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-20 h-6 border rounded", style: { borderColor: translucent(heroPalette[(colorIndex + 2) % heroPalette.length]) } })
          ] })
        },
        component.id
      );
    case "table":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: `${baseClasses} rounded`,
          style: { left: component.x, top: component.y, width: component.width, height: component.height },
          initial: { opacity: 0, scale: 0.9 },
          animate: {
            opacity: [0.15, 0.45, 0.15],
            scale: [0.96, 1.02, 0.96],
            borderColor: cycleFrom(colorIndex)
          },
          transition: slowTransition,
          "aria-hidden": "true",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-2 space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/3 h-2 rounded", style: { backgroundColor: translucent(heroPalette[colorIndex % heroPalette.length]) } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/3 h-2 rounded", style: { backgroundColor: translucent(heroPalette[(colorIndex + 1) % heroPalette.length]) } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/3 h-2 rounded", style: { backgroundColor: translucent(heroPalette[(colorIndex + 2) % heroPalette.length]) } })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/3 h-2 rounded", style: { backgroundColor: translucent(heroPalette[(colorIndex + 1) % heroPalette.length]) } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/3 h-2 rounded", style: { backgroundColor: translucent(heroPalette[(colorIndex + 2) % heroPalette.length]) } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1/3 h-2 rounded", style: { backgroundColor: translucent(heroPalette[colorIndex % heroPalette.length]) } })
            ] })
          ] })
        },
        component.id
      );
    case "icon":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: `${baseClasses} rounded`,
          style: { left: component.x, top: component.y, width: component.width, height: component.height },
          initial: { opacity: 0, scale: 0.9 },
          animate: {
            opacity: [0.15, 0.45, 0.15],
            scale: [0.95, 1.08, 0.95],
            borderColor: cycleFrom(colorIndex),
            rotate: [0, 120, 240, 360]
          },
          transition: slowTransition,
          "aria-hidden": "true",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-full border rounded", style: { borderColor: translucent(heroPalette[(colorIndex + 2) % heroPalette.length]) } })
        },
        component.id
      );
    default:
      return null;
  }
};
const BlocksHeroBackground = ({ className, emoji, emojiX, emojiY, minEmojiViewportTop }) => {
  const designWidth = 1e3;
  const designHeight = 700;
  const containerRef = React.useRef(null);
  const [scale, setScale] = React.useState(1);
  React.useEffect(() => {
    const updateScale = () => {
      const el = containerRef.current;
      if (!el) return;
      const { clientWidth, clientHeight } = el;
      if (!clientWidth || !clientHeight) return;
      const widthScale = clientWidth / designWidth;
      const heightScale = clientHeight / designHeight;
      setScale(Math.min(widthScale, heightScale));
    };
    updateScale();
    let ro = null;
    if (typeof ResizeObserver !== "undefined") {
      ro = new ResizeObserver(updateScale);
      if (containerRef.current) ro.observe(containerRef.current);
    } else {
      window.addEventListener("resize", updateScale);
    }
    return () => {
      if (ro && containerRef.current) ro.unobserve(containerRef.current);
      window.removeEventListener("resize", updateScale);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: containerRef, className: `absolute inset-0 pointer-events-none ${className || ""}`, "aria-hidden": "true", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute inset-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-br from-emerald-100/40 via-purple-100/35 to-sky-100/40" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-tr from-emerald-50/30 via-purple-50/25 to-sky-50/30" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "absolute",
        style: {
          left: "50%",
          top: "50%",
          width: `${designWidth}px`,
          height: `${designHeight}px`,
          transform: `translate(-50%, -50%) scale(${scale})`,
          transformOrigin: "center",
          willChange: "transform"
        },
        children: [
          emoji && /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute select-none",
              style: {
                left: `${typeof emojiX === "number" ? emojiX : designWidth / 2}px`,
                top: (() => {
                  const baseY = typeof emojiY === "number" ? emojiY : 110;
                  if (typeof minEmojiViewportTop === "number" && scale > 0) {
                    const minCanvasY = minEmojiViewportTop / scale;
                    return `${Math.max(baseY, minCanvasY)}px`;
                  }
                  return `${baseY}px`;
                })(),
                transform: "translate(-50%, -50%)"
              },
              initial: { opacity: 0, y: -8, scale: 0.95 },
              animate: { opacity: 1, y: 0, scale: 1 },
              transition: { duration: 0.6, ease: "easeOut" },
              "aria-hidden": "true",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 56, lineHeight: "56px" }, children: emoji })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0", children: components.map((component, index) => renderComponent(component, index)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0", children: floatingIcons.map(({ Icon, x, y }, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute",
              style: { left: x, top: y, color: translucent(heroPalette[index % heroPalette.length], "99") },
              initial: { opacity: 0, scale: 0 },
              animate: {
                opacity: [0, 0.35, 0.2, 0.35],
                scale: [0, 1.05, 0.9, 1.05],
                rotate: [0, 360],
                x: [0, Math.sin(index) * 14, 0],
                y: [0, Math.cos(index) * 10, 0]
              },
              transition: {
                delay: index * 0.4,
                duration: 7,
                repeat: Infinity,
                ease: "easeInOut"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: 20 })
            },
            `floating-${index}`
          )) })
        ]
      }
    )
  ] });
};
const DynamicProductPage = ({ slug }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
  const { content, loading } = usePublishedContent();
  const { isAuthenticated, isAdmin } = useAuth();
  reactExports.useEffect(() => {
    debugService.info("DynamicProductPage mounted", {
      slug,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }, [slug]);
  const product = (_a = content.products) == null ? void 0 : _a[slug];
  reactExports.useEffect(() => {
    try {
      const keys = Object.keys((content == null ? void 0 : content.products) || {});
      console.log("DynamicProductPage content.products keys:", keys);
    } catch {
    }
  }, [content]);
  reactExports.useEffect(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2;
    try {
      debugService.info("DynamicProductPage sections visibility", {
        hasExpertQuote: Boolean((_b2 = (_a2 = product == null ? void 0 : product.llm) == null ? void 0 : _a2.expertQuote) == null ? void 0 : _b2.quote),
        hasStatistic: Boolean(((_d2 = (_c2 = product == null ? void 0 : product.llm) == null ? void 0 : _c2.statistic) == null ? void 0 : _d2.statistic) || ((_f2 = (_e2 = product == null ? void 0 : product.llm) == null ? void 0 : _e2.statistic) == null ? void 0 : _f2.description)),
        hasFaqs: Array.isArray((_g2 = product == null ? void 0 : product.llm) == null ? void 0 : _g2.faqs) && (((_i2 = (_h2 = product == null ? void 0 : product.llm) == null ? void 0 : _h2.faqs) == null ? void 0 : _i2.length) || 0) > 0,
        hasDetails: Array.isArray(product == null ? void 0 : product.details) && (((_j2 = product == null ? void 0 : product.details) == null ? void 0 : _j2.length) || 0) > 0,
        hasSpecifications: Array.isArray(product == null ? void 0 : product.specifications) && (((_k2 = product == null ? void 0 : product.specifications) == null ? void 0 : _k2.length) || 0) > 0
      });
    } catch {
    }
  }, [product]);
  reactExports.useEffect(() => {
    if (product) {
      const path = `/${slug}`;
      const baseUrl = typeof window !== "undefined" ? `${window.location.protocol}//${window.location.host}` : "https://bibliokit.com";
      const metadata = generateMetadata$1(path, content, baseUrl);
      updatePageMetadata(metadata);
    }
  }, [product, slug, content]);
  const productSchema = product ? createProductSchema(product) : {
    "@context": "https://schema.org",
    "@type": "WebPage",
    name: "Product",
    description: "BiblioKit Product Page"
  };
  const origin = typeof window !== "undefined" ? window.location.origin : "https://bibliokit.com";
  const href = typeof window !== "undefined" ? window.location.href : `${origin}/${slug}`;
  const breadcrumbSchema = createBreadcrumbSchema([
    { name: "Home", url: origin },
    { name: "Product", url: href }
  ]);
  useSchema(productSchema, `product-schema-${slug}`);
  useSchema(breadcrumbSchema, `breadcrumb-schema-${slug}`);
  const fallbackAnswerBox = "BiblioKit provides professional-grade software and plugins designed to help teams ship faster with best-in-class UX.";
  const answerBoxContent = ((_b = product == null ? void 0 : product.llm) == null ? void 0 : _b.answerBox) || fallbackAnswerBox;
  const expertQuote = {
    quote: ((_d = (_c = product == null ? void 0 : product.llm) == null ? void 0 : _c.expertQuote) == null ? void 0 : _d.quote) || "High-quality design systems drive faster delivery and better UX outcomes.",
    expertName: ((_f = (_e = product == null ? void 0 : product.llm) == null ? void 0 : _e.expertQuote) == null ? void 0 : _f.expertName) || "Design Ops Team",
    expertTitle: ((_h = (_g = product == null ? void 0 : product.llm) == null ? void 0 : _g.expertQuote) == null ? void 0 : _h.expertTitle) || "Best Practices",
    institution: ((_j = (_i = product == null ? void 0 : product.llm) == null ? void 0 : _i.expertQuote) == null ? void 0 : _j.institution) || "BiblioKit"
  };
  const statistic = {
    statistic: ((_l = (_k = product == null ? void 0 : product.llm) == null ? void 0 : _k.statistic) == null ? void 0 : _l.statistic) || "90%",
    description: ((_n = (_m = product == null ? void 0 : product.llm) == null ? void 0 : _m.statistic) == null ? void 0 : _n.description) || "of teams ship features faster with a strong design system",
    source: ((_p = (_o = product == null ? void 0 : product.llm) == null ? void 0 : _o.statistic) == null ? void 0 : _p.source) || "Internal study",
    date: ((_r = (_q = product == null ? void 0 : product.llm) == null ? void 0 : _q.statistic) == null ? void 0 : _r.date) || "2024"
  };
  const faqs = ((_s = product == null ? void 0 : product.llm) == null ? void 0 : _s.faqs) || [
    {
      question: "What is this product?",
      answer: "A professional tool crafted by BiblioKit to improve design system workflows and accelerate delivery."
    },
    {
      question: "How do I get started?",
      answer: "Use the primary call-to-action to try the product or contact us for a demo."
    }
  ];
  if (!product) {
    if (loading) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto px-4 py-20", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "animate-pulse space-y-6 max-w-3xl mx-auto", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-6 bg-gray-200 rounded w-40" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-10 bg-gray-200 rounded w-2/3" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 bg-gray-200 rounded w-full" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 bg-gray-200 rounded w-11/12" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-10 bg-gray-200 rounded w-48" })
      ] }) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto px-4 py-16", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-bold mb-4", children: "Product Not Found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: "We couldnt find this product. Check the URL or pick another page." })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "section-hero relative overflow-hidden py-28 md:py-32 px-4 min-h-screen flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BlocksHeroBackground, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        AnimatedGradientBackground,
        {
          Breathing: true,
          startingGap: 118,
          topOffset: -20,
          gradientColors: (product == null ? void 0 : product.gradientColors) && Array.isArray(product.gradientColors) && product.gradientColors.length > 0 ? product.gradientColors : ["#ecfeff00", "#ecfeff10", "#c7d2fe40", "#a7f3d040", "#a5b4fc50", "#93c5fd40", "#ffffff00"],
          gradientStops: [18, 44, 58, 70, 82, 90, 100],
          containerClassName: "pointer-events-none"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto text-center relative z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-4xl mx-auto", children: [
        (product == null ? void 0 : product.badgeLabel) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center gap-2 mb-6 px-4 py-2 rounded-full border border-primary/20 bg-white/70 backdrop-blur supports-[backdrop-filter]:bg-white/50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-flex h-2 w-2 rounded-full bg-primary" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-gray-800", children: product.badgeLabel })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-5xl md:text-6xl font-bold mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-900", children: product.title }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnswerBox, { content: answerBoxContent, className: "bg-white/95 text-gray-800 border-gray-200 shadow-lg" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-700 mb-8 max-w-3xl mx-auto", children: product.description }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row gap-4 justify-center", children: [
          product.primaryButtonLink ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "lg", className: "w-full sm:w-auto min-w-[12rem]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: product.primaryButtonLink,
              target: "_blank",
              rel: "noopener noreferrer",
              children: product.primaryButton || "Get Started"
            }
          ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "lg", className: "w-full sm:w-auto min-w-[12rem]", children: product.primaryButton || "Get Started" }),
          product.secondaryButtonLink ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "lg", variant: "outline", className: "w-full sm:w-auto min-w-[12rem]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: product.secondaryButtonLink,
              className: "inline-block text-center",
              target: product.secondaryButtonLink.startsWith("http") ? "_blank" : "_self",
              rel: product.secondaryButtonLink.startsWith("http") ? "noopener noreferrer" : void 0,
              children: product.secondaryButton || "Learn More"
            }
          ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "lg", variant: "outline", className: "w-full sm:w-auto min-w-[12rem]", children: product.secondaryButton || "Learn More" })
        ] })
      ] }) })
    ] }),
    ((_u = (_t = product == null ? void 0 : product.llm) == null ? void 0 : _t.expertQuote) == null ? void 0 : _u.quote) && /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-12 px-4 bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto max-w-4xl", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpertQuote, { ...expertQuote }) }) }),
    (((_w = (_v = product == null ? void 0 : product.llm) == null ? void 0 : _v.statistic) == null ? void 0 : _w.statistic) || ((_y = (_x = product == null ? void 0 : product.llm) == null ? void 0 : _x.statistic) == null ? void 0 : _y.description)) && /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "py-8 px-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatBox, { ...statistic }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ProductContentSections, { product, faqs })
  ] });
};
function MagnetizeButton({
  className,
  particleCount = 12,
  attractRadius = 50,
  children,
  href,
  target,
  rel,
  ...props
}) {
  const [isAttracting, setIsAttracting] = reactExports.useState(false);
  const [particles, setParticles] = reactExports.useState([]);
  const particlesControl = useAnimation();
  reactExports.useEffect(() => {
    const newParticles = Array.from({ length: particleCount }, (_, i) => ({
      id: i,
      x: Math.random() * 360 - 180,
      y: Math.random() * 360 - 180
    }));
    setParticles(newParticles);
  }, [particleCount]);
  const handleInteractionStart = reactExports.useCallback(async () => {
    setIsAttracting(true);
    await particlesControl.start({
      x: 0,
      y: 0,
      transition: {
        type: "spring",
        stiffness: 50,
        damping: 10
      }
    });
  }, [particlesControl]);
  const handleInteractionEnd = reactExports.useCallback(async () => {
    setIsAttracting(false);
    await particlesControl.start((i) => ({
      x: particles[i].x,
      y: particles[i].y,
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 15
      }
    }));
  }, [particlesControl, particles]);
  const isLink = typeof href === "string" && href.length > 0;
  if (isLink) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button$1,
      {
        asChild: true,
        className: cn$1("relative touch-none transition-all duration-300", className),
        onMouseEnter: handleInteractionStart,
        onMouseLeave: handleInteractionEnd,
        onTouchStart: handleInteractionStart,
        onTouchEnd: handleInteractionEnd,
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href, target, rel, children: [
          particles.map((_, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              custom: index,
              initial: { x: particles[index].x, y: particles[index].y },
              animate: particlesControl,
              className: cn$1(
                "absolute w-1.5 h-1.5 rounded-full",
                "bg-violet-400 dark:bg-violet-300",
                "transition-opacity duration-300",
                isAttracting ? "opacity-100" : "opacity-40"
              )
            },
            index
          )),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "relative w-full flex items-center justify-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Star,
              {
                className: cn$1(
                  "w-4 h-4 transition-transform duration-300",
                  isAttracting && "scale-110"
                )
              }
            ),
            children
          ] })
        ] })
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Button$1,
    {
      className: cn$1("relative touch-none transition-all duration-300", className),
      onMouseEnter: handleInteractionStart,
      onMouseLeave: handleInteractionEnd,
      onTouchStart: handleInteractionStart,
      onTouchEnd: handleInteractionEnd,
      ...props,
      children: [
        particles.map((_, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            custom: index,
            initial: { x: particles[index].x, y: particles[index].y },
            animate: particlesControl,
            className: cn$1(
              "absolute w-1.5 h-1.5 rounded-full",
              "bg-violet-400 dark:bg-violet-300",
              "transition-opacity duration-300",
              isAttracting ? "opacity-100" : "opacity-40"
            )
          },
          index
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "relative w-full flex items-center justify-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Star,
            {
              className: cn$1(
                "w-4 h-4 transition-transform duration-300",
                isAttracting && "scale-110"
              )
            }
          ),
          children
        ] })
      ]
    }
  );
}
const Swatch = ({ name, className, textClass, hex }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `h-8 w-8 rounded-md border ${className}` }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-sm font-medium ${textClass || "text-foreground"}`, children: name }),
    hex && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-muted-foreground font-mono", children: hex })
  ] })
] });
const TextSwatch = ({ name, textClass }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-8 w-8 rounded-md border bg-background flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-base leading-none ${textClass}`, children: "Aa" }) }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-foreground", children: name })
] });
const BorderSwatch = ({ name, borderClass }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `h-8 w-8 rounded-md bg-background border ${borderClass}` }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-foreground", children: name })
] });
const DesignSystem = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-16", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-10", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-bold", children: "Design System" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: "BiblioKit UI tokens and components (pink, blue, green)." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold mb-4", children: "Colors" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid sm:grid-cols-2 lg:grid-cols-3 gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "Brand Colors" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "pink-500", className: "bg-pink-500", hex: "#ec4899" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "blue-500", className: "bg-blue-500", hex: "#3b82f6" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "green-500", className: "bg-green-500", hex: "#22c55e" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "pink-50", className: "bg-pink-50", hex: "#fdf2f8" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "blue-50", className: "bg-blue-50", hex: "#eff6ff" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "green-50", className: "bg-green-50", hex: "#f0fdf4" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "Primary (Pink)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "primary", className: "bg-pink-500", hex: "#ec4899" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "primary-foreground", className: "bg-pink-500", textClass: "text-white", hex: "#fdf2f8" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "ring", className: "bg-pink-400", hex: "#f472b6" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "Accent (Blue)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "accent", className: "bg-blue-500", hex: "#3b82f6" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "accent-foreground", className: "bg-blue-500", textClass: "text-white", hex: "#eff6ff" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "Success (Green)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "success", className: "bg-green-500", hex: "#22c55e" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "success soft", className: "bg-green-100", hex: "#dcfce7" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "Neutrals (Gray)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "gray-50", className: "bg-gray-50", hex: "#f9fafb" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "gray-100", className: "bg-gray-100", hex: "#f3f4f6" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "gray-200", className: "bg-gray-200", hex: "#e5e7eb" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "gray-300", className: "bg-gray-300", hex: "#d1d5db" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "gray-400", className: "bg-gray-400", hex: "#9ca3af" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "gray-500", className: "bg-gray-500", textClass: "text-white", hex: "#6b7280" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "gray-600", className: "bg-gray-600", textClass: "text-white", hex: "#4b5563" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "gray-700", className: "bg-gray-700", textClass: "text-white", hex: "#374151" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "gray-800", className: "bg-gray-800", textClass: "text-white", hex: "#1f2937" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "gray-900", className: "bg-gray-900", textClass: "text-white", hex: "#111827" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "Surfaces & Borders" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "background", className: "bg-background", hex: "#ffffff" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "foreground", className: "bg-foreground", textClass: "text-white", hex: "#0f172a" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "muted", className: "bg-muted", hex: "#f1f5f9" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "muted-foreground", className: "bg-muted-foreground", textClass: "text-white", hex: "#64748b" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "border", className: "bg-border", hex: "#e2e8f0" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Swatch, { name: "input", className: "bg-input", hex: "#e2e8f0" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "Text (Gray)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TextSwatch, { name: "foreground", textClass: "text-foreground" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TextSwatch, { name: "muted-foreground", textClass: "text-muted-foreground" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TextSwatch, { name: "gray-500", textClass: "text-gray-500" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TextSwatch, { name: "gray-600", textClass: "text-gray-600" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TextSwatch, { name: "gray-700", textClass: "text-gray-700" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TextSwatch, { name: "gray-800", textClass: "text-gray-800" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TextSwatch, { name: "gray-900", textClass: "text-gray-900" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "Borders (Gray)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(BorderSwatch, { name: "border", borderClass: "border-border" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(BorderSwatch, { name: "gray-100", borderClass: "border-gray-100" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(BorderSwatch, { name: "gray-200", borderClass: "border-gray-200" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(BorderSwatch, { name: "gray-300", borderClass: "border-gray-300" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(BorderSwatch, { name: "gray-400", borderClass: "border-gray-400" })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold mb-4", children: "Gradients" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid sm:grid-cols-2 lg:grid-cols-3 gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-brand text-white", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-brand" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm opacity-90", children: "from-pink-500  via-blue-500  to-green-500" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-brand-soft", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-brand-soft" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "from-pink-50  via-blue-50  to-green-50" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card relative overflow-hidden h-32 flex items-center justify-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedGradientBackground, { Breathing: true, startingGap: 125, containerClassName: "opacity-90" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative z-10 text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "Animated Gradient" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Configurable radial breathing" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-ocean-soft-radial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-ocean-soft-radial" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "blue/cyan/teal soft with radial accents" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-violet-soft-radial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-violet-soft-radial" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "violet/indigo/blue soft with radial accents" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-mint-soft-radial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-mint-soft-radial" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "green/emerald/teal soft with radial accents" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-sunset-soft-radial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-sunset-soft-radial" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "rose/pink/orange soft with radial accents" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-sand-soft-radial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-sand-soft-radial" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "amber/warm sand soft with radial accents" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-ice-soft-radial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-ice-soft-radial" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "icy blue/indigo soft with radial accents" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-rosewater-soft-radial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-rosewater-soft-radial" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "rose/pink/violet soft with radial accents" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-aurora-soft-radial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-aurora-soft-radial" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "green/cyan/violet aurora-inspired soft blend" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-meadow-soft-radial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-meadow-soft-radial" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "lime/green/mint meadow soft blend" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card gradient-moonlight-soft-radial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold", children: "gradient-moonlight-soft-radial" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "slate/indigo/violet moonlight soft blend" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold mb-4", children: "HSL Gradients Examples" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid sm:grid-cols-2 lg:grid-cols-3 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card h-32 flex items-center justify-center", style: { background: "linear-gradient(135deg, hsl(240, 100%, 95%), hsl(280, 100%, 95%), hsl(320, 100%, 95%))" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Purple HSL Soft" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "hsl(240,100%,95%)  hsl(280,100%,95%)  hsl(320,100%,95%)" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card h-32 flex items-center justify-center", style: { background: "radial-gradient(ellipse at center, hsl(200, 80%, 90%), hsl(220, 70%, 85%), hsl(240, 60%, 80%))" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Blue HSL Radial" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "radial hsl(200,80%,90%)  hsl(220,70%,85%)  hsl(240,60%,80%)" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card h-32 flex items-center justify-center", style: { background: "linear-gradient(45deg, hsl(120, 60%, 95%), hsl(150, 70%, 92%), hsl(180, 80%, 90%))" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Green HSL Diagonal" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "45deg hsl(120,60%,95%)  hsl(150,70%,92%)  hsl(180,80%,90%)" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card h-32 flex items-center justify-center", style: { background: "conic-gradient(from 0deg, hsl(0, 70%, 90%), hsl(60, 80%, 85%), hsl(120, 70%, 90%), hsl(180, 80%, 85%), hsl(240, 70%, 90%), hsl(300, 80%, 85%), hsl(0, 70%, 90%))" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Rainbow HSL Conic" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "conic-gradient with 360 HSL color wheel" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card h-32 flex items-center justify-center", style: { background: "linear-gradient(to bottom right, hsl(40, 100%, 95%), hsl(50, 90%, 88%), hsl(60, 80%, 85%))" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "Warm HSL Gradient" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "diagonal hsl(40,100%,95%)  hsl(50,90%,88%)  hsl(60,80%,85%)" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card h-32 flex items-center justify-center", style: { background: "linear-gradient(90deg, hsla(200, 100%, 95%, 0.8), hsla(220, 80%, 90%, 0.6), hsla(240, 60%, 85%, 0.8))" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold", children: "HSL with Alpha" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "hsla() with varying alpha transparency" })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 p-4 bg-muted/50 rounded-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium mb-2", children: "HSL Benefits" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "text-sm text-muted-foreground space-y-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Intuitive:" }),
              " Hue (0-360), Saturation (0-100%), Lightness (0-100%)"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Consistent brightness:" }),
              " Easy to create harmonious color schemes"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Better gradients:" }),
              " Smooth transitions through color wheel"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Alpha support:" }),
              " Use hsla() for transparency effects"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Design-friendly:" }),
              " Matches how designers think about color"
            ] })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold mb-4", children: "Border Radius" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid sm:grid-cols-2 lg:grid-cols-3 gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "rounded-sm" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-16 w-full bg-muted rounded-sm border" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "rounded-md" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-16 w-full bg-muted rounded-md border" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "rounded-lg" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-16 w-full bg-muted rounded-lg border" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "rounded-xl" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-16 w-full bg-muted rounded-xl border" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "rounded-2xl" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-16 w-full bg-muted rounded-2xl border" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "rounded-full" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-16 w-16 bg-muted rounded-full border" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground mt-3", children: "Note: `rounded-*` values are aligned to the theme radius token `--radius`." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold mb-4", children: "Shadows" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid sm:grid-cols-2 lg:grid-cols-3 gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card shadow-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium", children: "shadow-sm" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Subtle elevation" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card shadow", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium", children: "shadow" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Default elevation" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card shadow-md", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium", children: "shadow-md" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Medium elevation" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card shadow-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium", children: "shadow-lg" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Large elevation" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card shadow-xl", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium", children: "shadow-xl" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Extra large elevation" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card shadow-2xl", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium", children: "shadow-2xl" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Max elevation" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold mb-4", children: "Spacing Scale" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid md:grid-cols-2 gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "Padding Examples" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2 text-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-muted rounded border p-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-block bg-background px-2 py-1 rounded border", children: "p-1" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-muted rounded border p-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-block bg-background px-2 py-1 rounded border", children: "p-2" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-muted rounded border p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-block bg-background px-2 py-1 rounded border", children: "p-4" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-muted rounded border p-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-block bg-background px-2 py-1 rounded border", children: "p-6" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-muted rounded border p-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-block bg-background px-2 py-1 rounded border", children: "p-8" }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-3", children: "Gap/Space Examples" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3 text-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge", children: "gap-1" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge", children: "gap-2" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge", children: "gap-4" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge", children: "gap-6" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 w-8 bg-muted rounded" })
              ] })
            ] })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold mb-4", children: "Buttons" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { children: "Primary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "outline", children: "Outline" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "ghost", children: "Ghost" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "secondary", children: "Secondary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "destructive", children: "Destructive" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "link", children: "Link" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MagnetizeButton, { "aria-label": "Magnetize button demo", children: "Magnetize" }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold mb-4", children: "Forms" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid md:grid-cols-2 gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "label", htmlFor: "email", children: "Email" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "email", type: "email", className: "input", placeholder: "you@domain.com" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "helper-text", children: "Well never share your email." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "label", htmlFor: "name", children: "Name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { id: "name", type: "text", className: "input", placeholder: "Jane Doe" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold mb-4", children: "Cards" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid md:grid-cols-2 gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold mb-2", children: "Standard Card" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: "Use for general content containers." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card card-featured", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold mb-2", children: "Featured Card" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: "Highlighted with a soft brand gradient." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "card-button", children: "Call to Action" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "mb-12", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold mb-4", children: "Badges" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge", children: "Default" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge badge-primary", children: "Primary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge badge-accent", children: "Accent" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "badge badge-success", children: "Success" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold mb-4", children: "Typography" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-bold", children: "Heading 1" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl font-bold", children: "Heading 2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-semibold", children: "Heading 3" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-base", children: "Body text  default." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Muted text  for secondary information." })
      ] })
    ] })
  ] });
};
const AdminLogin = ({ onClose }) => {
  const [email, setEmail] = reactExports.useState("");
  const [password, setPassword] = reactExports.useState("");
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const { login } = useAuth();
  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError("");
    try {
      const result = await login(email, password);
      if (result.success) {
        if (onClose) onClose();
        if (window.location.pathname === "/admin") {
          window.location.reload();
        }
      } else {
        if (result.error === "Server configuration error") {
          setError("Admin credentials not configured. Please contact the site administrator.");
        } else {
          setError(result.error || "Login failed");
        }
      }
    } catch (error2) {
      setError("Network error: Unable to connect to the authentication server");
    } finally {
      setLoading(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background border border-border rounded-lg w-full max-w-md p-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold", children: "Admin Login" }),
      onClose && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: onClose,
          className: "text-muted-foreground hover:text-foreground",
          children: ""
        }
      )
    ] }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded mb-4", children: error }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "email", className: "block text-sm font-medium mb-2", children: "Email" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            id: "email",
            type: "email",
            value: email,
            onChange: (e) => setEmail(e.target.value),
            className: "w-full p-3 border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-primary",
            placeholder: "admin@bibliokit.com",
            required: true,
            disabled: loading
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "password", className: "block text-sm font-medium mb-2", children: "Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            id: "password",
            type: "password",
            value: password,
            onChange: (e) => setPassword(e.target.value),
            className: "w-full p-3 border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-primary",
            placeholder: "",
            required: true,
            disabled: loading
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "submit",
          disabled: loading,
          className: "w-full button disabled:opacity-50 disabled:cursor-not-allowed",
          children: loading ? "Signing In..." : "Sign In"
        }
      )
    ] })
  ] }) });
};
const useContentEditorState = () => {
  const [savedContent, setSavedContent] = reactExports.useState(productData);
  const [jsonContent, setJsonContent] = reactExports.useState(
    JSON.stringify(productData, null, 2)
  );
  const [isEditing, setIsEditing] = reactExports.useState(false);
  const updateSection = (section, newData) => {
    const updatedContent = { ...savedContent };
    if (section.includes(".")) {
      const path = section.split(".");
      let current = updatedContent;
      for (let i = 0; i < path.length - 1; i++) {
        if (!current[path[i]]) {
          current[path[i]] = {};
        }
        current = current[path[i]];
      }
      current[path[path.length - 1]] = newData;
    } else {
      updatedContent[section] = newData;
    }
    setSavedContent(updatedContent);
    setJsonContent(JSON.stringify(updatedContent, null, 2));
    setIsEditing(true);
    try {
      const sample = section.startsWith("features") && Array.isArray(updatedContent == null ? void 0 : updatedContent.features) ? updatedContent.features[0] : section === "features" && Array.isArray(newData) ? newData[0] : void 0;
      debugService.contentUpdate("useContentEditorState.updateSection", {
        section,
        keys: Object.keys(updatedContent || {}),
        featuresCount: Array.isArray(updatedContent == null ? void 0 : updatedContent.features) ? updatedContent.features.length : void 0,
        sample
      });
    } catch {
    }
  };
  const updateNestedField = (section, index, field, value) => {
    let currentSection;
    if (section.includes(".")) {
      const path = section.split(".");
      currentSection = savedContent;
      for (const key of path) {
        currentSection = currentSection == null ? void 0 : currentSection[key];
      }
    } else {
      currentSection = savedContent[section];
    }
    let updatedSection;
    if (Array.isArray(currentSection) && index !== null) {
      updatedSection = currentSection.map(
        (item, i) => i === index ? { ...item, [field]: value } : item
      );
    } else {
      const baseObject = currentSection && typeof currentSection === "object" && !Array.isArray(currentSection) ? currentSection : {};
      updatedSection = { ...baseObject, [field]: value };
    }
    try {
      debugService.contentUpdate("useContentEditorState.updateNestedField(before)", {
        section,
        index,
        field,
        value: typeof value === "string" ? value.slice(0, 120) : value
      });
    } catch {
    }
    updateSection(section, updatedSection);
    try {
      const after = section.includes(".") ? section : `${section}`;
      debugService.contentUpdate("useContentEditorState.updateNestedField(after)", { path: after });
    } catch {
    }
  };
  return {
    savedContent,
    setSavedContent,
    jsonContent,
    setJsonContent,
    isEditing,
    setIsEditing,
    updateSection,
    updateNestedField
  };
};
const HeaderNavigationEditor = ({ items, onChange }) => {
  const handleAdd = () => {
    const next = [...items || [], { label: "New Link", href: "#" }];
    onChange(next);
  };
  const handleUpdate = (index, field, value) => {
    const next = (items || []).map((item, i) => i === index ? { ...item, [field]: value } : item);
    onChange(next);
  };
  const handleRemove = (index) => {
    const next = (items || []).filter((_, i) => i !== index);
    onChange(next);
  };
  const handleMove = (from, to) => {
    const next = reorderArray(items || [], from, to);
    onChange(next);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-border pt-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium", children: "Navigation Links" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleAdd, className: "button-secondary text-xs", children: "+ Add Link" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
      (items || []).map((navItem, index) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-3 items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: (navItem == null ? void 0 : navItem.label) || "",
              onChange: (e) => handleUpdate(index, "label", e.target.value),
              className: "p-2 border border-border rounded text-sm",
              placeholder: "Link label (e.g., Features)",
              "aria-label": `Header nav ${index + 1} label`
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: (navItem == null ? void 0 : navItem.href) || "",
                onChange: (e) => handleUpdate(index, "href", e.target.value),
                className: "flex-1 p-2 border border-border rounded text-sm",
                placeholder: "/#contact or #pricing or /about",
                "aria-label": `Header nav ${index + 1} href`
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => {
                  if (index <= 0) return;
                  handleMove(index, index - 1);
                },
                disabled: index === 0,
                className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1",
                title: "Move up",
                "aria-label": `Move header nav link ${index + 1} up`,
                children: ""
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => {
                  if (index >= ((items == null ? void 0 : items.length) || 0) - 1) return;
                  handleMove(index, index + 1);
                },
                disabled: index === ((items == null ? void 0 : items.length) || 0) - 1,
                className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1",
                title: "Move down",
                "aria-label": `Move header nav link ${index + 1} down`,
                children: ""
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => handleRemove(index),
                className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-sm",
                "aria-label": `Remove header nav link ${index + 1}`,
                children: "Remove"
              }
            )
          ] })
        ] }, index);
      }),
      ((items == null ? void 0 : items.length) || 0) === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-6 text-muted-foreground text-sm", children: "No navigation links yet." })
    ] })
  ] });
};
const FooterEditor = ({
  description,
  sections,
  visibility,
  onChangeDescription,
  onChangeSections,
  onChangeVisibility
}) => {
  const [jsonEdit, setJsonEdit] = React.useState(false);
  const [jsonValue, setJsonValue] = React.useState(JSON.stringify({ visibility, description, sections }, null, 2));
  React.useEffect(() => {
    setJsonValue(JSON.stringify({ visibility, description, sections }, null, 2));
  }, [visibility, description, sections]);
  const addSection = () => {
    const next = [...sections || [], { title: "New Section", links: [] }];
    onChangeSections(next);
  };
  const updateSectionTitle = (index, value) => {
    const next = (sections || []).map((s2, i) => i === index ? { ...s2, title: value } : s2);
    onChangeSections(next);
  };
  const moveSection = (from, to) => {
    const next = reorderArray(sections || [], from, to);
    onChangeSections(next);
  };
  const removeSection = (index) => {
    const next = (sections || []).filter((_, i) => i !== index);
    onChangeSections(next);
  };
  const addLink = (sectionIndex) => {
    const group = (sections || [])[sectionIndex] || { links: [] };
    const nextLinks = [...group.links || [], { label: "New Link", href: "#" }];
    const next = (sections || []).map((s2, i) => i === sectionIndex ? { ...s2, links: nextLinks } : s2);
    onChangeSections(next);
  };
  const updateLink = (sectionIndex, linkIndex, field, value) => {
    const group = (sections || [])[sectionIndex] || { links: [] };
    const links = [...group.links || []];
    links[linkIndex] = { ...links[linkIndex] || {}, [field]: value };
    const next = (sections || []).map((s2, i) => i === sectionIndex ? { ...s2, links } : s2);
    onChangeSections(next);
  };
  const moveLink = (sectionIndex, from, to) => {
    const group = (sections || [])[sectionIndex] || { links: [] };
    const nextLinks = reorderArray(group.links || [], from, to);
    const next = (sections || []).map((s2, i) => i === sectionIndex ? { ...s2, links: nextLinks } : s2);
    onChangeSections(next);
  };
  const removeLink = (sectionIndex, linkIndex) => {
    const group = (sections || [])[sectionIndex] || { links: [] };
    const nextLinks = (group.links || []).filter((_, i) => i !== linkIndex);
    const next = (sections || []).map((s2, i) => i === sectionIndex ? { ...s2, links: nextLinks } : s2);
    onChangeSections(next);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Footer Section" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "px-3 py-1 text-sm rounded border border-border hover:bg-muted", onClick: () => setJsonEdit(true), children: "Edit JSON" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "checkbox",
          id: "footer-visible",
          checked: visibility,
          onChange: (e) => onChangeVisibility(e.target.checked),
          className: "rounded border-border"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "footer-visible", className: "text-sm", children: "Visible on website" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Description" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          value: description || "",
          onChange: (e) => onChangeDescription(e.target.value),
          className: "w-full p-2 border border-border rounded h-24",
          placeholder: "Footer description"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-border pt-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium", children: "Footer Sections" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: addSection, className: "button-secondary text-xs", children: "+ Add Section" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: (sections || []).map((sectionItem, si) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border rounded-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-muted-foreground", children: [
              "Section #",
              si + 1
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: (sectionItem == null ? void 0 : sectionItem.title) || "",
                onChange: (e) => updateSectionTitle(si, e.target.value),
                className: "flex-1 p-2 border border-border rounded text-sm",
                placeholder: "Section title (e.g., Product)",
                "aria-label": `Footer section ${si + 1} title`
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => {
                  if (si <= 0) return;
                  moveSection(si, si - 1);
                },
                disabled: si === 0,
                className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1",
                title: "Move up",
                "aria-label": `Move footer section ${si + 1} up`,
                children: ""
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => {
                  if (si >= ((sections == null ? void 0 : sections.length) || 0) - 1) return;
                  moveSection(si, si + 1);
                },
                disabled: si === ((sections == null ? void 0 : sections.length) || 0) - 1,
                className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1",
                title: "Move down",
                "aria-label": `Move footer section ${si + 1} down`,
                children: ""
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => removeSection(si),
                className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-sm",
                "aria-label": `Remove footer section ${si + 1}`,
                children: "Remove"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 pt-3 border-t border-border/50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-medium", children: "Links" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => addLink(si), className: "text-primary hover:bg-primary/10 px-2 py-1 rounded text-xs", children: "+ Add Link" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: ((sectionItem == null ? void 0 : sectionItem.links) || []).map((link, li) => {
            var _a;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-3 items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: (link == null ? void 0 : link.label) || "",
                  onChange: (e) => updateLink(si, li, "label", e.target.value),
                  className: "p-2 border border-border rounded text-sm",
                  placeholder: "Link label (e.g., Pricing)",
                  "aria-label": `Footer link ${li + 1} label in section ${si + 1}`
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    value: (link == null ? void 0 : link.href) || "",
                    onChange: (e) => updateLink(si, li, "href", e.target.value),
                    className: "flex-1 p-2 border border-border rounded text-sm",
                    placeholder: "#pricing or https://example.com",
                    "aria-label": `Footer link ${li + 1} href in section ${si + 1}`
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: () => {
                      if (li <= 0) return;
                      moveLink(si, li, li - 1);
                    },
                    disabled: li === 0,
                    className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1",
                    title: "Move up",
                    "aria-label": `Move link ${li + 1} up in section ${si + 1}`,
                    children: ""
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: () => {
                      var _a2;
                      if (li >= (((_a2 = sectionItem.links) == null ? void 0 : _a2.length) || 0) - 1) return;
                      moveLink(si, li, li + 1);
                    },
                    disabled: li === (((_a = sectionItem.links) == null ? void 0 : _a.length) || 0) - 1,
                    className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1",
                    title: "Move down",
                    "aria-label": `Move link ${li + 1} down in section ${si + 1}`,
                    children: ""
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: () => removeLink(si, li),
                    className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-sm",
                    "aria-label": `Remove footer link ${li + 1} in section ${si + 1}`,
                    children: "Remove"
                  }
                )
              ] })
            ] }, li);
          }) })
        ] })
      ] }, si)) })
    ] })
  ] });
};
const HeaderCtasEditor = ({
  visibility,
  logoText,
  signInText,
  getStartedText,
  signInHref,
  getStartedHref,
  showSignIn,
  showGetStarted,
  onChangeVisibility,
  onChangeLogoText,
  onChangeSignInText,
  onChangeGetStartedText,
  onChangeSignInHref,
  onChangeGetStartedHref,
  onChangeShowSignIn,
  onChangeShowGetStarted
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "checkbox",
          id: "header-visible",
          checked: visibility,
          onChange: (e) => onChangeVisibility(e.target.checked),
          className: "rounded border-border"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "header-visible", className: "text-sm", children: "Visible on website" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Logo Text" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          value: logoText || "",
          onChange: (e) => onChangeLogoText(e.target.value),
          className: "w-full p-2 border border-border rounded",
          placeholder: "BiblioKit"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Sign In Text" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: signInText || "",
            onChange: (e) => onChangeSignInText(e.target.value),
            className: "w-full p-2 border border-border rounded",
            placeholder: "Sign In"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Get Started Text" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: getStartedText || "",
            onChange: (e) => onChangeGetStartedText(e.target.value),
            className: "w-full p-2 border border-border rounded",
            placeholder: "Get Started"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Sign In Link" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: signInHref || "",
            onChange: (e) => onChangeSignInHref(e.target.value),
            className: "w-full p-2 border border-border rounded",
            placeholder: "/admin or /login"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Get Started Link" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: getStartedHref || "",
            onChange: (e) => onChangeGetStartedHref(e.target.value),
            className: "w-full p-2 border border-border rounded",
            placeholder: "/#contact or /signup"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            id: "show-sign-in-sections",
            checked: showSignIn ?? true,
            onChange: (e) => onChangeShowSignIn(e.target.checked),
            className: "rounded border-border"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "show-sign-in-sections", className: "text-sm", children: "Show Sign In Button" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            id: "show-get-started-sections",
            checked: showGetStarted ?? true,
            onChange: (e) => onChangeShowGetStarted(e.target.checked),
            className: "rounded border-border"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "show-get-started-sections", className: "text-sm", children: "Show Get Started Button" })
      ] })
    ] })
  ] });
};
const ProductsManager = ({
  products: products2,
  activeSection,
  showNewProductForm,
  newProductSlug,
  newProductTitle,
  setActiveSection,
  setShowNewProductForm,
  setNewProductSlug,
  setNewProductTitle,
  onDuplicate,
  onDelete,
  onCreate,
  onRenameSlug,
  onRenameTitle,
  onMove,
  onImportJson,
  onCreateFromJson
}) => {
  const productKeys = Object.keys(products2 || {});
  const [openActionsFor, setOpenActionsFor] = React.useState(null);
  const [editingSlugFor, setEditingSlugFor] = React.useState(null);
  const [editingTitleFor, setEditingTitleFor] = React.useState(null);
  const [slugDraft, setSlugDraft] = React.useState("");
  const [titleDraft, setTitleDraft] = React.useState("");
  const [showPasteFor, setShowPasteFor] = React.useState(null);
  const [pasteText, setPasteText] = React.useState("");
  const [createFromJsonOpen, setCreateFromJsonOpen] = React.useState(false);
  const [createJsonText, setCreateJsonText] = React.useState("");
  const isFirst = (key) => productKeys.indexOf(key) === 0;
  const isLast = (key) => productKeys.indexOf(key) === productKeys.length - 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    productKeys.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold mb-2 text-sm", children: "Product Pages" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: productKeys.map((productKey) => {
        var _a;
        const isActive = activeSection === `product-${productKey}`;
        const title = ((_a = products2[productKey]) == null ? void 0 : _a.title) || productKey.replace(/-/g, " ");
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-2 rounded border ${isActive ? "border-primary/40 bg-primary/5" : "border-border"} focus-within:ring-1 focus-within:ring-primary`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-between gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                type: "button",
                className: "text-left flex-1",
                onClick: () => setActiveSection(`product-${productKey}`),
                onKeyDown: (e) => {
                  if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    setActiveSection(`product-${productKey}`);
                  }
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium", children: title }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "opacity-70 text-xs", children: [
                    "/",
                    productKey
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "text-xs px-2 py-1 rounded bg-muted",
                onClick: () => setOpenActionsFor(openActionsFor === productKey ? null : productKey),
                "aria-haspopup": "true",
                "aria-expanded": openActionsFor === productKey,
                "aria-controls": `product-actions-${productKey}`,
                children: "Manage"
              }
            ) })
          ] }),
          openActionsFor === productKey && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: `product-actions-${productKey}`, role: "group", className: "mt-2 bg-muted/30 rounded p-2 space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "text-xs px-2 py-1 rounded bg-muted",
                  onClick: () => {
                    onDuplicate(productKey);
                    setOpenActionsFor(null);
                  },
                  children: "Duplicate"
                }
              ),
              onMove && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    className: "text-xs px-2 py-1 rounded bg-muted disabled:opacity-50",
                    disabled: isFirst(productKey),
                    onClick: () => {
                      onMove(productKey, "up");
                    },
                    "aria-label": "Move up",
                    children: "Move "
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    className: "text-xs px-2 py-1 rounded bg-muted disabled:opacity-50",
                    disabled: isLast(productKey),
                    onClick: () => {
                      onMove(productKey, "down");
                    },
                    "aria-label": "Move down",
                    children: "Move "
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "text-xs px-2 py-1 rounded bg-muted",
                  onClick: () => {
                    setEditingTitleFor(null);
                    setEditingSlugFor(productKey);
                    setSlugDraft(productKey);
                  },
                  children: "Rename Slug"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "text-xs px-2 py-1 rounded bg-muted",
                  onClick: () => {
                    var _a2;
                    setEditingSlugFor(null);
                    setEditingTitleFor(productKey);
                    setTitleDraft(((_a2 = products2[productKey]) == null ? void 0 : _a2.title) || "");
                  },
                  children: "Rename Title"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "text-xs px-2 py-1 rounded bg-muted text-red-700",
                  onClick: () => {
                    if (confirm("Delete this product page? This only affects local JSON until you Publish.")) {
                      onDelete(productKey);
                      setOpenActionsFor(null);
                    }
                  },
                  children: "Delete"
                }
              ),
              onImportJson && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "text-xs px-2 py-1 rounded bg-muted",
                  onClick: () => {
                    setShowPasteFor(productKey);
                    setPasteText(JSON.stringify(products2[productKey] || {}, null, 2));
                  },
                  children: "Paste Full JSON"
                }
              )
            ] }),
            editingSlugFor === productKey && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: slugDraft,
                  onChange: (e) => setSlugDraft(e.target.value),
                  className: "flex-1 p-1 border border-border rounded text-xs",
                  placeholder: "new-slug",
                  "aria-label": "New slug"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "text-xs px-2 py-1 rounded bg-primary text-primary-foreground",
                  onClick: () => {
                    if (onRenameSlug) onRenameSlug(productKey, slugDraft);
                    setEditingSlugFor(null);
                    setOpenActionsFor(null);
                  },
                  children: "Save"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "text-xs px-2 py-1 rounded bg-muted",
                  onClick: () => setEditingSlugFor(null),
                  children: "Cancel"
                }
              )
            ] }),
            editingTitleFor === productKey && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: titleDraft,
                  onChange: (e) => setTitleDraft(e.target.value),
                  className: "flex-1 p-1 border border-border rounded text-xs",
                  placeholder: "New title",
                  "aria-label": "New title"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "text-xs px-2 py-1 rounded bg-primary text-primary-foreground",
                  onClick: () => {
                    if (onRenameTitle) onRenameTitle(productKey, titleDraft);
                    setEditingTitleFor(null);
                    setOpenActionsFor(null);
                  },
                  children: "Save"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  className: "text-xs px-2 py-1 rounded bg-muted",
                  onClick: () => setEditingTitleFor(null),
                  children: "Cancel"
                }
              )
            ] }),
            showPasteFor === productKey && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  value: pasteText,
                  onChange: (e) => setPasteText(e.target.value),
                  className: "w-full p-2 border border-border rounded text-xs font-mono h-40",
                  placeholder: '{"title":"My Product","description":"...","primaryButton":"Get Started","primaryButtonLink":"/start","secondaryButton":"Learn More","secondaryButtonLink":"/learn","details":[{"title":"","description":""}],"benefits":[],"specifications":[],"pricing":{"price":"","period":"/month","description":"","buttonText":""},"visibility":{"waitlist":true},"llm":{"answerBox":"","expertQuote":{},"statistic":{},"faqs":[]}}'
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    className: "text-xs px-2 py-1 rounded bg-primary text-primary-foreground",
                    onClick: () => {
                      try {
                        const parsed = JSON.parse(pasteText);
                        onImportJson == null ? void 0 : onImportJson(productKey, parsed);
                        setShowPasteFor(null);
                        setPasteText("");
                        setOpenActionsFor(null);
                      } catch {
                        alert("Invalid JSON. Please fix and try again.");
                      }
                    },
                    children: "Apply JSON"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    className: "text-xs px-2 py-1 rounded bg-muted",
                    onClick: () => {
                      setShowPasteFor(null);
                      setPasteText("");
                    },
                    children: "Cancel"
                  }
                )
              ] })
            ] })
          ] })
        ] }, productKey);
      }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-3", children: !showNewProductForm ? /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setShowNewProductForm(true), className: "w-full button-secondary text-xs", children: "+ New Product Page" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          value: newProductSlug,
          onChange: (e) => setNewProductSlug(e.target.value),
          placeholder: "my-product",
          className: "w-full p-2 border rounded text-sm"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          value: newProductTitle,
          onChange: (e) => setNewProductTitle(e.target.value),
          placeholder: "My Product",
          className: "w-full p-2 border rounded text-sm"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onCreate, className: "button text-xs", children: "Create" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => {
              setShowNewProductForm(false);
              setNewProductSlug("");
              setNewProductTitle("");
            },
            className: "button-secondary text-xs",
            children: "Cancel"
          }
        )
      ] }),
      onCreateFromJson && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2 mt-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: "w-full text-xs px-2 py-1 rounded bg-muted",
            onClick: () => setCreateFromJsonOpen(!createFromJsonOpen),
            children: createFromJsonOpen ? "Hide JSON Creator" : "Create from Full JSON"
          }
        ),
        createFromJsonOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              value: createJsonText,
              onChange: (e) => setCreateJsonText(e.target.value),
              className: "w-full p-2 border border-border rounded text-xs font-mono h-40",
              placeholder: '{"title":"My Product","description":"...","primaryButton":"Get Started","primaryButtonLink":"/start","secondaryButton":"Learn More","secondaryButtonLink":"/learn","details":[{"title":"","description":""}],"benefits":[],"specifications":[],"pricing":{"price":"","period":"/month","description":"","buttonText":""},"visibility":{"waitlist":true},"llm":{"answerBox":"","expertQuote":{},"statistic":{},"faqs":[]}}'
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "button text-xs",
              onClick: () => {
                try {
                  const parsed = JSON.parse(createJsonText || "{}");
                  const slug = newProductSlug || (parsed == null ? void 0 : parsed.slug) || "";
                  if (!slug && !(parsed == null ? void 0 : parsed.title)) {
                    alert("Provide a slug above or include a title/slug in JSON.");
                    return;
                  }
                  onCreateFromJson == null ? void 0 : onCreateFromJson(slug, parsed);
                  setCreateJsonText("");
                  setCreateFromJsonOpen(false);
                } catch {
                  alert("Invalid JSON. Please fix and try again.");
                }
              },
              children: "Create from JSON"
            }
          )
        ] })
      ] })
    ] }) })
  ] });
};
const PagesManager = ({ pages, activeSection, setActiveSection }) => {
  if (!Array.isArray(pages) || pages.length === 0) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold mb-2 text-sm", children: "Static Pages" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: pages.map((p) => {
      const key = p.slug || `${p.id}`;
      const isActive = activeSection === "pages";
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          className: `w-full text-left p-2 rounded text-sm transition-colors flex items-center justify-between ${isActive ? "bg-primary text-primary-foreground" : "hover:bg-muted/40"}`,
          onClick: () => setActiveSection("pages"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: p.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "opacity-70 ml-2 text-xs", children: [
              "/",
              p.slug
            ] })
          ]
        },
        key
      );
    }) })
  ] });
};
const PagesEditor = ({ pages, onChange }) => {
  const [value, setValue] = React.useState(JSON.stringify(pages || [], null, 2));
  React.useEffect(() => {
    setValue(JSON.stringify(pages || [], null, 2));
  }, [pages]);
  const handleChange = (text) => {
    setValue(text);
    try {
      const parsed = JSON.parse(text);
      if (Array.isArray(parsed)) {
        onChange(parsed);
      }
    } catch {
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Pages" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Manage static pages. These are saved in JSON first; when you Save & Reload, they sync to the database." }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium", children: "Pages (JSON array)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          className: "w-full p-2 border border-border rounded h-64 font-mono text-sm",
          value,
          onChange: (e) => handleChange(e.target.value),
          placeholder: '[{"slug":"about","title":"About Us","content":{"blocks":[]},"isPublished":true}]'
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-muted-foreground", children: "Tip: Use unique slugs. Content can be any JSON shape you render on that page." })
  ] });
};
const TextInput = ({
  label,
  value,
  onChange,
  placeholder,
  type = "text",
  className = ""
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: label }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type,
      value,
      onChange: (e) => onChange(e.target.value),
      className: `w-full p-2 border border-border rounded ${className}`,
      placeholder
    }
  )
] });
const TextArea = ({
  label,
  value,
  onChange,
  placeholder,
  rows = 3,
  className = ""
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: label }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "textarea",
    {
      value,
      onChange: (e) => onChange(e.target.value),
      className: `w-full p-2 border border-border rounded ${className}`,
      placeholder,
      rows
    }
  )
] });
const ToggleSwitch = ({
  label,
  checked,
  onChange,
  id: id2
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "inline-flex items-center cursor-pointer", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "checkbox",
        className: "sr-only peer",
        checked,
        onChange: (e) => onChange(e.target.checked),
        id: id2
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-primary" })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "capitalize", children: label })
] });
const Button = ({
  children,
  onClick,
  variant = "primary",
  disabled = false,
  className = ""
}) => {
  const baseClasses = "px-3 py-2 rounded transition-colors text-sm";
  const variantClasses = {
    primary: "button",
    secondary: "button-secondary",
    danger: "bg-red-600 text-white hover:bg-red-700"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick,
      disabled,
      className: `${baseClasses} ${variantClasses[variant]} ${className}`,
      children
    }
  );
};
const ButtonField = ({
  label,
  buttonText,
  buttonLink,
  onTextChange,
  onLinkChange,
  textPlaceholder = "Button text",
  linkPlaceholder = "https://example.com or /path"
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "font-medium text-sm text-muted-foreground", children: label }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextInput,
    {
      label: "Button Text",
      value: buttonText,
      onChange: onTextChange,
      placeholder: textPlaceholder
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    TextInput,
    {
      label: "Button Link",
      value: buttonLink,
      onChange: onLinkChange,
      placeholder: linkPlaceholder
    }
  )
] });
const ContactSectionEditor = ({ contact: contact2, updateNestedField }) => {
  const [jsonEdit, setJsonEdit] = React.useState(false);
  const [jsonValue, setJsonValue] = React.useState(JSON.stringify(contact2 || {}, null, 2));
  const [localContact, setLocalContact] = React.useState(() => contact2 || {});
  const isActivelyEditing = React.useRef(false);
  const lastPropUpdate = React.useRef(Date.now());
  React.useEffect(() => {
    const now = Date.now();
    const timeSinceLastUpdate = now - lastPropUpdate.current;
    if (Object.keys(localContact).length === 0 || timeSinceLastUpdate > 1e3 && !isActivelyEditing.current) {
      setLocalContact(contact2 || {});
      lastPropUpdate.current = now;
    }
  }, [contact2, localContact]);
  React.useEffect(() => {
    setJsonValue(JSON.stringify(localContact || {}, null, 2));
  }, [localContact]);
  const updateContactField = React.useCallback((field, value) => {
    isActivelyEditing.current = true;
    const updatedContact = { ...localContact, [field]: value };
    setLocalContact(updatedContact);
    updateNestedField("contact", null, field, value);
    setTimeout(() => {
      isActivelyEditing.current = false;
    }, 2e3);
  }, [localContact, updateNestedField]);
  const applyJson = () => {
    try {
      const wasEditing2 = isActivelyEditing.current;
      isActivelyEditing.current = false;
      const parsed = JSON.parse(jsonValue || "{}");
      if (parsed && typeof parsed === "object") {
        setLocalContact(parsed);
        Object.entries(parsed).forEach(([k, v]) => updateNestedField("contact", null, k, v));
      }
      setJsonEdit(false);
      setTimeout(() => {
        setJsonValue(JSON.stringify(localContact, null, 2));
        isActivelyEditing.current = wasEditing2;
      }, 50);
    } catch {
      isActivelyEditing.current = wasEditing;
      alert("Invalid JSON. Please correct and try again.");
    }
  };
  if (jsonEdit) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Contact Information  JSON Editor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "button-secondary text-xs", onClick: () => setJsonEdit(false), children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "button text-xs", onClick: applyJson, children: "Apply JSON" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          className: "w-full p-2 border border-border rounded h-64 font-mono text-sm",
          value: jsonValue,
          onChange: (e) => setJsonValue(e.target.value),
          placeholder: '{"email":"hello@example.com","twitter":"@username","github":"username"}'
        }
      )
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Contact Information" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "px-3 py-1 text-sm rounded border border-border hover:bg-muted", onClick: () => setJsonEdit(true), children: "Edit JSON" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        label: "Email",
        type: "email",
        value: (localContact == null ? void 0 : localContact.email) || "",
        onChange: (value) => updateContactField("email", value),
        placeholder: "hello@example.com"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        label: "Twitter",
        value: (localContact == null ? void 0 : localContact.twitter) || "",
        onChange: (value) => updateContactField("twitter", value),
        placeholder: "@username"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        label: "GitHub",
        value: (localContact == null ? void 0 : localContact.github) || "",
        onChange: (value) => updateContactField("github", value),
        placeholder: "username"
      }
    )
  ] });
};
const HeroSectionEditor = ({
  hero: hero2,
  updateNestedField,
  visible,
  updateVisibility
}) => {
  const [jsonEdit, setJsonEdit] = React.useState(false);
  const [jsonValue, setJsonValue] = React.useState(
    JSON.stringify({ visible, hero: hero2 }, null, 2)
  );
  const [localHero, setLocalHero] = React.useState(() => hero2 || {});
  const isActivelyEditing = React.useRef(false);
  const lastPropUpdate = React.useRef(Date.now());
  React.useEffect(() => {
    const now = Date.now();
    const timeSinceLastUpdate = now - lastPropUpdate.current;
    if (Object.keys(localHero).length === 0 || timeSinceLastUpdate > 1e3 && !isActivelyEditing.current) {
      setLocalHero(hero2 || {});
      lastPropUpdate.current = now;
    }
  }, [hero2, localHero]);
  React.useEffect(() => {
    setJsonValue(JSON.stringify({ visible, hero: localHero }, null, 2));
  }, [localHero, visible]);
  const updateHeroField = React.useCallback((field, value) => {
    isActivelyEditing.current = true;
    const updatedHero = { ...localHero, [field]: value };
    setLocalHero(updatedHero);
    updateNestedField("hero", null, field, value);
    setTimeout(() => {
      isActivelyEditing.current = false;
    }, 2e3);
  }, [localHero, updateNestedField]);
  const applyJson = () => {
    try {
      const wasEditing2 = isActivelyEditing.current;
      isActivelyEditing.current = false;
      const parsed = JSON.parse(jsonValue);
      if (parsed && typeof parsed === "object") {
        const nextHero = parsed.hero || parsed;
        if (nextHero && typeof nextHero === "object") {
          setLocalHero(nextHero);
          Object.entries(nextHero).forEach(([k, v]) => updateNestedField("hero", null, k, v));
        }
        if (typeof parsed.visible === "boolean") {
          updateVisibility(parsed.visible);
        }
      }
      setJsonEdit(false);
      setTimeout(() => {
        const refreshPayload = { visible, hero: localHero };
        setJsonValue(JSON.stringify(refreshPayload, null, 2));
        isActivelyEditing.current = wasEditing2;
      }, 50);
    } catch {
      isActivelyEditing.current = wasEditing;
      alert("Invalid JSON. Please correct and try again.");
    }
  };
  if (jsonEdit) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Hero Section  JSON Editor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "button-secondary text-xs", onClick: () => setJsonEdit(false), children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "button text-xs", onClick: applyJson, children: "Apply JSON" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          className: "w-full p-2 border border-border rounded h-64 font-mono text-sm",
          value: jsonValue,
          onChange: (e) => setJsonValue(e.target.value),
          placeholder: '{"visible":true,"hero":{"badgeLabel":"","gradientColors":["#ecfeff00"],"emoji":"","title":"","subtitle":"","description":"","primaryButton":"","primaryButtonLink":"","secondaryButton":"","secondaryButtonLink":""}}'
        }
      )
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Hero Section" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "px-3 py-1 text-sm rounded border border-border hover:bg-muted", onClick: () => setJsonEdit(true), children: "Edit JSON" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-4 p-3 bg-muted/20 rounded-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          id: "hero-visible",
          type: "checkbox",
          checked: visible,
          onChange: (e) => updateVisibility(e.target.checked),
          className: "rounded border-border"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "hero-visible", className: "text-sm font-medium", children: "Visible on site" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        label: "Badge Label",
        value: (localHero == null ? void 0 : localHero.badgeLabel) || "",
        onChange: (value) => updateHeroField("badgeLabel", value),
        placeholder: "SaaS Analytics Platform"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium", children: "Gradient Colors (comma-separated hex)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          value: ((localHero == null ? void 0 : localHero.gradientColors) || []).join(", "),
          onChange: (e) => updateHeroField("gradientColors", e.target.value.split(",").map((v) => v.trim()).filter(Boolean)),
          className: "w-full p-2 border border-border rounded",
          placeholder: "#ecfeff00, #ecfeff10, #c7d2fe40, #a7f3d040, #a5b4fc50, #93c5fd40, #ffffff00"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "Provide 58 RGBA/hex values with alpha for best effect." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        label: "Emoji",
        value: (localHero == null ? void 0 : localHero.emoji) || "",
        onChange: (value) => updateHeroField("emoji", value),
        placeholder: "e.g. "
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        label: "Title",
        value: (localHero == null ? void 0 : localHero.title) || "",
        onChange: (value) => updateHeroField("title", value)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        label: "Subtitle",
        value: (localHero == null ? void 0 : localHero.subtitle) || "",
        onChange: (value) => updateHeroField("subtitle", value)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextArea,
      {
        label: "Description",
        value: (localHero == null ? void 0 : localHero.description) || "",
        onChange: (value) => updateHeroField("description", value),
        rows: 3
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "Buttons" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonField,
          {
            label: "Primary Button",
            buttonText: (localHero == null ? void 0 : localHero.primaryButton) || "",
            buttonLink: (localHero == null ? void 0 : localHero.primaryButtonLink) || "",
            onTextChange: (value) => updateHeroField("primaryButton", value),
            onLinkChange: (value) => updateHeroField("primaryButtonLink", value)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonField,
          {
            label: "Secondary Button",
            buttonText: (localHero == null ? void 0 : localHero.secondaryButton) || "",
            buttonLink: (localHero == null ? void 0 : localHero.secondaryButtonLink) || "",
            onTextChange: (value) => updateHeroField("secondaryButton", value),
            onLinkChange: (value) => updateHeroField("secondaryButtonLink", value)
          }
        )
      ] })
    ] })
  ] });
};
const SettingsSectionEditor = ({
  settings: settings2,
  updateSettingsVisibility
}) => {
  const [jsonEdit, setJsonEdit] = React.useState(false);
  const [jsonValue, setJsonValue] = React.useState(JSON.stringify(settings2 || {}, null, 2));
  React.useEffect(() => {
    setJsonValue(JSON.stringify(settings2 || {}, null, 2));
  }, [settings2]);
  const applyJson = () => {
    try {
      const parsed = JSON.parse(jsonValue || "{}");
      if (parsed && typeof parsed === "object") {
        if (parsed.visibility && typeof parsed.visibility === "object") {
          Object.entries(parsed.visibility).forEach(([key, value]) => {
            updateSettingsVisibility(String(key), Boolean(value));
          });
        }
        if (parsed.labels && typeof parsed.labels === "object") {
          Object.entries(parsed.labels).forEach(([key, value]) => {
            updateSettingsVisibility(`labels.${String(key)}`, Boolean(value));
          });
        }
      }
      setJsonEdit(false);
    } catch {
      alert("Invalid JSON. Please correct and try again.");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Visibility Settings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "px-3 py-1 text-sm rounded border border-border hover:bg-muted", onClick: () => setJsonEdit(true), children: "Edit JSON" })
    ] }),
    jsonEdit && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3 mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          className: "w-full p-2 border border-border rounded h-64 font-mono text-sm",
          value: jsonValue,
          onChange: (e) => setJsonValue(e.target.value),
          placeholder: '{"visibility":{"hero":true,"features":true},"labels":{"featuresBadges":true}}'
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "button text-xs", onClick: applyJson, children: "Apply JSON" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "button-secondary text-xs", onClick: () => setJsonEdit(false), children: "Cancel" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Visibility Settings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground mb-4", children: "Control which sections are displayed on your website." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: [
        "hero",
        "features",
        "pricing",
        "cta",
        "waitlist",
        "header",
        "footer"
      ].map((section) => {
        var _a;
        const isVisible = ((_a = settings2 == null ? void 0 : settings2.visibility) == null ? void 0 : _a[section]) !== false;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleSwitch,
          {
            id: `${section}-visibility`,
            label: `${section} Section`,
            checked: isVisible,
            onChange: (checked) => updateSettingsVisibility(section, checked)
          },
          section
        );
      }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Label/Badge Settings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground mb-2", children: "Toggle badges and labels per section." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: [
        { key: "featuresBadges", label: "Features Badges" },
        { key: "pricingBadges", label: "Pricing Popular Badge" },
        { key: "heroBadges", label: "Hero Labels/Badges" },
        { key: "productBadges", label: "Product Page Badges" },
        { key: "ctaBadges", label: "CTA Labels/Badges" }
      ].map(({ key, label }) => {
        var _a;
        const enabled = ((_a = settings2 == null ? void 0 : settings2.labels) == null ? void 0 : _a[key]) ?? true;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleSwitch,
          {
            id: `labels-${key}`,
            label,
            checked: enabled,
            onChange: (checked) => {
              updateSettingsVisibility(`labels.${key}`, checked);
            }
          },
          key
        );
      }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Label/Badge Settings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground mb-2", children: "Toggle badges and labels per section." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: [
        { key: "featuresBadges", label: "Features Badges" },
        { key: "pricingBadges", label: "Pricing Popular Badge" }
      ].map(({ key, label }) => {
        var _a;
        const enabled = ((_a = settings2 == null ? void 0 : settings2.labels) == null ? void 0 : _a[key]) ?? true;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleSwitch,
          {
            id: `labels-${key}`,
            label,
            checked: enabled,
            onChange: (checked) => {
              updateSettingsVisibility(`labels.${key}`, checked);
            }
          },
          key
        );
      }) })
    ] })
  ] });
};
const LLMSectionEditor = ({
  llmContent,
  updateNestedField,
  countWords,
  getWordStatus
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg mb-2", children: "LLM Optimization Settings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-blue-900 mb-2", children: " LLM Citation Priority List" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "text-sm text-blue-800 space-y-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "1. Expert quote (+41% citation lift)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "2. Dated stat (+30% citation boost)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "3. FAQ/HowTo schema (Copilot reads verbatim)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "4. Answer box under H1 (40-70 words)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: '5. Fresh "Updated" timestamp' }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "6. Community echo on Reddit (~47% of Perplexity answers)" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-200 rounded-lg p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium mb-3", children: " Answer Box (Feature Snippet)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium", children: "40-70 Word Summary" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: (llmContent == null ? void 0 : llmContent.answerBox) || "",
            onChange: (e) => updateNestedField("llm", null, "answerBox", e.target.value),
            className: "w-full p-3 border border-border rounded-lg h-24 text-sm",
            placeholder: "Write a 40-70 word summary that answers the main question about your product..."
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500 mt-1", children: "Optimal for LLM feature snippets. Keep between 40-70 words for maximum citation potential." })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-200 rounded-lg p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium mb-3", children: " Expert Quote (+41% Citation Lift)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-1", children: "Quote" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              value: ((_a = llmContent == null ? void 0 : llmContent.expertQuote) == null ? void 0 : _a.quote) || "",
              onChange: (e) => {
                const currentQuote = (llmContent == null ? void 0 : llmContent.expertQuote) || {};
                updateNestedField("llm", null, "expertQuote", { ...currentQuote, quote: e.target.value });
              },
              className: "w-full p-2 border border-border rounded text-sm h-20",
              placeholder: "Expert opinion or insight about your industry/product..."
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: "Expert Name",
              value: ((_b = llmContent == null ? void 0 : llmContent.expertQuote) == null ? void 0 : _b.expertName) || "",
              onChange: (value) => {
                const currentQuote = (llmContent == null ? void 0 : llmContent.expertQuote) || {};
                updateNestedField("llm", null, "expertQuote", { ...currentQuote, expertName: value });
              },
              placeholder: "Dr. Jane Smith"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: "Title",
              value: ((_c = llmContent == null ? void 0 : llmContent.expertQuote) == null ? void 0 : _c.expertTitle) || "",
              onChange: (value) => {
                const currentQuote = (llmContent == null ? void 0 : llmContent.expertQuote) || {};
                updateNestedField("llm", null, "expertQuote", { ...currentQuote, expertTitle: value });
              },
              placeholder: "Director of Design Technology"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextInput,
          {
            label: "Institution",
            value: ((_d = llmContent == null ? void 0 : llmContent.expertQuote) == null ? void 0 : _d.institution) || "",
            onChange: (value) => {
              const currentQuote = (llmContent == null ? void 0 : llmContent.expertQuote) || {};
              updateNestedField("llm", null, "expertQuote", { ...currentQuote, institution: value });
            },
            placeholder: "Stanford University, MIT, etc."
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-200 rounded-lg p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium mb-3", children: " Fresh Statistics (+30% Citation Boost)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: "Statistic",
              value: ((_e = llmContent == null ? void 0 : llmContent.statistic) == null ? void 0 : _e.statistic) || "",
              onChange: (value) => {
                const currentStat = (llmContent == null ? void 0 : llmContent.statistic) || {};
                updateNestedField("llm", null, "statistic", { ...currentStat, statistic: value });
              },
              placeholder: "73%, 2.5x, $1.2M, etc."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: "Date",
              value: ((_f = llmContent == null ? void 0 : llmContent.statistic) == null ? void 0 : _f.date) || "",
              onChange: (value) => {
                const currentStat = (llmContent == null ? void 0 : llmContent.statistic) || {};
                updateNestedField("llm", null, "statistic", { ...currentStat, date: value });
              },
              placeholder: "January 2024"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextArea,
          {
            label: "Description",
            value: ((_g = llmContent == null ? void 0 : llmContent.statistic) == null ? void 0 : _g.description) || "",
            onChange: (value) => {
              const currentStat = (llmContent == null ? void 0 : llmContent.statistic) || {};
              updateNestedField("llm", null, "statistic", { ...currentStat, description: value });
            },
            placeholder: "of design teams report improved workflow efficiency...",
            rows: 2
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextInput,
          {
            label: "Source",
            value: ((_h = llmContent == null ? void 0 : llmContent.statistic) == null ? void 0 : _h.source) || "",
            onChange: (value) => {
              const currentStat = (llmContent == null ? void 0 : llmContent.statistic) || {};
              updateNestedField("llm", null, "statistic", { ...currentStat, source: value });
            },
            placeholder: "Design Systems Survey 2024, McKinsey Report, etc."
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-200 rounded-lg p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium mb-3", children: " FAQ Schema (Copilot Reads Verbatim)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        ((llmContent == null ? void 0 : llmContent.faqs) || []).map((faq, index) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-100 rounded p-3 bg-gray-50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-medium", children: [
                "FAQ #",
                index + 1
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => {
                    const currentFaqs = (llmContent == null ? void 0 : llmContent.faqs) || [];
                    const updatedFaqs = currentFaqs.filter((_, i) => i !== index);
                    updateNestedField("llm", null, "faqs", updatedFaqs);
                  },
                  className: "text-red-600 hover:text-red-800 text-sm",
                  children: "Remove"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextInput,
                {
                  label: "Question",
                  value: faq.question,
                  onChange: (value) => {
                    const currentFaqs = [...(llmContent == null ? void 0 : llmContent.faqs) || []];
                    currentFaqs[index] = { ...currentFaqs[index], question: value };
                    updateNestedField("llm", null, "faqs", currentFaqs);
                  },
                  placeholder: "How does..."
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextArea,
                {
                  label: "Answer",
                  value: faq.answer,
                  onChange: (value) => {
                    const currentFaqs = [...(llmContent == null ? void 0 : llmContent.faqs) || []];
                    currentFaqs[index] = { ...currentFaqs[index], answer: value };
                    updateNestedField("llm", null, "faqs", currentFaqs);
                  },
                  placeholder: "Our platform...",
                  rows: 2
                }
              )
            ] })
          ] }, index);
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => {
              const currentFaqs = (llmContent == null ? void 0 : llmContent.faqs) || [];
              const newFaq = { question: "", answer: "" };
              updateNestedField("llm", null, "faqs", [...currentFaqs, newFaq]);
            },
            className: "w-full p-2 border-2 border-dashed border-gray-300 rounded text-sm text-gray-600 hover:border-gray-400 hover:text-gray-800 transition-colors",
            children: "+ Add FAQ Item"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 border border-gray-200 rounded-lg p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium mb-3", children: " Content Optimization Tips" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "text-sm space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Keep paragraphs  300 tokens (~1200 characters)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Break with H2 every ~250 words for vector chunks" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Avoid hard-sell CTAs in quotable content" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Include updated timestamps on all content" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: " Seed Reddit/Stack Overflow discussions for community echo" })
      ] })
    ] })
  ] });
};
const ColorPreview = ({ color }) => {
  if (color.startsWith("#")) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "w-4 h-4 rounded border",
        style: { backgroundColor: color },
        title: `Color: ${color}`
      }
    );
  }
  const colorClass = {
    green: "bg-green-100 text-green-800 border border-green-200",
    blue: "bg-blue-100 text-blue-800 border border-blue-200",
    orange: "bg-orange-100 text-orange-800 border border-orange-200",
    purple: "bg-purple-100 text-purple-800 border border-purple-200",
    red: "bg-red-100 text-red-800 border border-red-200",
    yellow: "bg-yellow-100 text-yellow-800 border border-yellow-200",
    pink: "bg-pink-100 text-pink-800 border border-pink-200",
    gray: "bg-gray-100 text-gray-800 border border-gray-200"
  }[color] || "bg-primary text-primary-foreground";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-xs px-1 py-0.5 rounded ${colorClass}`, children: color });
};
const FeaturesSectionEditor = ({
  features: features2,
  updateNestedField,
  visible,
  updateVisibility,
  updateSection,
  sectionData
}) => {
  const normalizeFeatureItem = React.useCallback((raw) => {
    const item = { ...raw || {} };
    if (item.badge_color && !item.badgeColor) item.badgeColor = item.badge_color;
    if (item.is_featured !== void 0 && item.isFeatured === void 0) item.isFeatured = !!item.is_featured;
    if (item.button_text && !item.buttonText) item.buttonText = item.button_text;
    if (item.button_link && !item.buttonLink) item.buttonLink = item.button_link;
    if (item.product_slug && !item.productSlug) item.productSlug = item.product_slug;
    if (item.top_items && !item.topItems) item.topItems = item.top_items;
    if (item.top3 && !item.topItems && Array.isArray(item.top3)) item.topItems = item.top3;
    if (item.ideaText && !item.idea) item.idea = item.ideaText;
    if (item.tagline && !item.idea) item.idea = item.tagline;
    if (item.show_badge !== void 0 && item.showBadge === void 0) item.showBadge = !!item.show_badge;
    if (typeof item.productSlug === "string") {
      item.productSlug = item.productSlug.replace(/^\/+/, "");
    }
    if (!Array.isArray(item.topItems)) item.topItems = Array.isArray(item.top_items) ? item.top_items : Array.isArray(item.top3) ? item.top3 : [];
    if (!Array.isArray(item.badges)) item.badges = Array.isArray(item.badges) ? item.badges : [];
    return item;
  }, []);
  const [jsonEdit, setJsonEdit] = React.useState(false);
  const [jsonValue, setJsonValue] = React.useState(
    JSON.stringify({ section: sectionData || {}, items: features2 || [], visible }, null, 2)
  );
  const [normalizedFeatures, setNormalizedFeatures] = React.useState(
    () => (features2 || []).map(normalizeFeatureItem)
  );
  const [localSectionData, setLocalSectionData] = React.useState(() => sectionData || {});
  const isActivelyEditing = React.useRef(false);
  const lastPropUpdate = React.useRef(Date.now());
  React.useEffect(() => {
    const now = Date.now();
    const timeSinceLastUpdate = now - lastPropUpdate.current;
    if (normalizedFeatures.length === 0 || timeSinceLastUpdate > 1e3 && !isActivelyEditing.current) {
      const newNormalized = (features2 || []).map(normalizeFeatureItem);
      setNormalizedFeatures(newNormalized);
      lastPropUpdate.current = now;
    }
  }, [features2, normalizeFeatureItem, normalizedFeatures.length]);
  React.useEffect(() => {
    if (Object.keys(localSectionData).length === 0) {
      setLocalSectionData(sectionData || {});
    }
  }, [sectionData]);
  const updateFeatureField = React.useCallback((index, field, value) => {
    console.log(`[Features] Updating feature ${index}, field: ${field}, value:`, value);
    isActivelyEditing.current = true;
    const updatedFeatures = [...normalizedFeatures];
    updatedFeatures[index] = { ...updatedFeatures[index], [field]: value };
    setNormalizedFeatures(updatedFeatures);
    console.log(`[Features] Updated local state for feature ${index}:`, updatedFeatures[index]);
    updateNestedField("features", index, field, value);
    setTimeout(() => {
      isActivelyEditing.current = false;
    }, 2e3);
  }, [normalizedFeatures, updateNestedField]);
  const updateSectionField = React.useCallback((field, value) => {
    isActivelyEditing.current = true;
    const updatedSection = { ...localSectionData, [field]: value };
    setLocalSectionData(updatedSection);
    updateNestedField("featuresSection", null, field, value);
    setTimeout(() => {
      isActivelyEditing.current = false;
    }, 2e3);
  }, [localSectionData, updateNestedField]);
  const moveFeature = React.useCallback((fromIndex, toIndex) => {
    const list = normalizedFeatures || [];
    if (fromIndex === toIndex) return;
    if (toIndex < 0 || toIndex >= list.length) return;
    isActivelyEditing.current = true;
    const next = [...list];
    const [moved] = next.splice(fromIndex, 1);
    next.splice(toIndex, 0, moved);
    updateSection("features", next);
    setNormalizedFeatures(next);
    setTimeout(() => {
      isActivelyEditing.current = false;
    }, 2e3);
  }, [normalizedFeatures, updateSection]);
  const handleDragStart = (e, index) => {
    e.dataTransfer.setData("text/plain", String(index));
    e.dataTransfer.effectAllowed = "move";
  };
  const handleDropOnCard = (e, dropIndex) => {
    e.preventDefault();
    const from = parseInt(e.dataTransfer.getData("text/plain"), 10);
    if (!Number.isNaN(from)) {
      moveFeature(from, dropIndex);
    }
  };
  React.useEffect(() => {
    const payload = { section: localSectionData || {}, items: normalizedFeatures || [], visible };
    setJsonValue(JSON.stringify(payload, null, 2));
    debugService.contentUpdate("Features.useEffect: sync jsonValue from local state", payload);
    try {
      window.__FEATURES_SYNC__ = payload;
      console.log("[Features.useEffect] sync payload", payload);
    } catch {
    }
  }, [normalizedFeatures, localSectionData, visible]);
  const applyJson = () => {
    const wasEditing2 = isActivelyEditing.current;
    try {
      isActivelyEditing.current = false;
      const parsed = JSON.parse(jsonValue);
      debugService.contentUpdate("Features.applyJson: parsed", parsed);
      try {
        window.__FEATURES_PARSED__ = parsed;
        console.log("[Features.applyJson] parsed", parsed);
      } catch {
      }
      let finalFeatures = normalizedFeatures;
      let finalSection = localSectionData || {};
      let nextVisible = visible;
      if (Array.isArray(parsed)) {
        const normalizedArray = parsed.map(normalizeFeatureItem);
        updateSection("features", normalizedArray);
        setNormalizedFeatures(normalizedArray);
        finalFeatures = normalizedArray;
        const nextPayload = { section: finalSection, items: normalizedArray, visible };
        setJsonValue(JSON.stringify(nextPayload, null, 2));
        debugService.contentUpdate("Features.applyJson: applied array", nextPayload);
        try {
          window.__FEATURES_APPLY__ = nextPayload;
          console.log("[Features.applyJson] applied array", nextPayload);
        } catch {
        }
      } else if (parsed && typeof parsed === "object") {
        let nextFeatures;
        let nextSectionObj;
        const parsedAny = parsed;
        const featuresValue = parsedAny.features;
        const itemsValue = parsedAny.items;
        if (Array.isArray(itemsValue)) {
          nextFeatures = itemsValue;
        } else if (Array.isArray(featuresValue)) {
          nextFeatures = featuresValue;
        } else if (featuresValue && typeof featuresValue === "object" && Array.isArray(featuresValue.items)) {
          nextFeatures = featuresValue.items;
        } else if (Array.isArray(parsedAny)) {
          nextFeatures = parsedAny;
        }
        nextSectionObj = parsedAny.section || parsedAny.featuresSection;
        if (!nextSectionObj && featuresValue && typeof featuresValue === "object") {
          const maybeTitle = featuresValue.title;
          const maybeDesc = featuresValue.description;
          if (typeof maybeTitle === "string" || typeof maybeDesc === "string") {
            nextSectionObj = {
              ...typeof maybeTitle === "string" ? { title: maybeTitle } : {},
              ...typeof maybeDesc === "string" ? { description: maybeDesc } : {}
            };
          }
        }
        if (nextFeatures) {
          const normalizedList = nextFeatures.map(normalizeFeatureItem);
          updateSection("features", normalizedList);
          updateSection("features.items", normalizedList);
          setNormalizedFeatures(normalizedList);
          finalFeatures = normalizedList;
          debugService.contentUpdate("Features.applyJson: features updated", { count: normalizedList.length, first: normalizedList[0] });
          try {
            window.__FEATURES_NORMALIZED__ = normalizedList;
            console.log("[Features.applyJson] normalized first", normalizedList[0]);
          } catch {
          }
        }
        if (nextSectionObj && typeof nextSectionObj === "object") {
          updateSection("featuresSection", nextSectionObj);
          setLocalSectionData(nextSectionObj);
          finalSection = nextSectionObj;
          debugService.contentUpdate("Features.applyJson: featuresSection updated", nextSectionObj);
          try {
            window.__FEATURES_SECTION__ = nextSectionObj;
            console.log("[Features.applyJson] section", nextSectionObj);
          } catch {
          }
        }
        nextVisible = typeof parsedAny.visible === "boolean" ? Boolean(parsedAny.visible) : visible;
        if (typeof parsedAny.visible === "boolean") updateVisibility(nextVisible);
        const finalPayload = { section: finalSection, items: finalFeatures, visible: nextVisible };
        setJsonValue(JSON.stringify(finalPayload, null, 2));
        debugService.contentUpdate("Features.applyJson: final payload", finalPayload);
        try {
          window.__FEATURES_FINAL__ = finalPayload;
          console.log("[Features.applyJson] final payload", finalPayload);
        } catch {
        }
      }
      setJsonEdit(false);
      debugService.saveSuccess("Features.applyJson: done");
      setTimeout(() => {
        const refreshPayload = { section: finalSection, items: finalFeatures, visible: nextVisible };
        setJsonValue(JSON.stringify(refreshPayload, null, 2));
        setNormalizedFeatures([...finalFeatures]);
        setLocalSectionData({ ...finalSection });
        isActivelyEditing.current = wasEditing2;
      }, 50);
    } catch (error) {
      isActivelyEditing.current = wasEditing2;
      debugService.saveError("Features.applyJson: invalid JSON", jsonValue);
      alert("Invalid JSON. Please correct and try again.");
    }
  };
  if (jsonEdit) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Features Section  JSON Editor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "button-secondary text-xs", onClick: () => setJsonEdit(false), children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "button text-xs", onClick: applyJson, children: "Apply JSON" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          className: "w-full p-2 border border-border rounded h-64 font-mono text-sm",
          value: jsonValue,
          onChange: (e) => setJsonValue(e.target.value),
          placeholder: '{"section":{"title":"Features","description":"...","productPageLabel":"Visit product page","productPageLink":"/bibliokit-blocks"},"items":[{"icon":"","title":"","description":"","idea":"","topItems":["","",""],"badge":"","badgeColor":"green","badges":[],"isFeatured":false,"showBadge":true,"buttonPreset":"custom","buttonText":"","buttonLink":""}],"visible":true}'
        }
      )
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Features Section" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "px-3 py-1 text-sm rounded border border-border hover:bg-muted",
            onClick: () => setJsonEdit(true),
            "aria-label": "Edit section JSON",
            children: "Edit JSON"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "px-3 py-1 text-sm rounded border border-border hover:bg-muted",
            onClick: () => {
              isActivelyEditing.current = true;
              const newFeature = {
                icon: "",
                title: "New Feature",
                description: "Description",
                idea: "",
                topItems: ["", "", ""],
                badge: "",
                badgeColor: "green",
                badges: [],
                isFeatured: false,
                showBadge: true,
                buttonPreset: "custom",
                buttonText: "",
                buttonLink: ""
              };
              const updated = [...normalizedFeatures || [], newFeature];
              updateSection("features", updated);
              setNormalizedFeatures(updated);
              setTimeout(() => {
                isActivelyEditing.current = false;
              }, 2e3);
            },
            "aria-label": "Add feature",
            children: "+ Add Feature"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Section Title" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: (localSectionData == null ? void 0 : localSectionData.title) || "",
            onChange: (e) => updateSectionField("title", e.target.value),
            className: "w-full p-2 border border-border rounded",
            placeholder: "Features",
            "aria-label": "Features section title"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Section Description" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: (localSectionData == null ? void 0 : localSectionData.description) || "",
            onChange: (e) => updateSectionField("description", e.target.value),
            className: "w-full p-2 border border-border rounded h-20",
            placeholder: "Brief description of the features section",
            "aria-label": "Features section description"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Product Page CTA Label" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: (localSectionData == null ? void 0 : localSectionData.productPageLabel) || "",
              onChange: (e) => updateSectionField("productPageLabel", e.target.value),
              className: "w-full p-2 border border-border rounded",
              placeholder: "Visit product page",
              "aria-label": "Product page CTA label"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Product Page Link or Slug" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: (localSectionData == null ? void 0 : localSectionData.productPageLink) || "",
              onChange: (e) => updateSectionField("productPageLink", e.target.value),
              className: "w-full p-2 border border-border rounded",
              placeholder: "/bibliokit-blocks or https://example.com/product",
              "aria-label": "Product page link"
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-4 p-3 bg-muted/20 rounded-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          id: "features-visible",
          type: "checkbox",
          checked: visible,
          onChange: (e) => updateVisibility(e.target.checked),
          className: "rounded border-border"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "features-visible", className: "text-sm font-medium", children: "Visible on site" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: normalizedFeatures == null ? void 0 : normalizedFeatures.map((feature, index) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `p-3 border rounded ${feature.isFeatured ? "border-primary/30 bg-primary/5" : "border-border"}`,
          onDragOver: (e) => e.preventDefault(),
          onDrop: (e) => handleDropOnCard(e, index),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", "aria-label": `Reorder feature ${index + 1}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      className: "px-2 py-1 text-xs rounded border border-border hover:bg-muted disabled:opacity-50",
                      onClick: () => moveFeature(index, index - 1),
                      disabled: index === 0,
                      "aria-label": "Move up",
                      children: ""
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      className: "px-2 py-1 text-xs rounded border border-border hover:bg-muted disabled:opacity-50",
                      onClick: () => moveFeature(index, index + 1),
                      disabled: index === ((normalizedFeatures == null ? void 0 : normalizedFeatures.length) || 0) - 1,
                      "aria-label": "Move down",
                      children: ""
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      className: "px-2 py-1 text-xs rounded border border-border hover:bg-muted cursor-move",
                      draggable: true,
                      onDragStart: (e) => handleDragStart(e, index),
                      "aria-label": "Drag to reorder",
                      title: "Drag to reorder",
                      children: ""
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "checkbox",
                      checked: !!feature.isFeatured,
                      onChange: (e) => updateFeatureField(index, "isFeatured", e.target.checked),
                      className: "rounded border-border"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: "Featured Card" })
                ] }),
                feature.isFeatured && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs px-2 py-1 bg-primary text-primary-foreground rounded-full", children: "FEATURED" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-xs",
                  onClick: () => {
                    isActivelyEditing.current = true;
                    const updated = (normalizedFeatures || []).filter((_, i) => i !== index);
                    updateSection("features", updated);
                    setNormalizedFeatures(updated);
                    setTimeout(() => {
                      isActivelyEditing.current = false;
                    }, 2e3);
                  },
                  "aria-label": `Remove feature ${index + 1}`,
                  children: "Remove"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-6 gap-2 text-sm mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Icon" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    value: feature.icon,
                    onChange: (e) => updateFeatureField(index, "icon", e.target.value),
                    className: "p-1 border border-border rounded w-full",
                    placeholder: "Icon"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Title" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    value: feature.title,
                    onChange: (e) => updateFeatureField(index, "title", e.target.value),
                    className: "p-1 border border-border rounded w-full",
                    placeholder: "Title"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Badge" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    value: feature.badge,
                    onChange: (e) => updateFeatureField(index, "badge", e.target.value),
                    className: "p-1 border border-border rounded w-full",
                    placeholder: "e.g. New, Coming Soon"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Badge Color" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      value: feature.badgeColor || "",
                      onChange: (e) => updateFeatureField(index, "badgeColor", e.target.value),
                      className: "p-1 border border-border rounded flex-1",
                      placeholder: "#10b981 or green"
                    }
                  ),
                  feature.badgeColor && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ColorPreview, { color: feature.badgeColor }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-muted-foreground mt-1", children: "Use hex (#10b981) or predefined (green, blue, orange, etc.)" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium", children: "Badges" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "text-xs px-2 py-1 rounded border border-border hover:bg-muted",
                    onClick: () => {
                      const next = [...feature.badges || [], { label: "Badge", type: "custom", color: "green" }];
                      updateFeatureField(index, "badges", next);
                    },
                    "aria-label": `Add badge to feature ${index + 1}`,
                    children: "+ Add Badge"
                  }
                )
              ] }),
              (feature.badges || []).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2 mt-2", children: (feature.badges || []).map((b, bi) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-6 gap-2 text-sm items-end", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Label" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      value: b.label,
                      onChange: (e) => {
                        const next = [...feature.badges || []];
                        next[bi] = { ...next[bi], label: e.target.value };
                        updateFeatureField(index, "badges", next);
                      },
                      className: "p-1 border border-border rounded w-full",
                      placeholder: "e.g. Figma, SaaS"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Type" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "select",
                    {
                      value: b.type || "custom",
                      onChange: (e) => {
                        const next = [...feature.badges || []];
                        next[bi] = { ...next[bi], type: e.target.value };
                        updateFeatureField(index, "badges", next);
                      },
                      className: "p-1 border border-border rounded w-full",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "custom", children: "Custom" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "figma", children: "Figma" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "saas", children: "SaaS" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Color" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "text",
                        value: b.color || "",
                        onChange: (e) => {
                          const next = [...feature.badges || []];
                          next[bi] = { ...next[bi], color: e.target.value };
                          updateFeatureField(index, "badges", next);
                        },
                        className: "p-1 border border-border rounded w-full",
                        placeholder: "#10b981 or green"
                      }
                    ),
                    b.color && /* @__PURE__ */ jsxRuntimeExports.jsx(ColorPreview, { color: b.color })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-xs",
                    onClick: () => {
                      const next = (feature.badges || []).filter((_, i) => i !== bi);
                      updateFeatureField(index, "badges", next);
                    },
                    "aria-label": `Remove badge ${bi + 1}`,
                    children: "Remove"
                  }
                ) })
              ] }, bi)) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  checked: feature.showBadge !== false,
                  onChange: (e) => updateFeatureField(index, "showBadge", e.target.checked),
                  className: "rounded border-border"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: "Show Badge" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Description" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  value: feature.description,
                  onChange: (e) => updateFeatureField(index, "description", e.target.value),
                  className: "p-1 border border-border rounded h-16 text-xs w-full",
                  placeholder: "Description"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Idea / Tagline" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: feature.idea || "",
                  onChange: (e) => updateFeatureField(index, "idea", e.target.value),
                  className: "p-1 border border-border rounded w-full text-sm",
                  placeholder: "Short idea or tagline shown inside the card",
                  "aria-label": "Feature idea or tagline"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-2", children: "Key Features (bullets)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: [0, 1, 2].map((i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: (feature.topItems || [])[i] || "",
                  onChange: (e) => {
                    const arr = Array.isArray(feature.topItems) ? [...feature.topItems] : ["", "", ""];
                    arr[i] = e.target.value;
                    updateFeatureField(index, "topItems", arr);
                  },
                  className: "p-1 border border-border rounded w-full text-sm",
                  placeholder: `Bullet ${i + 1}`,
                  "aria-label": `Top feature bullet ${i + 1}`
                },
                i
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-border/50 pt-3 space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs font-medium text-primary", children: "Card Button" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-2 text-sm", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Preset" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "select",
                    {
                      value: feature.buttonPreset || "custom",
                      onChange: (e) => updateFeatureField(index, "buttonPreset", e.target.value),
                      className: "p-1 border border-border rounded w-full",
                      "aria-label": "Button preset",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "custom", children: "Custom" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "beta", children: "Sign Up for Beta" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Product Page Slug" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      value: feature.productSlug || "",
                      onChange: (e) => updateFeatureField(index, "productSlug", e.target.value),
                      className: "p-1 border border-border rounded w-full",
                      placeholder: "e.g. bibliokit-blocks (renders as /bibliokit-blocks)",
                      "aria-label": "Product page slug"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-2 text-sm", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Button Text" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      value: feature.buttonText || "",
                      onChange: (e) => updateFeatureField(index, "buttonText", e.target.value),
                      className: "p-1 border border-border rounded w-full",
                      placeholder: "e.g. Learn More, Visit product page",
                      "aria-label": "Button text"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Button Link" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      value: feature.buttonLink || "",
                      onChange: (e) => updateFeatureField(index, "buttonLink", e.target.value),
                      className: "p-1 border border-border rounded w-full",
                      placeholder: "/bibliokit-blocks or https://example.com",
                      "aria-label": "Button link"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-muted-foreground mt-1", children: "Button appears when text and link are provided." })
            ] })
          ]
        },
        index
      );
    }) })
  ] });
};
const PricingProductSectionEditor = ({
  activeSection,
  pricing: pricing2,
  product,
  updateNestedField,
  updateSection,
  setEditMode,
  pricingVisible,
  productVisible,
  updateVisibility
}) => {
  const [jsonEdit, setJsonEdit] = reactExports.useState(false);
  const [localJson, setLocalJson] = reactExports.useState(JSON.stringify(product || {}, null, 2));
  reactExports.useEffect(() => {
    if (product) {
      setLocalJson(JSON.stringify(product, null, 2));
    }
  }, [product]);
  if (activeSection === "pricing" && pricing2) {
    const isComingSoon = (pricing2 == null ? void 0 : pricing2.isComingSoon) !== false;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Pricing Plans" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setEditMode("json"), variant: "secondary", children: "Advanced Editor" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-4 p-3 bg-muted/20 rounded-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            id: "pricing-visible",
            type: "checkbox",
            checked: pricingVisible,
            onChange: (e) => updateVisibility("pricing", e.target.checked),
            className: "rounded border-border"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "pricing-visible", className: "text-sm font-medium", children: "Visible on site" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border border-border rounded-lg p-4 space-y-4 bg-muted/5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base mb-1", children: "Coming Soon Mode" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: 'Show "Coming Soon" message instead of pricing plans' })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "relative inline-flex items-center cursor-pointer", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: isComingSoon,
              onChange: (e) => updateSection("pricing", {
                ...pricing2,
                isComingSoon: e.target.checked
              }),
              className: "sr-only peer"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-primary/20 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary" })
        ] })
      ] }) }),
      !isComingSoon && Array.isArray(pricing2) && pricing2.map((plan, index) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "font-medium text-base", children: [
            plan.name,
            " Plan"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ButtonField,
            {
              label: "Plan Button",
              buttonText: plan.buttonText || "",
              buttonLink: plan.buttonLink || "",
              onTextChange: (value) => updateNestedField("pricing", index, "buttonText", value),
              onLinkChange: (value) => updateNestedField("pricing", index, "buttonLink", value)
            }
          )
        ] }, index);
      }),
      isComingSoon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border border-amber-200 bg-amber-50 rounded-lg p-4 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-amber-800", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium mb-2", children: "Coming Soon Mode Active" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm", children: 'Visitors will see a "Coming Soon" message instead of pricing plans. Toggle off to edit individual plans.' })
      ] }) })
    ] });
  }
  if (activeSection === "product" && product) {
    if (jsonEdit) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Product Details JSON Editor" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: () => setJsonEdit(false), children: "Cancel" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: localJson,
            onChange: (e) => setLocalJson(e.target.value),
            className: "w-full h-64 p-2 border border-border rounded font-mono text-sm"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => {
                try {
                  const parsed = JSON.parse(localJson);
                  updateSection("product", parsed);
                  setJsonEdit(false);
                  setTimeout(() => {
                    updateSection("product", { ...parsed });
                  }, 50);
                } catch {
                  alert("Invalid JSON. Please correct and try again.");
                }
              },
              children: "Save JSON"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: () => setJsonEdit(false), children: "Cancel" })
        ] })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Product Details" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: () => setJsonEdit(true), children: "Edit JSON" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-4 p-3 bg-muted/20 rounded-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            id: "product-visible",
            type: "checkbox",
            checked: productVisible,
            onChange: (e) => updateVisibility("product", e.target.checked),
            className: "rounded border-border"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "product-visible", className: "text-sm font-medium", children: "Visible on site" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "Buttons" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ButtonField,
            {
              label: "Primary Button",
              buttonText: product.primaryButton || "",
              buttonLink: product.primaryButtonLink || "",
              onTextChange: (value) => updateNestedField("product", null, "primaryButton", value),
              onLinkChange: (value) => updateNestedField("product", null, "primaryButtonLink", value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ButtonField,
            {
              label: "Secondary Button",
              buttonText: product.secondaryButton || "",
              buttonLink: product.secondaryButtonLink || "",
              onTextChange: (value) => updateNestedField("product", null, "secondaryButton", value),
              onLinkChange: (value) => updateNestedField("product", null, "secondaryButtonLink", value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "Key Features" }),
          (product.details || []).map((detail, index) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextInput,
                {
                  label: "Title",
                  value: detail.title,
                  onChange: (value) => {
                    const updated = [...product.details];
                    updated[index].title = value;
                    updateNestedField("product", null, "details", updated);
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextArea,
                {
                  label: "Description",
                  value: detail.description,
                  onChange: (value) => {
                    const updated = [...product.details];
                    updated[index].description = value;
                    updateNestedField("product", null, "details", updated);
                  },
                  rows: 3
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => {
                    const updated = product.details.filter((_, i) => i !== index);
                    updateNestedField("product", null, "details", updated);
                  },
                  className: "text-red-600 hover:text-red-800 text-sm",
                  children: "Remove Feature"
                }
              )
            ] }, index);
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                const newFeature = { title: "", description: "" };
                const updated = [...product.details || [], newFeature];
                updateNestedField("product", null, "details", updated);
              },
              className: "w-full p-2 border-2 border-dashed border-gray-300 rounded text-sm text-gray-600 hover:border-gray-400 hover:text-gray-800",
              children: "+ Add Feature"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "Use Cases" }),
          (product.benefits || []).map((benefit, index) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextArea,
                {
                  label: `Use Case ${index + 1}`,
                  value: benefit,
                  onChange: (value) => {
                    const updated = [...product.benefits];
                    updated[index] = value;
                    updateNestedField("product", null, "benefits", updated);
                  },
                  rows: 2
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => {
                    const updated = product.benefits.filter((_, i) => i !== index);
                    updateNestedField("product", null, "benefits", updated);
                  },
                  className: "text-red-600 hover:text-red-800 text-sm",
                  children: "Remove Use Case"
                }
              )
            ] }, index);
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                const updated = [...product.benefits || [], ""];
                updateNestedField("product", null, "benefits", updated);
              },
              className: "w-full p-2 border-2 border-dashed border-gray-300 rounded text-sm text-gray-600 hover:border-gray-400 hover:text-gray-800",
              children: "+ Add Use Case"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "Technical Capabilities" }),
          (product.specifications || []).map((spec, index) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextInput,
                  {
                    label: "Icon",
                    value: spec.icon,
                    onChange: (value) => {
                      const updated = [...product.specifications];
                      updated[index].icon = value;
                      updateNestedField("product", null, "specifications", updated);
                    },
                    placeholder: ""
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextInput,
                  {
                    label: "Name",
                    value: spec.name,
                    onChange: (value) => {
                      const updated = [...product.specifications];
                      updated[index].name = value;
                      updateNestedField("product", null, "specifications", updated);
                    },
                    placeholder: "Analytics Engine"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {})
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextArea,
                {
                  label: "Value/Description",
                  value: spec.value,
                  onChange: (value) => {
                    const updated = [...product.specifications];
                    updated[index].value = value;
                    updateNestedField("product", null, "specifications", updated);
                  },
                  rows: 2,
                  placeholder: "Real-time component tracking..."
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => {
                    const updated = product.specifications.filter((_, i) => i !== index);
                    updateNestedField("product", null, "specifications", updated);
                  },
                  className: "text-red-600 hover:text-red-800 text-sm",
                  children: "Remove Specification"
                }
              )
            ] }, index);
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                const newSpec = { icon: "", name: "", value: "" };
                const updated = [...product.specifications || [], newSpec];
                updateNestedField("product", null, "specifications", updated);
              },
              className: "w-full p-2 border-2 border-dashed border-gray-300 rounded text-sm text-gray-600 hover:border-gray-400 hover:text-gray-800",
              children: "+ Add Specification"
            }
          )
        ] })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: activeSection === "pricing" ? "Pricing Plans" : "Product Details" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-muted-foreground", children: [
      "For detailed ",
      activeSection,
      " editing, use the Advanced JSON Editor below."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setEditMode("json"), children: "Open Advanced Editor" })
  ] });
};
const IndividualProductEditor = ({
  productKey,
  productData: productData2,
  updateNestedField,
  updateSection,
  setEditMode
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U;
  const [jsonEdit, setJsonEdit] = reactExports.useState(false);
  const [localJson, setLocalJson] = reactExports.useState(JSON.stringify(productData2 || {}, null, 2));
  const [localProductData, setLocalProductData] = reactExports.useState(() => productData2 || {});
  const isActivelyEditing = React.useRef(false);
  const lastPropUpdate = React.useRef(Date.now());
  reactExports.useEffect(() => {
    if (productData2) {
      setLocalJson(JSON.stringify(productData2, null, 2));
    }
  }, [productData2]);
  React.useEffect(() => {
    const now = Date.now();
    const timeSinceLastUpdate = now - lastPropUpdate.current;
    if (Object.keys(localProductData).length === 0 || timeSinceLastUpdate > 1e3 && !isActivelyEditing.current) {
      setLocalProductData(productData2 || {});
      lastPropUpdate.current = now;
    }
  }, [productData2, localProductData]);
  const updateProductField = (field, value) => {
    isActivelyEditing.current = true;
    setLocalProductData((prev) => ({ ...prev, [field]: value }));
    updateNestedField(`products.${productKey}`, null, field, value);
    setTimeout(() => {
      isActivelyEditing.current = false;
    }, 2e3);
  };
  const updateProductNestedField = (field, index, subField, value) => {
    isActivelyEditing.current = true;
    if (index !== null) {
      const currentArray = localProductData[field] || [];
      const updated = currentArray.map(
        (item, i) => i === index ? { ...item, [subField]: value } : item
      );
      setLocalProductData((prev) => ({ ...prev, [field]: updated }));
      updateNestedField(`products.${productKey}`, null, field, updated);
    } else {
      const currentObj = localProductData[field] || {};
      const updatedObj = { ...currentObj, [subField]: value };
      setLocalProductData((prev) => ({ ...prev, [field]: updatedObj }));
      updateNestedField(`products.${productKey}`, null, field, updatedObj);
    }
    setTimeout(() => {
      isActivelyEditing.current = false;
    }, 2e3);
  };
  if (!productData2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-semibold text-lg", children: [
        productKey,
        " Product"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Product data not found. Please check the data structure." })
    ] });
  }
  if (jsonEdit) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-semibold text-lg", children: [
          productData2.title,
          " - JSON Editor"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: () => setJsonEdit(false), children: "Cancel" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          value: localJson,
          onChange: (e) => setLocalJson(e.target.value),
          className: "w-full h-64 p-2 border border-border rounded font-mono text-sm",
          placeholder: '{"title":"My Product","description":"...","primaryButton":"Get Started","primaryButtonLink":"/start","secondaryButton":"Learn More","secondaryButtonLink":"/learn","details":[{"title":"","description":""}],"benefits":[],"specifications":[],"pricing":{"price":"","period":"/month","description":"","buttonText":""},"visibility":{"waitlist":true},"llm":{"answerBox":"","expertQuote":{},"statistic":{},"faqs":[]}}'
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            onClick: () => {
              try {
                const wasEditing2 = isActivelyEditing.current;
                isActivelyEditing.current = false;
                const parsed = JSON.parse(localJson);
                updateSection(`products.${productKey}`, parsed);
                setLocalProductData(parsed);
                setJsonEdit(false);
                setTimeout(() => {
                  setLocalProductData({ ...parsed });
                  isActivelyEditing.current = wasEditing2;
                }, 50);
              } catch (error) {
                alert("Invalid JSON. Please correct and try again.");
              }
            },
            children: "Save JSON"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: () => setJsonEdit(false), children: "Cancel" })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: localProductData.title || productData2.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: () => setJsonEdit(true), children: "Edit JSON" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "1. Hero Section" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          label: "Emoji",
          value: localProductData.emoji || "",
          onChange: (value) => updateProductField("emoji", value),
          placeholder: "e.g. "
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          label: "Hero Badge Label",
          value: localProductData.badgeLabel || "",
          onChange: (value) => updateProductField("badgeLabel", value),
          placeholder: "SaaS Analytics Platform"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium", children: "Hero Gradient Colors (comma-separated hex)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: (localProductData.gradientColors || []).join(", "),
            onChange: (e) => updateProductField("gradientColors", e.target.value.split(",").map((v) => v.trim()).filter(Boolean)),
            className: "w-full p-2 border border-border rounded",
            placeholder: "#ecfeff00, #ecfeff10, #c7d2fe40, #a7f3d040, #a5b4fc50, #93c5fd40, #ffffff00"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-muted-foreground", children: "Provide 58 RGBA/hex values with alpha for best effect." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          label: "Title",
          value: localProductData.title || "",
          onChange: (value) => updateProductField("title", value)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextArea,
        {
          label: "Description",
          value: localProductData.description || "",
          onChange: (value) => updateProductField("description", value),
          rows: 3
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextArea,
        {
          label: "Answer Box (appears directly under title)",
          value: ((_a = localProductData.llm) == null ? void 0 : _a.answerBox) || "",
          onChange: (value) => updateProductNestedField("llm", null, "answerBox", value),
          rows: 3,
          placeholder: "Brief description for LLM optimization (40-70 words)"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonField,
          {
            label: "Primary Button",
            buttonText: localProductData.primaryButton || "",
            buttonLink: localProductData.primaryButtonLink || "",
            onTextChange: (value) => updateProductField("primaryButton", value),
            onLinkChange: (value) => updateProductField("primaryButtonLink", value)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonField,
          {
            label: "Secondary Button",
            buttonText: localProductData.secondaryButton || "",
            buttonLink: localProductData.secondaryButtonLink || "",
            onTextChange: (value) => updateProductField("secondaryButton", value),
            onLinkChange: (value) => updateProductField("secondaryButtonLink", value)
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "2. Expert Quote Section (Optional)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextArea,
          {
            label: "Quote",
            value: ((_c = (_b = localProductData.llm) == null ? void 0 : _b.expertQuote) == null ? void 0 : _c.quote) || "",
            onChange: (value) => {
              var _a2;
              const current = ((_a2 = localProductData.llm) == null ? void 0 : _a2.expertQuote) || {};
              updateProductNestedField("llm", null, "expertQuote", { ...current, quote: value });
            },
            rows: 2,
            placeholder: "Compelling industry quote or statistic"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: "Expert Name",
              value: ((_e = (_d = localProductData.llm) == null ? void 0 : _d.expertQuote) == null ? void 0 : _e.expertName) || "",
              onChange: (value) => {
                var _a2;
                const current = ((_a2 = localProductData.llm) == null ? void 0 : _a2.expertQuote) || {};
                updateProductNestedField("llm", null, "expertQuote", { ...current, expertName: value });
              },
              placeholder: "John Doe"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: "Expert Title",
              value: ((_g = (_f = localProductData.llm) == null ? void 0 : _f.expertQuote) == null ? void 0 : _g.expertTitle) || "",
              onChange: (value) => {
                var _a2;
                const current = ((_a2 = localProductData.llm) == null ? void 0 : _a2.expertQuote) || {};
                updateProductNestedField("llm", null, "expertQuote", { ...current, expertTitle: value });
              },
              placeholder: "Design System Expert"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextInput,
          {
            label: "Institution",
            value: ((_i = (_h = localProductData.llm) == null ? void 0 : _h.expertQuote) == null ? void 0 : _i.institution) || "",
            onChange: (value) => {
              var _a2;
              const current = ((_a2 = localProductData.llm) == null ? void 0 : _a2.expertQuote) || {};
              updateProductNestedField("llm", null, "expertQuote", { ...current, institution: value });
            },
            placeholder: "Company or Publication Name"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "3. Statistic Section (Optional)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: "Statistic",
              value: ((_k = (_j = localProductData.llm) == null ? void 0 : _j.statistic) == null ? void 0 : _k.statistic) || "",
              onChange: (value) => {
                var _a2;
                const current = ((_a2 = localProductData.llm) == null ? void 0 : _a2.statistic) || {};
                updateProductNestedField("llm", null, "statistic", { ...current, statistic: value });
              },
              placeholder: "85%"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: "Date",
              value: ((_m = (_l = localProductData.llm) == null ? void 0 : _l.statistic) == null ? void 0 : _m.date) || "",
              onChange: (value) => {
                var _a2;
                const current = ((_a2 = localProductData.llm) == null ? void 0 : _a2.statistic) || {};
                updateProductNestedField("llm", null, "statistic", { ...current, date: value });
              },
              placeholder: "February 2024"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextArea,
          {
            label: "Description",
            value: ((_o = (_n = localProductData.llm) == null ? void 0 : _n.statistic) == null ? void 0 : _o.description) || "",
            onChange: (value) => {
              var _a2;
              const current = ((_a2 = localProductData.llm) == null ? void 0 : _a2.statistic) || {};
              updateProductNestedField("llm", null, "statistic", { ...current, description: value });
            },
            rows: 2,
            placeholder: "Brief explanation of the statistic"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextInput,
          {
            label: "Source",
            value: ((_q = (_p = localProductData.llm) == null ? void 0 : _p.statistic) == null ? void 0 : _q.source) || "",
            onChange: (value) => {
              var _a2;
              const current = ((_a2 = localProductData.llm) == null ? void 0 : _a2.statistic) || {};
              updateProductNestedField("llm", null, "statistic", { ...current, source: value });
            },
            placeholder: "Report or Study Name"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "4. Key Features Section" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          label: "Section Title",
          value: ((_s = (_r = productData2 == null ? void 0 : productData2.sections) == null ? void 0 : _r.features) == null ? void 0 : _s.title) || "",
          onChange: (value) => {
            const next = { ...productData2.sections || {}, features: { ...(productData2.sections || {}).features || {}, title: value } };
            updateProductField("sections", next);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextArea,
        {
          label: "Section Description",
          value: ((_u = (_t = productData2 == null ? void 0 : productData2.sections) == null ? void 0 : _t.features) == null ? void 0 : _u.description) || "",
          onChange: (value) => {
            const next = { ...productData2.sections || {}, features: { ...(productData2.sections || {}).features || {}, description: value } };
            updateProductField("sections", next);
          },
          rows: 2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-1", children: "Columns" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "select",
          {
            value: String(((_w = (_v = localProductData == null ? void 0 : localProductData.sections) == null ? void 0 : _v.features) == null ? void 0 : _w.columns) ?? ""),
            onChange: (e) => {
              const value = e.target.value;
              const safe = value === "" ? void 0 : Math.min(4, Math.max(1, parseInt(value, 10)));
              const next = {
                ...productData2.sections || {},
                features: {
                  ...(productData2.sections || {}).features || {},
                  ...typeof safe === "number" ? { columns: safe } : {}
                }
              };
              if (typeof safe !== "number") {
                if (next.features && "columns" in next.features) delete next.features.columns;
              }
              updateProductField("sections", next);
            },
            className: "w-full p-2 border border-border rounded",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Auto (by count)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "1", children: "1" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "2", children: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "3", children: "3" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "4", children: "4" })
            ]
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "Key Features Items" }),
      (localProductData.details || []).map((detail, index) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: "Title",
              value: detail.title,
              onChange: (value) => updateProductNestedField("details", index, "title", value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextArea,
            {
              label: "Description",
              value: detail.description,
              onChange: (value) => updateProductNestedField("details", index, "description", value),
              rows: 3
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                const updated = productData2.details.filter((_, i) => i !== index);
                updateProductField("details", updated);
              },
              className: "text-red-600 hover:text-red-800 text-sm",
              children: "Remove Feature"
            }
          )
        ] }, index);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => {
            const newFeature = { title: "", description: "" };
            const updated = [...productData2.details || [], newFeature];
            updateProductField("details", updated);
          },
          className: "w-full p-2 border-2 border-dashed border-gray-300 rounded text-sm text-gray-600 hover:border-gray-400 hover:text-gray-800",
          children: "+ Add Feature"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "5. Use Cases Section" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          label: "Section Title",
          value: ((_y = (_x = productData2 == null ? void 0 : productData2.sections) == null ? void 0 : _x.useCases) == null ? void 0 : _y.title) || "",
          onChange: (value) => {
            const next = { ...productData2.sections || {}, useCases: { ...(productData2.sections || {}).useCases || {}, title: value } };
            updateProductField("sections", next);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextArea,
        {
          label: "Section Description",
          value: ((_A = (_z = productData2 == null ? void 0 : productData2.sections) == null ? void 0 : _z.useCases) == null ? void 0 : _A.description) || "",
          onChange: (value) => {
            const next = { ...productData2.sections || {}, useCases: { ...(productData2.sections || {}).useCases || {}, description: value } };
            updateProductField("sections", next);
          },
          rows: 2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-1", children: "Columns (default 2)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "select",
          {
            value: String(((_C = (_B = localProductData == null ? void 0 : localProductData.sections) == null ? void 0 : _B.useCases) == null ? void 0 : _C.columns) ?? 2),
            onChange: (e) => {
              const safe = Math.min(4, Math.max(1, parseInt(e.target.value, 10)));
              const next = {
                ...productData2.sections || {},
                useCases: {
                  ...(productData2.sections || {}).useCases || {},
                  columns: safe
                }
              };
              updateProductField("sections", next);
            },
            className: "w-full p-2 border border-border rounded",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "1", children: "1" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "2", children: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "3", children: "3" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "4", children: "4" })
            ]
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "Use Cases Items" }),
      (localProductData.benefits || []).map((benefit, index) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextArea,
            {
              label: `Use Case ${index + 1}`,
              value: benefit,
              onChange: (value) => {
                const updated = [...productData2.benefits];
                updated[index] = value;
                updateProductField("benefits", updated);
              },
              rows: 2
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                const updated = productData2.benefits.filter((_, i) => i !== index);
                updateProductField("benefits", updated);
              },
              className: "text-red-600 hover:text-red-800 text-sm",
              children: "Remove Use Case"
            }
          )
        ] }, index);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => {
            const updated = [...productData2.benefits || [], ""];
            updateProductField("benefits", updated);
          },
          className: "w-full p-2 border-2 border-dashed border-gray-300 rounded text-sm text-gray-600 hover:border-gray-400 hover:text-gray-800",
          children: "+ Add Use Case"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "6. Technical Capabilities Section" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          label: "Section Title",
          value: ((_E = (_D = productData2 == null ? void 0 : productData2.sections) == null ? void 0 : _D.specifications) == null ? void 0 : _E.title) || "",
          onChange: (value) => {
            const next = { ...productData2.sections || {}, specifications: { ...(productData2.sections || {}).specifications || {}, title: value } };
            updateProductField("sections", next);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextArea,
        {
          label: "Section Description",
          value: ((_G = (_F = productData2 == null ? void 0 : productData2.sections) == null ? void 0 : _F.specifications) == null ? void 0 : _G.description) || "",
          onChange: (value) => {
            const next = { ...productData2.sections || {}, specifications: { ...(productData2.sections || {}).specifications || {}, description: value } };
            updateProductField("sections", next);
          },
          rows: 2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-1", children: "Columns" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "select",
          {
            value: String(((_I = (_H = localProductData == null ? void 0 : localProductData.sections) == null ? void 0 : _H.specifications) == null ? void 0 : _I.columns) ?? ""),
            onChange: (e) => {
              const value = e.target.value;
              const safe = value === "" ? void 0 : Math.min(4, Math.max(1, parseInt(value, 10)));
              const next = {
                ...productData2.sections || {},
                specifications: {
                  ...(productData2.sections || {}).specifications || {},
                  ...typeof safe === "number" ? { columns: safe } : {}
                }
              };
              if (typeof safe !== "number") {
                if (next.specifications && "columns" in next.specifications) delete next.specifications.columns;
              }
              updateProductField("sections", next);
            },
            className: "w-full p-2 border border-border rounded",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Auto (by count)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "1", children: "1" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "2", children: "2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "3", children: "3" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "4", children: "4" })
            ]
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "Technical Capabilities Items" }),
      (localProductData.specifications || []).map((spec, index) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextInput,
              {
                label: "Icon",
                value: spec.icon,
                onChange: (value) => updateProductNestedField("specifications", index, "icon", value),
                placeholder: ""
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextInput,
              {
                label: "Name",
                value: spec.name,
                onChange: (value) => updateProductNestedField("specifications", index, "name", value),
                placeholder: "Analytics Engine"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {})
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextArea,
            {
              label: "Value/Description",
              value: spec.value,
              onChange: (value) => updateProductNestedField("specifications", index, "value", value),
              rows: 2,
              placeholder: "Real-time component tracking..."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                const updated = productData2.specifications.filter((_, i) => i !== index);
                updateProductField("specifications", updated);
              },
              className: "text-red-600 hover:text-red-800 text-sm",
              children: "Remove Specification"
            }
          )
        ] }, index);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => {
            const newSpec = { icon: "", name: "", value: "" };
            const updated = [...productData2.specifications || [], newSpec];
            updateProductField("specifications", updated);
          },
          className: "w-full p-2 border-2 border-dashed border-gray-300 rounded text-sm text-gray-600 hover:border-gray-400 hover:text-gray-800",
          children: "+ Add Specification"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "7. FAQs Section" }),
      (((_J = localProductData.llm) == null ? void 0 : _J.faqs) || []).map((faq, index) => {
        var _a2, _b2;
        const stableKey = `llm-faq-${index}-${((_a2 = faq.question) == null ? void 0 : _a2.length) || 0}-${((_b2 = faq.answer) == null ? void 0 : _b2.length) || 0}`;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: `Question ${index + 1}`,
              value: faq.question || "",
              onChange: (value) => {
                var _a3;
                const updated = [...((_a3 = localProductData.llm) == null ? void 0 : _a3.faqs) || []];
                updated[index] = { ...updated[index], question: value };
                updateProductNestedField("llm", null, "faqs", updated);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextArea,
            {
              label: "Answer",
              value: faq.answer || "",
              rows: 3,
              onChange: (value) => {
                var _a3;
                const updated = [...((_a3 = localProductData.llm) == null ? void 0 : _a3.faqs) || []];
                updated[index] = { ...updated[index], answer: value };
                updateProductNestedField("llm", null, "faqs", updated);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                var _a3;
                const updated = (((_a3 = localProductData.llm) == null ? void 0 : _a3.faqs) || []).filter((_, i) => i !== index);
                updateProductNestedField("llm", null, "faqs", updated);
              },
              className: "text-red-600 hover:text-red-800 text-sm",
              children: "Remove FAQ"
            }
          )
        ] }, stableKey);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => {
            var _a2;
            const updated = [...((_a2 = localProductData.llm) == null ? void 0 : _a2.faqs) || [], { question: "", answer: "" }];
            updateProductNestedField("llm", null, "faqs", updated);
          },
          className: "w-full p-2 border-2 border-dashed border-gray-300 rounded text-sm text-gray-600 hover:border-gray-400 hover:text-gray-800",
          children: "+ Add FAQ"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "8. Waitlist Section" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "The waitlist section appears automatically. Use visibility settings below to control its display." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "Additional: Pricing (Optional)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextInput,
          {
            label: "Price",
            value: ((_K = localProductData.pricing) == null ? void 0 : _K.price) || "",
            onChange: (value) => updateProductNestedField("pricing", null, "price", value),
            placeholder: "$49"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextInput,
          {
            label: "Period",
            value: ((_L = localProductData.pricing) == null ? void 0 : _L.period) || "",
            onChange: (value) => updateProductNestedField("pricing", null, "period", value),
            placeholder: "/month"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextArea,
        {
          label: "Pricing Description",
          value: ((_M = localProductData.pricing) == null ? void 0 : _M.description) || "",
          onChange: (value) => updateProductNestedField("pricing", null, "description", value),
          rows: 2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          label: "Pricing Button Text",
          value: ((_N = localProductData.pricing) == null ? void 0 : _N.buttonText) || "",
          onChange: (value) => updateProductNestedField("pricing", null, "buttonText", value),
          placeholder: "Start Free Trial"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "Section Visibility Controls" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: ((_O = productData2.visibility) == null ? void 0 : _O.expertQuote) ?? true,
              onChange: (e) => updateProductNestedField("visibility", null, "expertQuote", e.target.checked),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show Expert Quote section" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: ((_P = productData2.visibility) == null ? void 0 : _P.statistic) ?? true,
              onChange: (e) => updateProductNestedField("visibility", null, "statistic", e.target.checked),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show Statistic section" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: ((_Q = productData2.visibility) == null ? void 0 : _Q.features) ?? true,
              onChange: (e) => updateProductNestedField("visibility", null, "features", e.target.checked),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show Key Features section" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: ((_R = productData2.visibility) == null ? void 0 : _R.benefits) ?? true,
              onChange: (e) => updateProductNestedField("visibility", null, "benefits", e.target.checked),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show Use Cases section" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: ((_S = productData2.visibility) == null ? void 0 : _S.specifications) ?? true,
              onChange: (e) => updateProductNestedField("visibility", null, "specifications", e.target.checked),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show Technical Capabilities section" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: ((_T = productData2.visibility) == null ? void 0 : _T.faqs) ?? true,
              onChange: (e) => updateProductNestedField("visibility", null, "faqs", e.target.checked),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show FAQs section" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              checked: ((_U = productData2.visibility) == null ? void 0 : _U.waitlist) ?? true,
              onChange: (e) => updateProductNestedField("visibility", null, "waitlist", e.target.checked),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Show Waitlist section" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-base", children: "FAQs" }),
      (localProductData.faqs || []).map((faq, index) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-border rounded-lg p-4 space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextInput,
            {
              label: `Question ${index + 1}`,
              value: faq.question || "",
              onChange: (value) => {
                const updated = [...productData2.faqs || []];
                updated[index] = { ...updated[index], question: value };
                updateProductField("faqs", updated);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextArea,
            {
              label: "Answer",
              value: faq.answer || "",
              rows: 3,
              onChange: (value) => {
                const updated = [...productData2.faqs || []];
                updated[index] = { ...updated[index], answer: value };
                updateProductField("faqs", updated);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                const updated = (productData2.faqs || []).filter((_, i) => i !== index);
                updateProductField("faqs", updated);
              },
              className: "text-red-600 hover:text-red-800 text-sm",
              children: "Remove FAQ"
            }
          )
        ] }, index);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => {
            const updated = [...productData2.faqs || [], { question: "", answer: "" }];
            updateProductField("faqs", updated);
          },
          className: "w-full p-2 border-2 border-dashed border-gray-300 rounded text-sm text-gray-600 hover:border-gray-400 hover:text-gray-800",
          children: "+ Add FAQ"
        }
      )
    ] })
  ] });
};
const ContentEditor = ({ onContentUpdate, initialOpen = false }) => {
  const [editMode, setEditMode] = reactExports.useState("database");
  const [showEditor, setShowEditor] = reactExports.useState(initialOpen);
  const [showLogin, setShowLogin] = reactExports.useState(false);
  const {
    savedContent,
    setSavedContent,
    jsonContent,
    setJsonContent,
    isEditing,
    setIsEditing,
    updateSection,
    updateNestedField
  } = useContentEditorState();
  const [activeSection, setActiveSection] = reactExports.useState("hero");
  const [sections, setSections] = reactExports.useState([]);
  const [contactInfo, setContactInfo] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const [databaseAvailable, setDatabaseAvailable] = reactExports.useState(null);
  const { isAuthenticated, isAdmin, logout } = useAuth();
  const [showNewProductForm, setShowNewProductForm] = reactExports.useState(false);
  const [newProductSlug, setNewProductSlug] = reactExports.useState("");
  const [newProductTitle, setNewProductTitle] = reactExports.useState("");
  const normalizeSlug = (value) => value.toLowerCase().trim().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-");
  const ensureUniqueSlug = (baseSlug) => {
    const existing = Object.keys((savedContent == null ? void 0 : savedContent.products) || {});
    if (!existing.includes(baseSlug)) return baseSlug;
    let i = 2;
    let candidate = `${baseSlug}-${i}`;
    while (existing.includes(candidate)) {
      i += 1;
      candidate = `${baseSlug}-${i}`;
    }
    return candidate;
  };
  const addHeaderNavigationForProduct = (slug, title) => {
    var _a;
    const currentNav = Array.isArray((_a = savedContent == null ? void 0 : savedContent.header) == null ? void 0 : _a.navigation) ? [...savedContent.header.navigation] : [];
    const href = `/${slug}`;
    const exists = currentNav.some((n) => n.href === href);
    if (exists) return;
    const updatedNav = [...currentNav, { label: title || slug.replace(/-/g, " "), href }];
    const nextHeader = { ...(savedContent == null ? void 0 : savedContent.header) || {}, navigation: updatedNav };
    updateSection("header", nextHeader);
  };
  const removeHeaderNavigationForProduct = (slug) => {
    var _a;
    const currentNav = Array.isArray((_a = savedContent == null ? void 0 : savedContent.header) == null ? void 0 : _a.navigation) ? [...savedContent.header.navigation] : [];
    const href = `/${slug}`;
    const filtered = currentNav.filter((n) => n.href !== href);
    const nextHeader = { ...(savedContent == null ? void 0 : savedContent.header) || {}, navigation: filtered };
    updateSection("header", nextHeader);
  };
  const handleCreateProduct = () => {
    const normalized = normalizeSlug(newProductSlug || newProductTitle);
    if (!normalized) {
      showSaveNotification("Enter a slug or title to create a product page", "error");
      return;
    }
    const unique = ensureUniqueSlug(normalized);
    const title = newProductTitle || unique.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
    const newProduct = {
      visibility: { waitlist: true },
      badgeLabel: "",
      title,
      description: "",
      primaryButton: "Get Started",
      primaryButtonLink: "",
      secondaryButton: "Learn More",
      secondaryButtonLink: "",
      details: [],
      benefits: [],
      specifications: [],
      pricing: { price: "", period: "", description: "", buttonText: "" },
      llm: {
        answerBox: "",
        expertQuote: {},
        statistic: {},
        faqs: []
      }
    };
    const nextProducts = { ...savedContent.products || {} };
    nextProducts[unique] = newProduct;
    updateSection("products", nextProducts);
    addHeaderNavigationForProduct(unique, title);
    setShowNewProductForm(false);
    setNewProductSlug("");
    setNewProductTitle("");
    setActiveSection(`product-${unique}`);
    showSaveNotification("Product page created. Remember to Publish Changes.", "success");
  };
  const handleDuplicateProduct = (productKey) => {
    var _a;
    const source = (_a = savedContent == null ? void 0 : savedContent.products) == null ? void 0 : _a[productKey];
    if (!source) return;
    const baseSlug = normalizeSlug(`${productKey}-copy`);
    const unique = ensureUniqueSlug(baseSlug);
    const cloned = JSON.parse(JSON.stringify(source));
    const title = `${cloned.title || productKey} (Copy)`;
    cloned.title = title;
    const nextProducts = { ...savedContent.products || {} };
    nextProducts[unique] = cloned;
    updateSection("products", nextProducts);
    addHeaderNavigationForProduct(unique, title);
    setActiveSection(`product-${unique}`);
    showSaveNotification("Product duplicated. Remember to Publish Changes.", "success");
  };
  const handleDeleteProduct = (productKey) => {
    const current = { ...savedContent.products || {} };
    if (!current[productKey]) return;
    delete current[productKey];
    updateSection("products", current);
    removeHeaderNavigationForProduct(productKey);
    if (activeSection === `product-${productKey}`) setActiveSection("settings");
    showSaveNotification("Product removed. Remember to Publish Changes.", "info");
  };
  const normalizeProductImportJson = (input) => {
    try {
      if (input && typeof input === "object" && !Array.isArray(input)) {
        if (typeof input.title === "string" || typeof input.description === "string" || (input == null ? void 0 : input.llm) || (input == null ? void 0 : input.pricing)) {
          return input;
        }
      }
      const sourceArray = Array.isArray(input) ? input : [];
      if (sourceArray.length === 0) return input;
      const hasType = (obj, type) => {
        const t = obj == null ? void 0 : obj["@type"];
        return t === type || Array.isArray(t) && t.includes(type);
      };
      const faqPage = sourceArray.find((o) => hasType(o, "FAQPage")) || null;
      const productLd = sourceArray.find((o) => hasType(o, "Product")) || null;
      const llmFaqs = Array.isArray(faqPage == null ? void 0 : faqPage.mainEntity) ? faqPage.mainEntity.map((q) => {
        var _a;
        return {
          question: (q == null ? void 0 : q.name) || "",
          answer: ((_a = q == null ? void 0 : q.acceptedAnswer) == null ? void 0 : _a.text) || ""
        };
      }) : [];
      const offers = (productLd == null ? void 0 : productLd.offers) || {};
      const additionalProps = Array.isArray(productLd == null ? void 0 : productLd.additionalProperty) ? productLd.additionalProperty : [];
      const specifications = additionalProps.map((p) => ({
        icon: "",
        name: (p == null ? void 0 : p.name) || "",
        value: (p == null ? void 0 : p.value) || ""
      }));
      const normalized = {
        visibility: { waitlist: true },
        badgeLabel: "",
        title: (productLd == null ? void 0 : productLd.name) || "",
        description: (productLd == null ? void 0 : productLd.description) || "",
        primaryButton: "Get Started",
        primaryButtonLink: typeof (offers == null ? void 0 : offers.url) === "string" ? offers.url : "",
        secondaryButton: "Learn More",
        secondaryButtonLink: "",
        details: [],
        benefits: [],
        specifications,
        pricing: {
          price: typeof (offers == null ? void 0 : offers.price) === "string" || typeof (offers == null ? void 0 : offers.price) === "number" ? String(offers.price) : "",
          period: "/month",
          description: (offers == null ? void 0 : offers.description) || "",
          buttonText: ""
        },
        llm: {
          answerBox: "",
          expertQuote: {},
          statistic: {},
          faqs: llmFaqs
        }
      };
      return normalized;
    } catch {
      return input;
    }
  };
  const handleImportProductJson = (productKey, nextData) => {
    try {
      const currentProducts = { ...(savedContent || {}).products || {} };
      if (!currentProducts[productKey]) {
        showSaveNotification("Product not found", "error");
        return;
      }
      currentProducts[productKey] = normalizeProductImportJson(nextData);
      updateSection("products", currentProducts);
      if (activeSection === `product-${productKey}`) {
        setActiveSection(`product-${productKey}`);
      }
      showSaveNotification("Product JSON applied. Remember to Publish Changes.", "success");
    } catch (e) {
      showSaveNotification("Failed to import JSON for product", "error");
    }
  };
  const handleCreateProductFromJson = (slug, nextData) => {
    const parsedData = normalizeProductImportJson(nextData);
    const normalized = normalizeSlug(slug || (parsedData == null ? void 0 : parsedData.title) || (parsedData == null ? void 0 : parsedData.name) || "new-product");
    if (!normalized) {
      showSaveNotification("Enter a valid slug for the new product", "error");
      return;
    }
    const unique = ensureUniqueSlug(normalized);
    const nextProducts = { ...(savedContent || {}).products || {} };
    if (nextProducts[unique]) {
      showSaveNotification("Slug already exists", "error");
      return;
    }
    nextProducts[unique] = parsedData;
    updateSection("products", nextProducts);
    addHeaderNavigationForProduct(unique, (parsedData == null ? void 0 : parsedData.title) || unique.replace(/-/g, " "));
    setShowNewProductForm(false);
    setNewProductSlug("");
    setNewProductTitle("");
    setActiveSection(`product-${unique}`);
    showSaveNotification("Product created from JSON. Remember to Publish Changes.", "success");
  };
  const handleRenameProductSlug = (productKey, nextSlugOrTitle) => {
    const normalized = normalizeSlug(nextSlugOrTitle);
    if (!normalized) {
      showSaveNotification("Enter a valid slug", "error");
      return;
    }
    const unique = productKey === normalized ? normalized : ensureUniqueSlug(normalized);
    const currentProducts = { ...(savedContent || {}).products || {} };
    const product = currentProducts[productKey];
    if (!product) return;
    if (currentProducts[unique] && unique !== productKey) {
      showSaveNotification("Slug already exists", "error");
      return;
    }
    delete currentProducts[productKey];
    currentProducts[unique] = product;
    updateSection("products", currentProducts);
    removeHeaderNavigationForProduct(productKey);
    addHeaderNavigationForProduct(unique, product.title || unique.replace(/-/g, " "));
    if (activeSection === `product-${productKey}`) setActiveSection(`product-${unique}`);
    showSaveNotification("Product slug updated. Remember to Publish Changes.", "success");
  };
  const handleRenameProductTitle = (productKey, nextTitle) => {
    const title = (nextTitle || "").trim();
    if (!title) {
      showSaveNotification("Enter a valid title", "error");
      return;
    }
    const currentProducts = { ...(savedContent || {}).products || {} };
    const product = currentProducts[productKey];
    if (!product) return;
    currentProducts[productKey] = { ...product, title };
    updateSection("products", currentProducts);
    removeHeaderNavigationForProduct(productKey);
    addHeaderNavigationForProduct(productKey, title);
    showSaveNotification("Product title updated. Remember to Publish Changes.", "success");
  };
  const handleMoveProduct = (productKey, direction) => {
    const currentProducts = { ...(savedContent || {}).products || {} };
    const keys = Object.keys(currentProducts);
    const fromIndex = keys.indexOf(productKey);
    if (fromIndex === -1) return;
    const toIndex = direction === "up" ? fromIndex - 1 : fromIndex + 1;
    if (toIndex < 0 || toIndex >= keys.length) return;
    const reorderedKeys = reorderArray(keys, fromIndex, toIndex);
    const nextProducts = {};
    for (const k of reorderedKeys) nextProducts[k] = currentProducts[k];
    updateSection("products", nextProducts);
  };
  const migrateContentStructure = (content) => {
    var _a;
    if (!content.products && productData.products) {
      content.products = { ...productData.products };
      debugService.contentUpdate("Migrated content to include products structure");
    }
    const defaultContent = { ...productData };
    Object.keys(defaultContent).forEach((key) => {
      if (!content[key]) {
        content[key] = defaultContent[key];
      }
    });
    if (!content.products || typeof content.products !== "object") {
      content.products = {};
    }
    const defaultProducts = (productData == null ? void 0 : productData.products) || {};
    Object.entries(defaultProducts).forEach(([slug, prod]) => {
      if (!content.products[slug]) {
        content.products[slug] = prod;
      }
    });
    const navItems = Array.isArray((_a = content == null ? void 0 : content.header) == null ? void 0 : _a.navigation) ? [...content.header.navigation] : [];
    navItems.forEach((item) => {
      const href = ((item == null ? void 0 : item.href) || "").toString();
      if (!href.startsWith("/") || href.includes("#")) return;
      const slug = href.replace(/^\//, "").trim();
      if (!slug) return;
      if (!content.products[slug]) {
        const title = ((item == null ? void 0 : item.label) || slug.replace(/-/g, " ")).replace(/\b\w/g, (c) => c.toUpperCase());
        content.products[slug] = {
          visibility: { waitlist: true },
          badgeLabel: "",
          title,
          description: "",
          primaryButton: "Get Started",
          primaryButtonLink: "",
          secondaryButton: "Learn More",
          secondaryButtonLink: "",
          details: [],
          benefits: [],
          specifications: [],
          pricing: { price: "", period: "", description: "", buttonText: "" },
          llm: { answerBox: "", expertQuote: {}, statistic: {}, faqs: [] }
        };
      }
    });
    if (!content.settings) {
      content.settings = { visibility: {} };
    }
    if (!content.settings.visibility) {
      content.settings.visibility = {};
    }
    if (!content.settings.labels) {
      content.settings.labels = {
        featuresBadges: true,
        pricingBadges: true,
        heroBadges: true,
        productBadges: true,
        ctaBadges: true
      };
    } else {
      const labels = content.settings.labels;
      if (labels.featuresBadges === void 0) labels.featuresBadges = true;
      if (labels.pricingBadges === void 0) labels.pricingBadges = true;
      if (labels.heroBadges === void 0) labels.heroBadges = true;
      if (labels.productBadges === void 0) labels.productBadges = true;
      if (labels.ctaBadges === void 0) labels.ctaBadges = true;
    }
    const defaultVisibility = {
      hero: true,
      features: true,
      pricing: false,
      "bibliokit-blocks": true,
      "ai-rename-variants": true,
      product: true,
      contact: true,
      cta: true,
      waitlist: true,
      header: true,
      footer: true
    };
    Object.entries(defaultVisibility).forEach(([key, defaultValue]) => {
      if (content.settings.visibility[key] === void 0) {
        content.settings.visibility[key] = defaultValue;
      }
    });
    Object.keys(content.products || {}).forEach((slug) => {
      if (content.settings.visibility[slug] === void 0) {
        content.settings.visibility[slug] = true;
      }
    });
    return content;
  };
  const buildUnifiedContentFromDatabase = (sections2, contactInfo2) => {
    debugService.contentUpdate("Building unified content from database sections", { sectionCount: sections2.length });
    const unifiedContent = { ...productData };
    if (!unifiedContent.settings) unifiedContent.settings = {};
    if (!unifiedContent.settings.visibility) unifiedContent.settings.visibility = {};
    sections2.forEach((section) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      const sectionData = section.section_data || {};
      if (section.section_type) {
        unifiedContent.settings.visibility[section.section_type] = section.is_visible !== false;
      }
      switch (section.section_type) {
        case "hero":
          unifiedContent.hero = {
            ...unifiedContent.hero,
            ...sectionData,
            // Ensure we preserve any structure from productData that might not be in DB
            settings: { ...(_a = unifiedContent.hero) == null ? void 0 : _a.settings, ...sectionData.settings }
          };
          break;
        case "features":
          unifiedContent.features = {
            ...unifiedContent.features,
            ...sectionData,
            // If section has related features, include them
            items: section.features || sectionData.items || ((_b = unifiedContent.features) == null ? void 0 : _b.items) || []
          };
          break;
        case "pricing":
          unifiedContent.pricing = {
            ...unifiedContent.pricing,
            ...sectionData,
            // If section has related plans, include them
            plans: section.plans || sectionData.plans || ((_c = unifiedContent.pricing) == null ? void 0 : _c.plans) || []
          };
          break;
        case "cta":
          if (!unifiedContent.cta) unifiedContent.cta = {};
          unifiedContent.cta = {
            ...unifiedContent.cta,
            ...sectionData
          };
          break;
        case "waitlist":
          if (!unifiedContent.waitlist) unifiedContent.waitlist = {};
          unifiedContent.waitlist = {
            ...unifiedContent.waitlist,
            // normalize snake_case -> camelCase
            title: sectionData.title ?? unifiedContent.waitlist.title,
            description: sectionData.description ?? unifiedContent.waitlist.description,
            buttonText: sectionData.buttonText ?? sectionData.button_text ?? unifiedContent.waitlist.buttonText,
            successMessage: sectionData.successMessage ?? sectionData.success_message ?? unifiedContent.waitlist.successMessage
          };
          break;
        case "header": {
          if (!unifiedContent.header) unifiedContent.header = {};
          const mappedHeader = {
            logoText: sectionData.logoText || sectionData.logo_text || ((_d = unifiedContent.header) == null ? void 0 : _d.logoText),
            signInText: sectionData.signInText || sectionData.sign_in_text || ((_e = unifiedContent.header) == null ? void 0 : _e.signInText),
            getStartedText: sectionData.getStartedText || sectionData.get_started_text || ((_f = unifiedContent.header) == null ? void 0 : _f.getStartedText),
            signInHref: sectionData.signInHref || sectionData.sign_in_href || ((_g = unifiedContent.header) == null ? void 0 : _g.signInHref),
            getStartedHref: sectionData.getStartedHref || sectionData.get_started_href || ((_h = unifiedContent.header) == null ? void 0 : _h.getStartedHref),
            showSignIn: sectionData.showSignIn ?? sectionData.show_sign_in ?? ((_i = unifiedContent.header) == null ? void 0 : _i.showSignIn) ?? true,
            showGetStarted: sectionData.showGetStarted ?? sectionData.show_get_started ?? ((_j = unifiedContent.header) == null ? void 0 : _j.showGetStarted) ?? true,
            navigation: section.navigation_items || sectionData.navigation || sectionData.navigation_items || ((_k = unifiedContent.header) == null ? void 0 : _k.navigation) || []
          };
          unifiedContent.header = {
            ...unifiedContent.header,
            ...mappedHeader
          };
          break;
        }
        case "footer": {
          if (!unifiedContent.footer) unifiedContent.footer = {};
          const mappedFooter = {
            description: sectionData.description || ((_l = unifiedContent.footer) == null ? void 0 : _l.description),
            sections: section.footer_links || sectionData.sections || ((_m = unifiedContent.footer) == null ? void 0 : _m.sections) || []
          };
          unifiedContent.footer = {
            ...unifiedContent.footer,
            ...mappedFooter
          };
          break;
        }
        default:
          unifiedContent[section.section_type] = sectionData;
      }
    });
    if (contactInfo2) {
      unifiedContent.contact = contactInfo2;
    }
    debugService.contentUpdate("Unified content built successfully", {
      sections: Object.keys(unifiedContent),
      hasContact: !!contactInfo2
    });
    return unifiedContent;
  };
  const handleSave = async () => {
    debugService.saveStart("Main content save", { editMode, databaseAvailable });
    try {
      let contentToSave;
      if (editMode === "json") {
        try {
          contentToSave = JSON.parse(jsonContent);
          debugService.contentUpdate("JSON parsed successfully", { contentKeys: Object.keys(contentToSave) });
        } catch (parseError) {
          debugService.saveError("JSON parse failed", parseError);
          alert("Invalid JSON format. Please check your syntax.");
          return;
        }
      } else {
        contentToSave = savedContent;
        debugService.contentUpdate("Using current saved content", { contentKeys: Object.keys(contentToSave) });
      }
      let saveSuccess = false;
      let dbSaveSuccess = false;
      if (databaseAvailable) {
        debugService.saveStart("Saving to database");
        try {
          const response = await contentApi.saveContent(contentToSave, true);
          if (response.success) {
            debugService.saveSuccess("Database save completed", response.data);
            saveSuccess = true;
            dbSaveSuccess = true;
            if (editMode === "json") {
              debugService.saveStart("Syncing JSON to sections tables");
              const syncResponse = await contentApi.syncJsonToSections(contentToSave);
              if (syncResponse.success) {
                debugService.saveSuccess("JSON to sections sync completed", syncResponse.message);
              } else {
                debugService.saveError("JSON to sections sync failed", syncResponse.error);
              }
            }
          } else {
            debugService.saveError("Database save failed", response.error);
          }
        } catch (error2) {
          debugService.saveError("Database save exception", error2);
        }
      }
      debugService.saveStart("Saving to localStorage");
      try {
        localStorage.setItem("bibliokit-content", JSON.stringify(contentToSave));
        debugService.saveSuccess("localStorage save completed");
        if (!saveSuccess) saveSuccess = true;
      } catch (error2) {
        debugService.saveError("localStorage save failed", error2);
      }
      if (saveSuccess) {
        setSavedContent(contentToSave);
        setJsonContent(JSON.stringify(contentToSave, null, 2));
        setIsEditing(false);
        if (onContentUpdate) {
          debugService.contentUpdate("Notifying parent component");
          onContentUpdate(contentToSave);
        }
        debugService.saveSuccess("Content save completed successfully");
        const successMessage = dbSaveSuccess ? "Content saved to database!" : "Content saved locally!";
        showSaveNotification(successMessage, "success");
      } else {
        debugService.saveError("All save methods failed", "No successful save operation completed");
        showSaveNotification("Failed to save content. Please try again.", "error");
      }
    } catch (error2) {
      debugService.saveError("Unexpected error during save", error2);
      showSaveNotification("An unexpected error occurred while saving.", "error");
    }
  };
  const [saveNotification, setSaveNotification] = reactExports.useState(null);
  const showSaveNotification = (message, type) => {
    setSaveNotification({ message, type });
    setTimeout(() => setSaveNotification(null), 3e3);
  };
  const handleReset = () => {
    setJsonContent(JSON.stringify(productData, null, 2));
    setSavedContent(productData);
    setIsEditing(false);
    localStorage.removeItem("bibliokit-content");
    window.location.reload();
  };
  const updateVisibility = (sectionKey, isVisible) => {
    const currentSettings = savedContent.settings || { visibility: {}, labels: {} };
    const updatedSettings = { ...currentSettings };
    if (sectionKey.startsWith("labels.")) {
      const labelKey = sectionKey.split(".")[1];
      updatedSettings.labels = { ...currentSettings.labels || {}, [labelKey]: isVisible };
    } else {
      updatedSettings.visibility = {
        ...currentSettings.visibility || {},
        [sectionKey]: isVisible
      };
    }
    updateSection("settings", updatedSettings);
  };
  const updateSettingsVisibility = (section, isVisible) => {
    updateVisibility(section, isVisible);
  };
  reactExports.useEffect(() => {
    const checkDatabase = async () => {
      if (!isAuthenticated || !isAdmin) {
        debugService.authEvent("Content editor access denied - not authenticated or admin");
        return;
      }
      debugService.info("Starting database availability check");
      setLoading(true);
      try {
        const available = await contentApi.isDatabaseAvailable();
        setDatabaseAvailable(available);
        debugService.dbConnection(available ? "Database available" : "Database unavailable");
        if (available) {
          debugService.contentLoad("Loading content from database");
          await loadDatabaseContent();
        } else {
          debugService.contentLoad("Falling back to localStorage");
          const saved = localStorage.getItem("bibliokit-content");
          if (saved) {
            try {
              const parsed = JSON.parse(saved);
              const migratedContent = migrateContentStructure(parsed);
              setSavedContent(migratedContent);
              setJsonContent(JSON.stringify(migratedContent, null, 2));
              debugService.contentLoad("localStorage content loaded and migrated successfully", { keys: Object.keys(migratedContent) });
            } catch (error2) {
              debugService.error("Failed to parse localStorage content", error2);
            }
          } else {
            debugService.contentLoad("No localStorage content found, using defaults");
          }
        }
      } catch (error2) {
        debugService.error("Database check failed", error2);
        setDatabaseAvailable(false);
      } finally {
        setLoading(false);
      }
    };
    checkDatabase();
  }, [isAuthenticated, isAdmin]);
  const loadDatabaseContent = async () => {
    var _a, _b, _c;
    debugService.contentLoad("Starting database content load");
    try {
      const [publishedResponse, sectionsResponse, contactResponse] = await Promise.all([
        contentApi.getCurrentContent(),
        contentApi.getAllSections(),
        contentApi.getContactInfo()
      ]);
      debugService.apiResponse("GET", "published-content", publishedResponse);
      debugService.apiResponse("GET", "sections", sectionsResponse);
      debugService.apiResponse("GET", "contact", contactResponse);
      let liveContent;
      if (publishedResponse.success && ((_a = publishedResponse.data) == null ? void 0 : _a.content_data)) {
        debugService.contentLoad("Using published content from site_content table");
        liveContent = publishedResponse.data.content_data;
        if (sectionsResponse.success) {
          setSections(sectionsResponse.data || []);
        }
      } else {
        debugService.contentLoad("Published content not available, rebuilding from sections");
        if (sectionsResponse.success) {
          setSections(sectionsResponse.data || []);
          debugService.contentLoad("Sections loaded", { count: ((_b = sectionsResponse.data) == null ? void 0 : _b.length) || 0 });
        } else {
          debugService.error("Failed to load sections", sectionsResponse.error);
          setSections([]);
        }
        liveContent = buildUnifiedContentFromDatabase(
          sectionsResponse.success ? sectionsResponse.data || [] : [],
          contactResponse.success ? contactResponse.data || null : null
        );
      }
      if (contactResponse.success) {
        setContactInfo(contactResponse.data || null);
        debugService.contentLoad("Contact info loaded", contactResponse.data);
      } else {
        debugService.error("Failed to load contact info", contactResponse.error);
        setContactInfo(null);
      }
      if (contactResponse.success && contactResponse.data) {
        liveContent = {
          ...liveContent,
          contact: contactResponse.data
        };
      }
      const migratedLiveContent = migrateContentStructure(liveContent);
      setSavedContent(migratedLiveContent);
      setJsonContent(JSON.stringify(migratedLiveContent, null, 2));
      try {
        localStorage.setItem("bibliokit-content", JSON.stringify(migratedLiveContent));
      } catch {
      }
      if (onContentUpdate) {
        try {
          onContentUpdate(migratedLiveContent);
        } catch {
        }
      }
      debugService.contentLoad("Unified content loaded from database", {
        source: publishedResponse.success && ((_c = publishedResponse.data) == null ? void 0 : _c.content_data) ? "site_content" : "content_sections",
        sections: Object.keys(liveContent).filter((key) => key !== "contact"),
        hasContact: !!liveContent.contact
      });
    } catch (error2) {
      debugService.error("Database content load failed", error2);
      setError("Failed to load content from database");
    }
  };
  const saveSection = async (section) => {
    const operation = section.id ? "update" : "create";
    debugService.saveStart(`Section ${operation}`, { sectionType: section.section_type, id: section.id });
    try {
      let response;
      if (!section.id) {
        debugService.apiRequest("POST", "content-sections", section);
        response = await contentApi.createSection(section);
      } else {
        debugService.apiRequest("PUT", `content-sections/${section.id}`, section);
        response = await contentApi.updateSection(section.id, section);
      }
      debugService.apiResponse(operation.toUpperCase(), "content-sections", response);
      if (response.success) {
        debugService.saveSuccess(`Section ${operation} completed`, response.data);
        setError(null);
        showSaveNotification(`${section.section_type} section ${operation}d successfully!`, "success");
      } else {
        const errorMsg = response.error || `Failed to ${operation} section`;
        debugService.saveError(`Section ${operation} failed`, errorMsg);
        setError(errorMsg);
        showSaveNotification(errorMsg, "error");
      }
    } catch (error2) {
      debugService.saveError(`Section ${operation} exception`, error2);
      const errorMsg = `Unexpected error during section ${operation}`;
      setError(errorMsg);
      showSaveNotification(errorMsg, "error");
    }
  };
  const deleteSection = async (sectionId) => {
    debugService.saveStart("Section delete", { sectionId });
    try {
      debugService.apiRequest("DELETE", `content-sections/${sectionId}`);
      const response = await contentApi.deleteSection(sectionId);
      debugService.apiResponse("DELETE", "content-sections", response);
      if (response.success) {
        debugService.saveSuccess("Section delete completed", { sectionId });
        setError(null);
        showSaveNotification("Section deleted successfully!", "success");
      } else {
        const errorMsg = response.error || "Failed to delete section";
        debugService.saveError("Section delete failed", errorMsg);
        setError(errorMsg);
        showSaveNotification(errorMsg, "error");
      }
    } catch (error2) {
      debugService.saveError("Section delete exception", error2);
      const errorMsg = "Unexpected error during section delete";
      setError(errorMsg);
      showSaveNotification(errorMsg, "error");
    }
  };
  const countWords = (text) => {
    return text.trim().split(/\s+/).filter((word) => word.length > 0).length;
  };
  const getWordStatus = (words, min = 40, max = 70) => {
    if (words >= min && words <= max) return { status: "good", color: "text-green-600", bg: "bg-green-100" };
    if (words < min) return { status: "too-short", color: "text-yellow-600", bg: "bg-yellow-100" };
    return { status: "too-long", color: "text-red-600", bg: "bg-red-100" };
  };
  const renderSectionEditor = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F;
    if (editMode === "database" && databaseAvailable) {
      return renderDatabaseEditor();
    }
    const sections2 = {
      header: "Header Section",
      hero: "Hero Section",
      features: "Features Section",
      pricing: "Pricing Section",
      cta: "CTA Section",
      waitlist: "Waitlist Section",
      footer: "Footer Section",
      contact: "Contact Info",
      pages: "Pages",
      llm: "LLM Optimization",
      settings: "Visibility Settings"
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-4 gap-4 h-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-muted/20 p-4 rounded-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold mb-4", children: "Edit Sections" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 p-2 bg-muted/30 rounded", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-xs", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `w-2 h-2 rounded-full ${databaseAvailable ? "bg-green-500" : "bg-red-500"}` }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: databaseAvailable ? "Database Connected" : "Local Mode" })
          ] }),
          databaseAvailable && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setEditMode("database"),
              className: "mt-2 w-full button text-xs",
              children: "Switch to Database Editor"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: Object.entries(sections2).map(([key, label]) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setActiveSection(key),
            className: `w-full text-left p-2 rounded text-sm transition-colors ${activeSection === key ? "bg-primary text-primary-foreground" : "hover:bg-muted/40"}`,
            children: label
          },
          key
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ProductsManager,
          {
            products: (savedContent == null ? void 0 : savedContent.products) || {},
            activeSection,
            showNewProductForm,
            newProductSlug,
            newProductTitle,
            setActiveSection,
            setShowNewProductForm,
            setNewProductSlug,
            setNewProductTitle,
            onDuplicate: handleDuplicateProduct,
            onDelete: handleDeleteProduct,
            onCreate: handleCreateProduct,
            onRenameSlug: handleRenameProductSlug,
            onRenameTitle: handleRenameProductTitle,
            onMove: handleMoveProduct,
            onImportJson: handleImportProductJson,
            onCreateFromJson: handleCreateProductFromJson
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          PagesManager,
          {
            pages: (savedContent == null ? void 0 : savedContent.pages) || [],
            activeSection,
            setActiveSection
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-6 pt-4 border-t border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setEditMode("json"),
            className: "w-full button-secondary text-sm",
            children: "Advanced JSON Editor"
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lg:col-span-3 bg-muted/20 p-4 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-8", children: [
        activeSection === "settings" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          SettingsSectionEditor,
          {
            settings: savedContent.settings,
            updateSettingsVisibility
          }
        ),
        activeSection === "llm" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          LLMSectionEditor,
          {
            llmContent: savedContent.llm,
            updateNestedField,
            countWords,
            getWordStatus
          }
        ),
        activeSection === "hero" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          HeroSectionEditor,
          {
            hero: savedContent.hero,
            updateNestedField,
            visible: ((_b = (_a = savedContent.settings) == null ? void 0 : _a.visibility) == null ? void 0 : _b.hero) ?? true,
            updateVisibility: (isVisible) => updateVisibility("hero", isVisible)
          }
        ),
        activeSection === "pages" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          PagesEditor,
          {
            pages: savedContent.pages || [],
            onChange: (next) => updateSection("pages", next)
          }
        ),
        activeSection === "contact" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContactSectionEditor,
          {
            contact: savedContent.contact,
            updateNestedField
          }
        ),
        activeSection === "features" && (() => {
          var _a2, _b2, _c2, _d2, _e2;
          const featuresArray = Array.isArray(savedContent.features) ? savedContent.features : ((_a2 = savedContent == null ? void 0 : savedContent.features) == null ? void 0 : _a2.items) || [];
          const featuresSectionData = savedContent.featuresSection || (Array.isArray(savedContent.features) ? void 0 : {
            title: (_b2 = savedContent == null ? void 0 : savedContent.features) == null ? void 0 : _b2.title,
            description: (_c2 = savedContent == null ? void 0 : savedContent.features) == null ? void 0 : _c2.description
          });
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            FeaturesSectionEditor,
            {
              features: featuresArray,
              updateNestedField,
              visible: ((_e2 = (_d2 = savedContent.settings) == null ? void 0 : _d2.visibility) == null ? void 0 : _e2.features) ?? true,
              updateVisibility: (isVisible) => updateVisibility("features", isVisible),
              updateSection,
              sectionData: featuresSectionData
            }
          );
        })(),
        (activeSection === "pricing" || activeSection === "product") && /* @__PURE__ */ jsxRuntimeExports.jsx(
          PricingProductSectionEditor,
          {
            activeSection,
            pricing: savedContent.pricing,
            product: savedContent.product,
            updateNestedField,
            updateSection,
            setEditMode,
            pricingVisible: ((_d = (_c = savedContent.settings) == null ? void 0 : _c.visibility) == null ? void 0 : _d.pricing) ?? false,
            productVisible: ((_f = (_e = savedContent.settings) == null ? void 0 : _e.visibility) == null ? void 0 : _f.product) ?? true,
            updateVisibility
          }
        ),
        activeSection === "cta" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "CTA Section" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                id: "cta-visible",
                checked: ((_h = (_g = savedContent.settings) == null ? void 0 : _g.visibility) == null ? void 0 : _h.cta) ?? true,
                onChange: (e) => updateVisibility("cta", e.target.checked),
                className: "rounded border-border"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "cta-visible", className: "text-sm", children: "Visible on website" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Title" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: ((_i = savedContent.cta) == null ? void 0 : _i.title) || "",
                onChange: (e) => updateNestedField("cta", null, "title", e.target.value),
                className: "w-full p-2 border border-border rounded",
                placeholder: "Ready to get started?"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Description" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                value: ((_j = savedContent.cta) == null ? void 0 : _j.description) || "",
                onChange: (e) => updateNestedField("cta", null, "description", e.target.value),
                className: "w-full p-2 border border-border rounded h-24",
                placeholder: "Description text"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Primary Button" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: ((_k = savedContent.cta) == null ? void 0 : _k.primaryButton) || "",
                  onChange: (e) => updateNestedField("cta", null, "primaryButton", e.target.value),
                  className: "w-full p-2 border border-border rounded",
                  placeholder: "Start Free Trial"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Secondary Button" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: ((_l = savedContent.cta) == null ? void 0 : _l.secondaryButton) || "",
                  onChange: (e) => updateNestedField("cta", null, "secondaryButton", e.target.value),
                  className: "w-full p-2 border border-border rounded",
                  placeholder: "Schedule Demo"
                }
              )
            ] })
          ] })
        ] }),
        activeSection === "waitlist" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Waitlist Section" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                id: "waitlist-visible",
                checked: ((_n = (_m = savedContent.settings) == null ? void 0 : _m.visibility) == null ? void 0 : _n.waitlist) ?? true,
                onChange: (e) => updateVisibility("waitlist", e.target.checked),
                className: "rounded border-border"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "waitlist-visible", className: "text-sm", children: "Visible on website" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Title" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: ((_o = savedContent.waitlist) == null ? void 0 : _o.title) || "",
                onChange: (e) => updateNestedField("waitlist", null, "title", e.target.value),
                className: "w-full p-2 border border-border rounded",
                placeholder: "Join the Waitlist"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Description" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                value: ((_p = savedContent.waitlist) == null ? void 0 : _p.description) || "",
                onChange: (e) => updateNestedField("waitlist", null, "description", e.target.value),
                className: "w-full p-2 border border-border rounded h-24",
                placeholder: "Be the first to know when we launch..."
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Button Text" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: ((_q = savedContent.waitlist) == null ? void 0 : _q.buttonText) || "",
                onChange: (e) => updateNestedField("waitlist", null, "buttonText", e.target.value),
                className: "w-full p-2 border border-border rounded",
                placeholder: "Join Waitlist"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Success Message" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: ((_r = savedContent.waitlist) == null ? void 0 : _r.successMessage) || "",
                onChange: (e) => updateNestedField("waitlist", null, "successMessage", e.target.value),
                className: "w-full p-2 border border-border rounded",
                placeholder: "Thank you for joining our waitlist!"
              }
            )
          ] })
        ] }),
        activeSection === "header" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Header Section" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            HeaderCtasEditor,
            {
              visibility: ((_t = (_s = savedContent.settings) == null ? void 0 : _s.visibility) == null ? void 0 : _t.header) ?? true,
              logoText: ((_u = savedContent.header) == null ? void 0 : _u.logoText) || "",
              signInText: ((_v = savedContent.header) == null ? void 0 : _v.signInText) || "",
              getStartedText: ((_w = savedContent.header) == null ? void 0 : _w.getStartedText) || "",
              signInHref: ((_x = savedContent.header) == null ? void 0 : _x.signInHref) || "",
              getStartedHref: ((_y = savedContent.header) == null ? void 0 : _y.getStartedHref) || "",
              showSignIn: ((_z = savedContent.header) == null ? void 0 : _z.showSignIn) ?? true,
              showGetStarted: ((_A = savedContent.header) == null ? void 0 : _A.showGetStarted) ?? true,
              onChangeVisibility: (isVisible) => updateVisibility("header", isVisible),
              onChangeLogoText: (value) => updateNestedField("header", null, "logoText", value),
              onChangeSignInText: (value) => updateNestedField("header", null, "signInText", value),
              onChangeGetStartedText: (value) => updateNestedField("header", null, "getStartedText", value),
              onChangeSignInHref: (value) => updateNestedField("header", null, "signInHref", value),
              onChangeGetStartedHref: (value) => updateNestedField("header", null, "getStartedHref", value),
              onChangeShowSignIn: (checked) => updateNestedField("header", null, "showSignIn", checked),
              onChangeShowGetStarted: (checked) => updateNestedField("header", null, "showGetStarted", checked)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            HeaderNavigationEditor,
            {
              items: ((_B = savedContent == null ? void 0 : savedContent.header) == null ? void 0 : _B.navigation) || [],
              onChange: (next) => updateSection("header.navigation", next)
            }
          )
        ] }),
        activeSection === "footer" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          FooterEditor,
          {
            description: ((_C = savedContent.footer) == null ? void 0 : _C.description) || "",
            sections: ((_D = savedContent == null ? void 0 : savedContent.footer) == null ? void 0 : _D.sections) || [],
            visibility: ((_F = (_E = savedContent.settings) == null ? void 0 : _E.visibility) == null ? void 0 : _F.footer) ?? true,
            onChangeDescription: (value) => updateNestedField("footer", null, "description", value),
            onChangeSections: (next) => updateNestedField("footer", null, "sections", next),
            onChangeVisibility: (isVisible) => updateVisibility("footer", isVisible)
          }
        ),
        Object.keys((savedContent == null ? void 0 : savedContent.products) || {}).map((productKey) => {
          var _a2;
          return activeSection === `product-${productKey}` && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IndividualProductEditor,
            {
              productKey,
              productData: (_a2 = savedContent.products) == null ? void 0 : _a2[productKey],
              updateNestedField,
              updateSection,
              setEditMode
            },
            productKey
          );
        })
      ] }) })
    ] });
  };
  const renderDatabaseEditor = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-4 gap-4 h-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-muted/20 p-4 rounded-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold mb-4", children: "Database Sections" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 p-2 bg-green-50 border border-green-200 rounded", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 text-xs text-green-800", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-2 h-2 rounded-full bg-green-500" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Database Connected" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setEditMode("sections"),
              className: "mt-2 w-full button-secondary text-xs",
              children: "Switch to Local Editor"
            }
          )
        ] }),
        error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 p-2 bg-red-50 border border-red-200 rounded text-xs text-red-800", children: error }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: ["header", "hero", "features", "pricing", "cta", "waitlist", "footer", "contact"].map((sectionType) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setActiveSection(sectionType),
            className: `w-full text-left p-2 rounded text-sm transition-colors capitalize flex items-center justify-between ${activeSection === sectionType ? "bg-primary text-primary-foreground" : "hover:bg-muted/40"}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                sectionType,
                " Section"
              ] }),
              sections.find((s2) => s2.section_type === sectionType) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-2 h-2 rounded-full bg-green-500" })
            ]
          },
          sectionType
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-6 pt-4 border-t border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: loadDatabaseContent,
            className: "w-full button-secondary text-sm mb-2",
            disabled: loading,
            children: loading ? "Loading..." : "Refresh Data"
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lg:col-span-3 bg-muted/20 p-4 rounded-lg overflow-y-auto max-h-[70vh]", children: renderDatabaseSectionForm() })
    ] });
  };
  const renderDatabaseSectionForm = () => {
    const currentSection = sections.find((s2) => s2.section_type === activeSection);
    if (activeSection === "contact") {
      return renderContactForm();
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "font-semibold text-lg capitalize", children: [
          activeSection,
          " Section"
        ] }),
        currentSection && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => deleteSection(currentSection.id),
            className: "button-secondary text-red-600 hover:bg-red-50 text-xs",
            children: "Delete Section"
          }
        )
      ] }),
      activeSection === "hero" && renderHeroForm(currentSection),
      activeSection === "features" && renderFeaturesForm(currentSection),
      activeSection === "pricing" && renderPricingForm(currentSection),
      activeSection === "cta" && renderCTAForm(currentSection),
      activeSection === "waitlist" && renderWaitlistForm(currentSection),
      activeSection === "header" && renderHeaderForm(currentSection),
      activeSection === "footer" && renderFooterForm(currentSection)
    ] });
  };
  const renderContactForm = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-lg", children: "Contact Information" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Email" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "email",
            value: (contactInfo == null ? void 0 : contactInfo.email) || "",
            onChange: (e) => setContactInfo((prev) => ({ ...prev, email: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "hello@example.com"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Twitter" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: (contactInfo == null ? void 0 : contactInfo.twitter) || "",
            onChange: (e) => setContactInfo((prev) => ({ ...prev, twitter: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "@username"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "GitHub" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: (contactInfo == null ? void 0 : contactInfo.github) || "",
            onChange: (e) => setContactInfo((prev) => ({ ...prev, github: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "username"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: async () => {
            if (contactInfo) {
              const response = await contentApi.updateContactInfo(contactInfo);
              if (response.success) {
                setError(null);
                showSaveNotification("Contact info saved successfully!", "success");
              } else {
                setError(response.error || "Failed to update contact info");
              }
            }
          },
          className: "button",
          children: "Save Contact Info"
        }
      )
    ] })
  ] });
  const renderHeroForm = (section) => {
    const [formData, setFormData] = reactExports.useState(
      section || {
        section_type: "hero",
        is_visible: true,
        badgeLabel: "",
        title: "",
        subtitle: "",
        description: "",
        primary_button: "",
        secondary_button: ""
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Badge Label" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.badgeLabel || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, badgeLabel: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "SaaS Analytics Platform"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Emoji" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.emoji || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, emoji: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "e.g. "
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Title" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.title || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, title: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "Main title"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Subtitle" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.subtitle || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, subtitle: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "Subtitle"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Description" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: formData.description || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, description: e.target.value })),
            className: "w-full p-2 border border-border rounded h-24",
            placeholder: "Hero description"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Primary Button" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.primary_button || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, primary_button: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "Get Started"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Secondary Button" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.secondary_button || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, secondary_button: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "Learn More"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            id: "hero-visible",
            checked: formData.is_visible,
            onChange: (e) => setFormData((prev) => ({ ...prev, is_visible: e.target.checked })),
            className: "rounded border-border"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "hero-visible", className: "text-sm", children: "Visible on website" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: async () => {
            await saveSection(formData);
            setFormData(section || formData);
          },
          className: "button",
          children: section ? "Update Hero Section" : "Create Hero Section"
        }
      )
    ] }) });
  };
  const renderFeaturesForm = (section) => {
    const [formData, setFormData] = reactExports.useState(
      section || {
        section_type: "features",
        is_visible: true,
        title: "",
        description: ""
      }
    );
    const [features2, setFeatures] = reactExports.useState(
      (section == null ? void 0 : section.features) || []
    );
    const moveFeature = (fromIndex, toIndex) => {
      if (fromIndex === toIndex) return;
      if (toIndex < 0 || toIndex >= features2.length) return;
      const next = [...features2];
      const [moved] = next.splice(fromIndex, 1);
      next.splice(toIndex, 0, moved);
      setFeatures(next);
    };
    const handleDragStart = (e, index) => {
      e.dataTransfer.setData("text/plain", String(index));
      e.dataTransfer.effectAllowed = "move";
    };
    const handleDropOnCard = (e, dropIndex) => {
      e.preventDefault();
      const from = parseInt(e.dataTransfer.getData("text/plain"), 10);
      if (!Number.isNaN(from)) {
        moveFeature(from, dropIndex);
      }
    };
    const addFeature = () => {
      const newFeature = {
        icon: "",
        title: "New Feature",
        description: "Feature description",
        badge: "",
        badge_color: "green",
        is_featured: false
      };
      setFeatures([...features2, newFeature]);
    };
    const updateFeature = (index, field, value) => {
      const updatedFeatures = features2.map(
        (feature, i) => i === index ? { ...feature, [field]: value } : feature
      );
      setFeatures(updatedFeatures);
    };
    const removeFeature = (index) => {
      setFeatures(features2.filter((_, i) => i !== index));
    };
    const saveFeatures = async () => {
      var _a;
      try {
        let sectionId = section == null ? void 0 : section.id;
        const payload = {
          section_type: "features",
          is_visible: formData.is_visible !== false,
          section_data: {
            title: formData.title,
            description: formData.description
          }
        };
        if (!sectionId) {
          const createRes = await contentApi.createSection(payload);
          if (!createRes.success || !((_a = createRes.data) == null ? void 0 : _a.id)) throw new Error(createRes.error || "Failed to create features section");
          sectionId = createRes.data.id;
        } else {
          const updateRes = await contentApi.updateSection(sectionId, payload);
          if (!updateRes.success) throw new Error(updateRes.error || "Failed to update features section");
        }
        if (!sectionId) throw new Error("Features section ID unavailable");
        const originalItems = ((section == null ? void 0 : section.features) || []).map((f, idx) => ({ ...f, sort_order: f.sort_order ?? idx }));
        const originalIds = new Set(originalItems.filter((f) => f.id).map((f) => f.id));
        const currentItems = features2.map((f, idx) => ({ ...f, sort_order: idx }));
        const currentIds = new Set(currentItems.filter((f) => f.id).map((f) => f.id));
        for (const id2 of originalIds) {
          if (!currentIds.has(id2)) {
            await contentApi.deleteFeature(id2);
          }
        }
        for (const item of currentItems) {
          const body = {
            icon: item.icon,
            title: item.title,
            description: item.description,
            badge: item.badge || "",
            badge_color: item.badge_color || null,
            sort_order: item.sort_order ?? 0,
            is_featured: item.is_featured || false,
            button_text: item.button_text || null,
            button_link: item.button_link || null
          };
          if (!item.id) {
            await contentApi.createFeature(sectionId, body);
          } else {
            await contentApi.updateFeature(item.id, body);
          }
        }
        try {
          const [sectionsRes, contactRes] = await Promise.all([
            contentApi.getAllSections(),
            contentApi.getContactInfo()
          ]);
          const unified = buildUnifiedContentFromDatabase(
            sectionsRes.success ? sectionsRes.data : [],
            contactRes.success ? contactRes.data : null
          );
          await contentApi.saveContent(unified, true);
        } catch (publishErr) {
          console.warn("Auto-publish after features update failed", publishErr);
        }
        showSaveNotification("Features updated and published", "success");
      } catch (err) {
        showSaveNotification(err instanceof Error ? err.message : "Failed to save features", "error");
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Section Title" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.title || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, title: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "Features"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Section Description" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              value: formData.description || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, description: e.target.value })),
              className: "w-full p-2 border border-border rounded h-20",
              placeholder: "Brief description of the features section"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              id: "features-visible",
              checked: formData.is_visible,
              onChange: (e) => setFormData((prev) => ({ ...prev, is_visible: e.target.checked })),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "features-visible", className: "text-sm", children: "Visible on website" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-border pt-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium", children: "Individual Features" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: addFeature,
              className: "button-secondary text-sm",
              children: "+ Add Feature"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: features2.map((feature, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `p-4 border rounded-lg ${feature.is_featured ? "border-primary/30 bg-primary/5" : "border-border"}`,
            onDragOver: (e) => e.preventDefault(),
            onDrop: (e) => handleDropOnCard(e, index),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1 mr-2", "aria-label": `Reorder feature ${index + 1}`, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        type: "button",
                        className: "px-2 py-1 text-xs rounded border border-border hover:bg-muted disabled:opacity-50",
                        onClick: () => moveFeature(index, index - 1),
                        disabled: index === 0,
                        "aria-label": "Move up",
                        children: ""
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        type: "button",
                        className: "px-2 py-1 text-xs rounded border border-border hover:bg-muted disabled:opacity-50",
                        onClick: () => moveFeature(index, index + 1),
                        disabled: index === features2.length - 1,
                        "aria-label": "Move down",
                        children: ""
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        type: "button",
                        className: "px-2 py-1 text-xs rounded border border-border hover:bg-muted cursor-move",
                        draggable: true,
                        onDragStart: (e) => handleDragStart(e, index),
                        "aria-label": "Drag to reorder",
                        title: "Drag to reorder",
                        children: ""
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "checkbox",
                      checked: !!feature.is_featured,
                      onChange: (e) => updateFeature(index, "is_featured", e.target.checked),
                      className: "rounded border-border"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: "Featured Card" }),
                  feature.is_featured && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs px-2 py-1 bg-primary text-primary-foreground rounded-full", children: "FEATURED" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: () => removeFeature(index),
                    className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-sm",
                    children: "Remove"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Icon" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      value: feature.icon,
                      onChange: (e) => updateFeature(index, "icon", e.target.value),
                      className: "w-full p-2 border border-border rounded text-sm",
                      placeholder: " or icon name"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Title" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      value: feature.title,
                      onChange: (e) => updateFeature(index, "title", e.target.value),
                      className: "w-full p-2 border border-border rounded text-sm",
                      placeholder: "Feature title"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Badge" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      value: feature.badge || "",
                      onChange: (e) => updateFeature(index, "badge", e.target.value),
                      className: "w-full p-2 border border-border rounded text-sm",
                      placeholder: "New, Coming Soon"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Badge Color" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "select",
                    {
                      value: feature.badge_color || "green",
                      onChange: (e) => updateFeature(index, "badge_color", e.target.value),
                      className: "w-full p-2 border border-border rounded text-sm",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "green", children: "Green" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "blue", children: "Blue" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "orange", children: "Orange" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "purple", children: "Purple" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "red", children: "Red" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "yellow", children: "Yellow" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "pink", children: "Pink" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "gray", children: "Gray" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "md:col-span-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Description" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      value: feature.description,
                      onChange: (e) => updateFeature(index, "description", e.target.value),
                      className: "w-full p-2 border border-border rounded text-sm h-20",
                      placeholder: "Feature description"
                    }
                  )
                ] })
              ] }),
              feature.is_featured && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-t border-border/50 pt-3 mt-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Button Text" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      value: feature.button_text || "",
                      onChange: (e) => updateFeature(index, "button_text", e.target.value),
                      className: "w-full p-2 border border-border rounded text-sm",
                      placeholder: "Learn More"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Button Link" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      value: feature.button_link || "",
                      onChange: (e) => updateFeature(index, "button_link", e.target.value),
                      className: "w-full p-2 border border-border rounded text-sm",
                      placeholder: "/pricing or https://example.com"
                    }
                  )
                ] })
              ] }) })
            ]
          },
          index
        )) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: saveFeatures,
          className: "button w-full",
          children: section ? "Update Features Section" : "Create Features Section"
        }
      )
    ] });
  };
  const renderPricingForm = (section) => {
    const [formData, setFormData] = reactExports.useState(
      section || {
        section_type: "pricing",
        is_visible: true,
        title: "",
        description: "",
        isComingSoon: false
      }
    );
    const [plans, setPlans] = reactExports.useState(
      (section == null ? void 0 : section.plans) || []
    );
    const addPlan = () => {
      const newPlan = {
        name: "New Plan",
        price: "$0",
        period: "month",
        description: "Plan description",
        features: [],
        is_popular: false,
        button_text: "Get Started",
        button_link: "#"
      };
      setPlans([...plans, newPlan]);
    };
    const updatePlan = (index, field, value) => {
      const updatedPlans = plans.map(
        (plan, i) => i === index ? { ...plan, [field]: value } : plan
      );
      setPlans(updatedPlans);
    };
    const removePlan = (index) => {
      setPlans(plans.filter((_, i) => i !== index));
    };
    const addFeatureToPlan = (planIndex) => {
      const updatedPlans = [...plans];
      if (!updatedPlans[planIndex].features) {
        updatedPlans[planIndex].features = [];
      }
      updatedPlans[planIndex].features.push("New feature");
      setPlans(updatedPlans);
    };
    const updatePlanFeature = (planIndex, featureIndex, value) => {
      const updatedPlans = [...plans];
      updatedPlans[planIndex].features[featureIndex] = value;
      setPlans(updatedPlans);
    };
    const removePlanFeature = (planIndex, featureIndex) => {
      const updatedPlans = [...plans];
      updatedPlans[planIndex].features.splice(featureIndex, 1);
      setPlans(updatedPlans);
    };
    const savePricing = async () => {
      const sectionToSave = {
        ...formData,
        section_data: {
          title: formData.title,
          description: formData.description,
          isComingSoon: formData.isComingSoon,
          plans
        }
      };
      await saveSection(sectionToSave);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Section Title" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.title || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, title: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "Pricing"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Section Description" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              value: formData.description || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, description: e.target.value })),
              className: "w-full p-2 border border-border rounded h-20",
              placeholder: "Brief description of the pricing section"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              id: "pricing-visible",
              checked: formData.is_visible,
              onChange: (e) => setFormData((prev) => ({ ...prev, is_visible: e.target.checked })),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "pricing-visible", className: "text-sm", children: "Visible on website" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              id: "pricing-coming-soon",
              checked: formData.isComingSoon,
              onChange: (e) => setFormData((prev) => ({ ...prev, isComingSoon: e.target.checked })),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "pricing-coming-soon", className: "text-sm", children: "Coming Soon Mode" })
        ] })
      ] }),
      !formData.isComingSoon && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-border pt-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium", children: "Pricing Plans" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: addPlan,
              className: "button-secondary text-sm",
              children: "+ Add Plan"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-6", children: plans.map((plan, planIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-4 border rounded-lg ${plan.is_popular ? "border-primary/30 bg-primary/5" : "border-border"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  checked: !!plan.is_popular,
                  onChange: (e) => updatePlan(planIndex, "is_popular", e.target.checked),
                  className: "rounded border-border"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: "Featured Plan" }),
              plan.is_popular && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs px-2 py-1 bg-primary text-primary-foreground rounded-full", children: "POPULAR" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => removePlan(planIndex),
                className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-sm",
                children: "Remove Plan"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3 mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Plan Name" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: plan.name,
                  onChange: (e) => updatePlan(planIndex, "name", e.target.value),
                  className: "w-full p-2 border border-border rounded text-sm",
                  placeholder: "Starter, Pro, Enterprise"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Price" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: plan.price,
                  onChange: (e) => updatePlan(planIndex, "price", e.target.value),
                  className: "w-full p-2 border border-border rounded text-sm",
                  placeholder: "$19, Free, Custom"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Period" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  value: plan.period || "month",
                  onChange: (e) => updatePlan(planIndex, "period", e.target.value),
                  className: "w-full p-2 border border-border rounded text-sm",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "month", children: "per month" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "year", children: "per year" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "one-time", children: "one-time" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "custom", children: "custom" })
                  ]
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Description" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                value: plan.description,
                onChange: (e) => updatePlan(planIndex, "description", e.target.value),
                className: "w-full p-2 border border-border rounded text-sm h-20",
                placeholder: "Plan description"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-3 mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Button Text" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: plan.button_text || "",
                  onChange: (e) => updatePlan(planIndex, "button_text", e.target.value),
                  className: "w-full p-2 border border-border rounded text-sm",
                  placeholder: "Get Started, Contact Sales"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Button Link" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: plan.button_link || "",
                  onChange: (e) => updatePlan(planIndex, "button_link", e.target.value),
                  className: "w-full p-2 border border-border rounded text-sm",
                  placeholder: "/signup, /contact"
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-border/50 pt-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "text-sm font-medium", children: "Features" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => addFeatureToPlan(planIndex),
                  className: "text-primary hover:bg-primary/10 px-2 py-1 rounded text-xs",
                  children: "+ Add Feature"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: (plan.features || []).map((feature, featureIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: feature,
                  onChange: (e) => updatePlanFeature(planIndex, featureIndex, e.target.value),
                  className: "flex-1 p-2 border border-border rounded text-sm",
                  placeholder: "Feature description"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => removePlanFeature(planIndex, featureIndex),
                  className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-xs",
                  children: "Remove"
                }
              )
            ] }, featureIndex)) })
          ] })
        ] }, planIndex)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: savePricing,
          className: "button w-full",
          children: section ? "Update Pricing Section" : "Create Pricing Section"
        }
      )
    ] });
  };
  const renderCTAForm = (section) => {
    const [formData, setFormData] = reactExports.useState(
      section || {
        section_type: "cta",
        is_visible: true,
        title: "",
        description: "",
        primary_button: "",
        secondary_button: ""
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Title" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.title || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, title: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "Ready to get started?"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Description" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: formData.description || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, description: e.target.value })),
            className: "w-full p-2 border border-border rounded h-24",
            placeholder: "Call to action description"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Primary Button" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.primary_button || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, primary_button: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "Start Free Trial"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Secondary Button" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.secondary_button || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, secondary_button: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "Schedule Demo"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            id: "cta-visible",
            checked: formData.is_visible,
            onChange: (e) => setFormData((prev) => ({ ...prev, is_visible: e.target.checked })),
            className: "rounded border-border"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "cta-visible", className: "text-sm", children: "Visible on website" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: async () => {
            await saveSection(formData);
          },
          className: "button",
          children: section ? "Update CTA Section" : "Create CTA Section"
        }
      )
    ] }) });
  };
  const renderWaitlistForm = (section) => {
    const [formData, setFormData] = reactExports.useState(
      section || {
        section_type: "waitlist",
        is_visible: true,
        title: "",
        description: "",
        button_text: "",
        success_message: ""
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Title" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.title || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, title: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "Join the Waitlist"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Description" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: formData.description || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, description: e.target.value })),
            className: "w-full p-2 border border-border rounded h-24",
            placeholder: "Be the first to know when we launch..."
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Button Text" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.button_text || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, button_text: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "Join Waitlist"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Success Message" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: formData.success_message || "",
            onChange: (e) => setFormData((prev) => ({ ...prev, success_message: e.target.value })),
            className: "w-full p-2 border border-border rounded",
            placeholder: "Thank you for joining our waitlist!"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            id: "waitlist-visible",
            checked: formData.is_visible,
            onChange: (e) => setFormData((prev) => ({ ...prev, is_visible: e.target.checked })),
            className: "rounded border-border"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "waitlist-visible", className: "text-sm", children: "Visible on website" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: async () => {
            await saveSection(formData);
          },
          className: "button",
          children: section ? "Update Waitlist Section" : "Create Waitlist Section"
        }
      )
    ] }) });
  };
  const renderHeaderForm = (section) => {
    const [formData, setFormData] = reactExports.useState(
      section || {
        section_type: "header",
        is_visible: true,
        logo_text: "",
        sign_in_text: "Sign In",
        get_started_text: "Get Started",
        sign_in_href: "",
        get_started_href: "",
        show_sign_in: true,
        show_get_started: true
      }
    );
    const [navigationItems, setNavigationItems] = reactExports.useState(
      (section == null ? void 0 : section.navigation_items) || []
    );
    const addNavigationItem = () => {
      const newItem = {
        label: "New Link",
        href: "#",
        sort_order: navigationItems.length
      };
      setNavigationItems([...navigationItems, newItem]);
    };
    const updateNavigationItem = (index, field, value) => {
      const updatedItems = navigationItems.map(
        (item, i) => i === index ? { ...item, [field]: value } : item
      );
      setNavigationItems(updatedItems);
    };
    const removeNavigationItem = (index) => {
      setNavigationItems(navigationItems.filter((_, i) => i !== index));
    };
    const moveNavigationItem = (index, direction) => {
      const newItems = [...navigationItems];
      const targetIndex = direction === "up" ? index - 1 : index + 1;
      if (targetIndex >= 0 && targetIndex < newItems.length) {
        [newItems[index], newItems[targetIndex]] = [newItems[targetIndex], newItems[index]];
        newItems.forEach((item, i) => {
          item.sort_order = i;
        });
        setNavigationItems(newItems);
      }
    };
    const saveHeader = async () => {
      var _a;
      let sectionId = section == null ? void 0 : section.id;
      try {
        const payload = {
          section_type: "header",
          is_visible: formData.is_visible !== false,
          section_data: {
            logo_text: formData.logo_text,
            sign_in_text: formData.sign_in_text,
            get_started_text: formData.get_started_text,
            sign_in_href: formData.sign_in_href,
            get_started_href: formData.get_started_href,
            show_sign_in: formData.show_sign_in,
            show_get_started: formData.show_get_started
          }
        };
        if (!sectionId) {
          const createRes = await contentApi.createSection(payload);
          if (!createRes.success || !((_a = createRes.data) == null ? void 0 : _a.id)) throw new Error(createRes.error || "Failed to create header section");
          sectionId = createRes.data.id;
        } else {
          const updateRes = await contentApi.updateSection(sectionId, payload);
          if (!updateRes.success) throw new Error(updateRes.error || "Failed to update header section");
        }
        if (!sectionId) throw new Error("Header section ID unavailable");
        const originalItems = ((section == null ? void 0 : section.navigation_items) || []).map((i, idx) => ({ ...i, sort_order: i.sort_order ?? idx }));
        const originalIds = new Set(originalItems.filter((i) => i.id).map((i) => i.id));
        const currentItems = navigationItems.map((i, idx) => ({ ...i, sort_order: idx }));
        const currentIds = new Set(currentItems.filter((i) => i.id).map((i) => i.id));
        for (const id2 of originalIds) {
          if (!currentIds.has(id2)) {
            await contentApi.deleteNavigationItem(id2);
          }
        }
        for (const item of currentItems) {
          if (!item.id) {
            await contentApi.createNavigationItem(sectionId, {
              label: item.label,
              href: item.href,
              sort_order: item.sort_order ?? 0,
              type: item.type,
              isExternal: item.isExternal,
              nofollow: item.nofollow,
              isButton: item.isButton
            });
          } else {
            await contentApi.updateNavigationItem(item.id, {
              label: item.label,
              href: item.href,
              sort_order: item.sort_order ?? 0,
              type: item.type,
              isExternal: item.isExternal,
              nofollow: item.nofollow,
              isButton: item.isButton
            });
          }
        }
        showSaveNotification("Header updated successfully", "success");
      } catch (err) {
        showSaveNotification(err instanceof Error ? err.message : "Failed to save header", "error");
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Logo Text" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.logo_text || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, logo_text: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "BiblioKit"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Sign In Text" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.sign_in_text || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, sign_in_text: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "Sign In"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Sign In Link" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.sign_in_href || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, sign_in_href: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "/admin or /login"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Get Started Text" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.get_started_text || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, get_started_text: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "Get Started"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Get Started Link" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: formData.get_started_href || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, get_started_href: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: "/#contact or /signup"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              id: "header-visible",
              checked: formData.is_visible,
              onChange: (e) => setFormData((prev) => ({ ...prev, is_visible: e.target.checked })),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "header-visible", className: "text-sm", children: "Visible on website" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                checked: formData.show_sign_in !== false,
                onChange: (e) => setFormData((prev) => ({ ...prev, show_sign_in: e.target.checked })),
                className: "rounded border-border"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: "Show Sign In Button" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                checked: formData.show_get_started !== false,
                onChange: (e) => setFormData((prev) => ({ ...prev, show_get_started: e.target.checked })),
                className: "rounded border-border"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: "Show Get Started Button" })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-border pt-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium", children: "Navigation Items" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: addNavigationItem,
              className: "button-secondary text-sm",
              children: "+ Add Navigation Item"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: navigationItems.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-4 border rounded-lg ${item.isButton ? "border-primary/30 bg-primary/5" : "border-border"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-medium", children: [
                "#",
                index + 1
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "checkbox",
                    checked: !!item.isButton,
                    onChange: (e) => updateNavigationItem(index, "isButton", e.target.checked),
                    className: "rounded border-border"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: "Button Style" }),
                item.isButton && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs px-2 py-1 bg-primary text-primary-foreground rounded-full", children: "BUTTON" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => moveNavigationItem(index, "up"),
                  disabled: index === 0,
                  className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1",
                  title: "Move up",
                  children: ""
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => moveNavigationItem(index, "down"),
                  disabled: index === navigationItems.length - 1,
                  className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1",
                  title: "Move down",
                  children: ""
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => removeNavigationItem(index),
                  className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-sm",
                  children: "Remove"
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Link Text" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: item.label,
                  onChange: (e) => updateNavigationItem(index, "label", e.target.value),
                  className: "w-full p-2 border border-border rounded text-sm",
                  placeholder: "Home, About, Pricing"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Link URL" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: item.href,
                  onChange: (e) => updateNavigationItem(index, "href", e.target.value),
                  className: "w-full p-2 border border-border rounded text-sm",
                  placeholder: "/about, #pricing, https://example.com"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs font-medium mb-1", children: "Link Type" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  value: item.type || "link",
                  onChange: (e) => updateNavigationItem(index, "type", e.target.value),
                  className: "w-full p-2 border border-border rounded text-sm",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "link", children: "Regular Link" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "scroll", children: "Scroll to Section" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "external", children: "External Link" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "dropdown", children: "Dropdown Menu" })
                  ]
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-3 pt-3 border-t border-border/50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  checked: !!item.isExternal,
                  onChange: (e) => updateNavigationItem(index, "isExternal", e.target.checked),
                  className: "rounded border-border"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs", children: "Open in new tab" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex items-center gap-2 cursor-pointer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "checkbox",
                  checked: !!item.nofollow,
                  onChange: (e) => updateNavigationItem(index, "nofollow", e.target.checked),
                  className: "rounded border-border"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs", children: 'Add rel="nofollow"' })
            ] })
          ] }) }),
          item.type === "dropdown" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-3 pt-3 border-t border-border/50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs font-medium mb-2", children: "Dropdown Items" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-muted-foreground", children: "Dropdown menu functionality requires additional implementation for nested items management." })
          ] })
        ] }, index)) }),
        navigationItems.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-8 text-muted-foreground", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm", children: "No navigation items yet." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs", children: 'Click "Add Navigation Item" to get started.' })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: saveHeader,
          className: "button w-full",
          children: section ? "Update Header Section" : "Create Header Section"
        }
      )
    ] });
  };
  const renderFooterForm = (section) => {
    const [formData, setFormData] = reactExports.useState(
      section || {
        section_type: "footer",
        is_visible: true,
        description: "",
        copyright_text: ""
      }
    );
    const initialGroups = (() => {
      var _a;
      const fromRel = section == null ? void 0 : section.footer_links;
      if (fromRel && Array.isArray(fromRel) && fromRel.length > 0) {
        return fromRel.map((group) => ({
          id: group.id,
          title: group.title || "",
          sort_order: group.sort_order || 0,
          links: (group.links || []).map((l2) => ({
            id: l2.id,
            label: l2.label || "",
            href: l2.href || "",
            sort_order: l2.sort_order || 0
          }))
        }));
      }
      const fromJson = (_a = section == null ? void 0 : section.section_data) == null ? void 0 : _a.sections;
      if (fromJson && Array.isArray(fromJson)) {
        return fromJson.map((group) => ({
          title: group.title || "",
          sort_order: group.sort_order || 0,
          links: (group.links || []).map((l2) => ({
            label: l2.label || "",
            href: l2.href || "",
            sort_order: l2.sort_order || 0
          }))
        }));
      }
      return [];
    })();
    const [linkGroups, setLinkGroups] = reactExports.useState(initialGroups);
    const addGroup = () => {
      setLinkGroups((prev) => [
        ...prev,
        { title: "New Group", links: [], sort_order: prev.length }
      ]);
    };
    const updateGroupTitle = (index, title) => {
      setLinkGroups((prev) => prev.map((g, i) => i === index ? { ...g, title } : g));
    };
    const removeGroup = (index) => {
      setLinkGroups((prev) => prev.filter((_, i) => i !== index).map((g, i2) => ({ ...g, sort_order: i2 })));
    };
    const moveGroup = (index, direction) => {
      setLinkGroups((prev) => {
        const arr = [...prev];
        const target = direction === "up" ? index - 1 : index + 1;
        if (target < 0 || target >= arr.length) return prev;
        [arr[index], arr[target]] = [arr[target], arr[index]];
        return arr.map((g, i) => ({ ...g, sort_order: i }));
      });
    };
    const addLinkToGroup = (groupIndex) => {
      setLinkGroups((prev) => prev.map((g, i) => i === groupIndex ? { ...g, links: [...g.links, { label: "New Link", href: "#", sort_order: g.links.length }] } : g));
    };
    const updateLinkInGroup = (groupIndex, linkIndex, field, value) => {
      setLinkGroups((prev) => prev.map((g, i) => {
        if (i !== groupIndex) return g;
        const links = g.links.map((l2, li) => li === linkIndex ? { ...l2, [field]: value } : l2);
        return { ...g, links };
      }));
    };
    const removeLinkFromGroup = (groupIndex, linkIndex) => {
      setLinkGroups((prev) => prev.map((g, i) => {
        if (i !== groupIndex) return g;
        const links = g.links.filter((_, li) => li !== linkIndex).map((l2, li2) => ({ ...l2, sort_order: li2 }));
        return { ...g, links };
      }));
    };
    const moveLinkInGroup = (groupIndex, linkIndex, direction) => {
      setLinkGroups((prev) => prev.map((g, i) => {
        if (i !== groupIndex) return g;
        const links = [...g.links];
        const target = direction === "up" ? linkIndex - 1 : linkIndex + 1;
        if (target < 0 || target >= links.length) return g;
        [links[linkIndex], links[target]] = [links[target], links[linkIndex]];
        return { ...g, links: links.map((l2, li) => ({ ...l2, sort_order: li })) };
      }));
    };
    const saveFooter = async () => {
      var _a, _b;
      let sectionId = section == null ? void 0 : section.id;
      try {
        const payload = {
          section_type: "footer",
          is_visible: formData.is_visible !== false,
          section_data: {
            description: formData.description || "",
            copyright_text: (formData == null ? void 0 : formData.copyright_text) || ""
          }
        };
        if (!sectionId) {
          const createRes = await contentApi.createSection(payload);
          if (!createRes.success || !((_a = createRes.data) == null ? void 0 : _a.id)) throw new Error(createRes.error || "Failed to create footer section");
          sectionId = createRes.data.id;
        } else {
          const updateRes = await contentApi.updateSection(sectionId, payload);
          if (!updateRes.success) throw new Error(updateRes.error || "Failed to update footer section");
        }
        if (!sectionId) throw new Error("Footer section ID unavailable");
        const originalGroups = ((section == null ? void 0 : section.footer_links) || []).map((g, gi) => ({
          ...g,
          sort_order: g.sort_order ?? gi,
          links: (g.links || []).map((l2, li) => ({ ...l2, sort_order: l2.sort_order ?? li }))
        }));
        const originalGroupIdSet = new Set(originalGroups.filter((g) => g.id).map((g) => g.id));
        const currentGroups = linkGroups.map((g, gi) => ({ ...g, sort_order: gi }));
        const currentGroupIdSet = new Set(currentGroups.filter((g) => g.id).map((g) => g.id));
        for (const gid of originalGroupIdSet) {
          if (!currentGroupIdSet.has(gid)) {
            await contentApi.deleteFooterLinkGroup(gid);
          }
        }
        for (const group of currentGroups) {
          let groupId = group.id;
          if (!groupId) {
            const created = await contentApi.createFooterLinkGroup(sectionId, group.title, group.sort_order ?? 0);
            if (!created.success || !((_b = created.data) == null ? void 0 : _b.id)) throw new Error(created.error || "Failed to create footer group");
            groupId = created.data.id;
          } else {
            await contentApi.updateFooterLinkGroup(groupId, { title: group.title, sort_order: group.sort_order ?? 0 });
          }
          const originalGroup = originalGroups.find((g) => g.id === group.id);
          const originalLinks = (originalGroup == null ? void 0 : originalGroup.links) || [];
          const originalLinkIdSet = new Set(originalLinks.filter((l2) => l2.id).map((l2) => l2.id));
          const currentLinks = (group.links || []).map((l2, li) => ({ ...l2, sort_order: li }));
          const currentLinkIdSet = new Set(currentLinks.filter((l2) => l2.id).map((l2) => l2.id));
          for (const lid of originalLinkIdSet) {
            if (!currentLinkIdSet.has(lid)) {
              await contentApi.deleteFooterLink(lid);
            }
          }
          for (const link of currentLinks) {
            if (!link.id) {
              await contentApi.createFooterLink(groupId, { label: link.label, href: link.href, sort_order: link.sort_order ?? 0 });
            } else {
              await contentApi.updateFooterLink(link.id, { label: link.label, href: link.href, sort_order: link.sort_order ?? 0 });
            }
          }
        }
        showSaveNotification("Footer updated successfully", "success");
      } catch (err) {
        showSaveNotification(err instanceof Error ? err.message : "Failed to save footer", "error");
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Description" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              value: formData.description || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, description: e.target.value })),
              className: "w-full p-2 border border-border rounded h-24",
              placeholder: "Footer description"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-2", children: "Copyright Text" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: (formData == null ? void 0 : formData.copyright_text) || "",
              onChange: (e) => setFormData((prev) => ({ ...prev, copyright_text: e.target.value })),
              className: "w-full p-2 border border-border rounded",
              placeholder: ` ${(/* @__PURE__ */ new Date()).getFullYear()} BiblioKit. All rights reserved.`
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "checkbox",
              id: "footer-visible",
              checked: formData.is_visible,
              onChange: (e) => setFormData((prev) => ({ ...prev, is_visible: e.target.checked })),
              className: "rounded border-border"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "footer-visible", className: "text-sm", children: "Visible on website" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-border pt-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium", children: "Footer Link Groups" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: addGroup, className: "button-secondary text-sm", children: "+ Add Group" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: linkGroups.map((group, gi) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border rounded-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-medium", children: [
                "Group #",
                gi + 1
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: group.title,
                  onChange: (e) => updateGroupTitle(gi, e.target.value),
                  className: "p-2 border border-border rounded text-sm",
                  placeholder: "Group title (e.g., Product)"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => moveGroup(gi, "up"), disabled: gi === 0, className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1", title: "Move up", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => moveGroup(gi, "down"), disabled: gi === linkGroups.length - 1, className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1", title: "Move down", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => removeGroup(gi), className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-sm", children: "Remove" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-3 pt-3 border-t border-border/50", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-medium", children: "Links" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => addLinkToGroup(gi), className: "text-primary hover:bg-primary/10 px-2 py-1 rounded text-xs", children: "+ Add Link" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: group.links.map((link, li) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-3 items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: link.label,
                  onChange: (e) => updateLinkInGroup(gi, li, "label", e.target.value),
                  className: "p-2 border border-border rounded text-sm",
                  placeholder: "Link label (e.g., Pricing)"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    value: link.href,
                    onChange: (e) => updateLinkInGroup(gi, li, "href", e.target.value),
                    className: "flex-1 p-2 border border-border rounded text-sm",
                    placeholder: "#pricing or https://example.com"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => moveLinkInGroup(gi, li, "up"), disabled: li === 0, className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1", title: "Move up", children: "" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => moveLinkInGroup(gi, li, "down"), disabled: li === group.links.length - 1, className: "text-gray-500 hover:text-gray-700 disabled:opacity-50 px-2 py-1", title: "Move down", children: "" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => removeLinkFromGroup(gi, li), className: "text-red-600 hover:bg-red-50 px-2 py-1 rounded text-sm", children: "Remove" })
              ] })
            ] }, li)) })
          ] })
        ] }, gi)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: saveFooter, className: "button w-full", children: section ? "Update Footer Section" : "Create Footer Section" })
    ] });
  };
  if (showLogin && !isAuthenticated) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AdminLogin, { onClose: () => setShowLogin(false) });
  }
  if (!showEditor) {
    if (isAuthenticated && isAdmin) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed bottom-4 right-4 z-50 flex flex-col gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: "/admin",
            className: "bg-amber-500 text-white p-3 rounded-full shadow-lg hover:bg-amber-600 transition-colors text-base text-center",
            title: "Admin Dashboard",
            "aria-label": "Admin Dashboard",
            children: ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setShowEditor(true),
            className: "bg-primary text-primary-foreground p-3 rounded-full shadow-lg hover:bg-primary/90 transition-colors",
            title: "Edit Content",
            children: ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: logout,
            className: "bg-red-600 text-white p-2 rounded-full shadow-lg hover:bg-red-700 transition-colors text-sm",
            title: "Logout",
            children: ""
          }
        )
      ] });
    } else {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setShowLogin(true),
          className: "fixed bottom-4 right-4 bg-muted text-muted-foreground p-2 rounded-full shadow-lg hover:bg-muted/80 transition-colors z-50 text-xs",
          title: "Admin Access",
          children: ""
        }
      );
    }
  }
  if (!isAuthenticated || !isAdmin) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4", children: [
    saveNotification && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `fixed top-4 right-4 z-[60] px-4 py-2 rounded-lg shadow-lg transition-all duration-300 ${saveNotification.type === "success" ? "bg-green-500 text-white" : saveNotification.type === "error" ? "bg-red-500 text-white" : "bg-blue-500 text-white"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: saveNotification.type === "success" ? "" : saveNotification.type === "error" ? "" : "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: saveNotification.message })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background border border-border rounded-lg w-full max-w-6xl max-h-[90vh] flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-b border-border", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-semibold", children: "Content Editor" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
            databaseAvailable && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setEditMode("database"),
                className: `px-3 py-1 text-sm rounded ${editMode === "database" ? "bg-primary text-primary-foreground" : "bg-muted text-muted-foreground"}`,
                children: "Database"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setEditMode("sections"),
                className: `px-3 py-1 text-sm rounded ${editMode === "sections" ? "bg-primary text-primary-foreground" : "bg-muted text-muted-foreground"}`,
                children: "Sections"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => setEditMode("json"),
                className: `px-3 py-1 text-sm rounded ${editMode === "json" ? "bg-primary text-primary-foreground" : "bg-muted text-muted-foreground"}`,
                children: "JSON"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleReset,
              className: "button-secondary text-sm",
              children: "Reset to Default"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleSave,
              className: "button text-sm",
              disabled: !isEditing,
              children: "Save & Reload"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setShowEditor(false),
              className: "button-secondary text-sm",
              children: "Close"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: logout,
              className: "bg-red-600 text-white px-3 py-1 rounded text-sm hover:bg-red-700",
              children: "Logout"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 p-4 overflow-auto", children: editMode === "sections" ? renderSectionEditor() : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground mb-4", children: 'Edit the JSON below to change the website content. Click "Save & Reload" to apply changes.' }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            value: jsonContent,
            onChange: (e) => {
              setJsonContent(e.target.value);
              setIsEditing(true);
            },
            className: "w-full h-full min-h-[500px] p-3 border border-border rounded-md font-mono text-sm bg-muted/20 resize-none",
            placeholder: "Edit JSON content here..."
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-t border-border bg-muted/20 text-sm text-muted-foreground", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Instructions:" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "list-disc list-inside space-y-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: editMode === "sections" ? "Use the section editor for easy content changes" : "Edit the JSON structure to change website content" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
            "Make sure to maintain valid ",
            editMode === "sections" ? "content" : "JSON syntax"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: 'Click "Save & Reload" to see changes immediately' }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Changes are saved in browser storage for this session" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: 'Use "Reset to Default" to restore original content' })
        ] })
      ] })
    ] })
  ] });
};
class AdminErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("AdminDashboard Error:", error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback();
    }
    return this.props.children;
  }
}
const AdminFallback = () => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen bg-gray-50 flex items-center justify-center p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg border border-gray-200 p-8 max-w-md text-center shadow-sm", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold text-gray-900 mb-4", children: "Admin Dashboard" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-6", children: "There was an issue loading the full admin dashboard. This fallback mode ensures basic access." }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-green-50 border border-green-200 rounded p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-green-800 text-sm", children: " Dashboard routing is working" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-blue-50 border border-blue-200 rounded p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-blue-800 text-sm", children: " Error boundary is active" }) })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 space-x-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => window.location.reload(),
        className: "bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700",
        children: " Reload Dashboard"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "a",
      {
        href: "/",
        className: "inline-block bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700",
        children: " Go Home"
      }
    )
  ] })
] }) });
const AdminDashboard = () => {
  const { isAuthenticated, isAdmin, email, logout, loading: authLoading } = useAuth();
  const [activeTab, setActiveTab] = reactExports.useState("content");
  const [waitlist2, setWaitlist] = reactExports.useState([]);
  const [waitlistLoading, setWaitlistLoading] = reactExports.useState(false);
  const [contentVersions, setContentVersions] = reactExports.useState([]);
  const [currentContent, setCurrentContent] = reactExports.useState(productData);
  const [loading, setLoading] = reactExports.useState(false);
  const [showContentEditor, setShowContentEditor] = reactExports.useState(false);
  const [showLoginModal, setShowLoginModal] = reactExports.useState(false);
  const tabs = [
    { id: "content", label: "Content Editor", icon: "" },
    { id: "versions", label: "Version History", icon: "" },
    { id: "waitlist", label: "Waitlist", icon: "" },
    { id: "settings", label: "Site Settings", icon: "" },
    { id: "analytics", label: "Analytics", icon: "" },
    { id: "designsystem", label: "Design System", icon: "" }
  ];
  console.log("AdminDashboard render:", { isAuthenticated, isAdmin, email, authLoading });
  const loadContentVersions = async () => {
    try {
      setLoading(true);
      const dbAvailable = await contentApi.isDatabaseAvailable();
      if (dbAvailable) {
        const response = await contentApi.getContentVersions();
        if (response.success && response.data) {
          setContentVersions(response.data);
        }
      } else {
        const history2 = localStorage.getItem("bibliokit-content-history");
        if (history2) {
          const localVersions = JSON.parse(history2);
          const converted = localVersions.map((v) => ({
            id: parseInt(v.id),
            content_key: "main",
            content_data: v.content,
            version: v.version,
            is_published: v.is_published,
            created_at: v.created_at,
            updated_at: v.created_at
          }));
          setContentVersions(converted);
        }
      }
    } catch (error) {
      console.error("Failed to load content versions:", error);
    } finally {
      setLoading(false);
    }
  };
  const loadWaitlist = async () => {
    try {
      setWaitlistLoading(true);
      const result = await contentApi.getWaitlistSignups(100, 0);
      if (result.success && result.data) {
        setWaitlist(result.data);
      }
    } catch (error) {
      console.error("Failed to load waitlist:", error);
    } finally {
      setWaitlistLoading(false);
    }
  };
  reactExports.useEffect(() => {
    const loadCurrent = () => {
      const saved = localStorage.getItem("bibliokit-content");
      if (saved) {
        try {
          setCurrentContent(JSON.parse(saved));
        } catch (error) {
          console.error("Failed to load current content:", error);
        }
      }
    };
    loadContentVersions();
    loadCurrent();
    loadWaitlist();
  }, []);
  reactExports.useEffect(() => {
    const applyHash = () => {
      const hash = (window.location.hash || "").replace("#", "");
      if (!hash) return;
      const validIds = tabs.map((t) => t.id);
      if (validIds.includes(hash)) {
        setActiveTab(hash);
      }
    };
    applyHash();
    window.addEventListener("hashchange", applyHash);
    return () => window.removeEventListener("hashchange", applyHash);
  }, []);
  reactExports.useEffect(() => {
    const nextHash = `#${activeTab}`;
    if (window.location.hash !== nextHash) {
      window.location.hash = nextHash;
    }
  }, [activeTab]);
  if (authLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen bg-gray-100 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center bg-white p-8 rounded-lg shadow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold text-gray-900 mb-2", children: "Checking Access..." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: "Please wait while we verify your credentials." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-red-600 mt-2", children: [
        "Debug: authLoading = ",
        String(authLoading)
      ] })
    ] }) });
  }
  if (!isAuthenticated || !isAdmin) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen bg-gray-100 flex items-center justify-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto px-4 py-16 text-center max-w-md", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-lg border p-8 shadow", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold mb-4 text-gray-900", children: "Admin Access Required" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-8", children: "Please sign in with your admin credentials to access the dashboard." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-red-600 mb-4", children: [
          "Debug: isAuth=",
          String(isAuthenticated),
          ", isAdmin=",
          String(isAdmin)
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row gap-3 justify-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setShowLoginModal(true),
              className: "bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700",
              children: " Sign In"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/", className: "bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700", children: "Go Home" })
        ] })
      ] }) }),
      showLoginModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
        AdminLogin,
        {
          onClose: () => setShowLoginModal(false)
        }
      )
    ] });
  }
  const publishContent = async () => {
    try {
      setLoading(true);
      const dbAvailable = await contentApi.isDatabaseAvailable();
      if (dbAvailable) {
        const response = await contentApi.saveContent(currentContent, true);
        if (response.success) {
          alert(response.message || "Content published successfully!");
          await loadContentVersions();
        } else {
          throw new Error(response.error || "Failed to publish");
        }
      } else {
        const newVersion = {
          id: Date.now(),
          content_key: "main",
          content_data: currentContent,
          version: contentVersions.length + 1,
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          updated_at: (/* @__PURE__ */ new Date()).toISOString(),
          is_published: true
        };
        const updatedVersions = [...contentVersions, newVersion];
        setContentVersions(updatedVersions);
        localStorage.setItem("bibliokit-content-history", JSON.stringify(updatedVersions));
        localStorage.setItem("bibliokit-content", JSON.stringify(currentContent));
        alert("Content published successfully! (saved locally)");
      }
    } catch (error) {
      console.error("Failed to publish content:", error);
      alert("Failed to publish content: " + (error instanceof Error ? error.message : "Unknown error"));
    } finally {
      setLoading(false);
    }
  };
  const revertToVersion = (version) => {
    const contentData = version.content_data;
    setCurrentContent(contentData);
    localStorage.setItem("bibliokit-content", JSON.stringify(contentData));
    alert(`Reverted to version ${version.version}`);
    window.location.reload();
  };
  const exportContent = () => {
    const dataStr = JSON.stringify(currentContent, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `bibliokit-content-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
    link.click();
    URL.revokeObjectURL(url);
  };
  const importContent = (event) => {
    var _a;
    const file = (_a = event.target.files) == null ? void 0 : _a[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        var _a2;
        try {
          const imported = JSON.parse((_a2 = e.target) == null ? void 0 : _a2.result);
          setCurrentContent(imported);
          localStorage.setItem("bibliokit-content", JSON.stringify(imported));
          alert("Content imported successfully!");
          window.location.reload();
        } catch (error) {
          alert("Invalid JSON file");
        }
      };
      reader.readAsText(file);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen bg-muted/20 pt-16", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-background border-b border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold", children: "Admin Dashboard" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: "Manage your BiblioKit content and settings" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-muted-foreground", children: [
            "Logged in as: ",
            email
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: logout, className: "button-secondary", children: "Logout" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 mt-6", children: tabs.map((tab) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: () => setActiveTab(tab.id),
          className: `px-4 py-2 text-sm font-medium transition-colors ${activeTab === tab.id ? "bg-primary text-primary-foreground" : "text-muted-foreground hover:text-foreground hover:bg-muted"}`,
          style: { borderRadius: "6px" },
          children: [
            tab.icon,
            " ",
            tab.label
          ]
        },
        tab.id
      )) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-8", children: [
      activeTab === "content" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background rounded-lg border p-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold", children: "Content Management" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => setShowContentEditor(true),
                  className: "button",
                  children: " Edit Content"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: publishContent,
                  disabled: loading,
                  className: "button-secondary",
                  children: " Publish Changes"
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4 text-sm", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-muted/30 p-4 rounded", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-2", children: "Current Version" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-muted-foreground", children: [
                "Last modified: ",
                (/* @__PURE__ */ new Date()).toLocaleDateString()
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-muted/30 p-4 rounded", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-2", children: "Total Versions" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-muted-foreground", children: [
                contentVersions.length,
                " saved versions"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-muted/30 p-4 rounded", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium mb-2", children: "Status" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-green-600 font-medium", children: "Published" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background rounded-lg border p-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold mb-4", children: "Quick Actions" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: exportContent, className: "button-secondary", children: " Export Content" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "button-secondary cursor-pointer", children: [
              " Import Content",
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "file",
                  accept: ".json",
                  onChange: importContent,
                  className: "hidden"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/", className: "button-secondary", children: " Preview Site" })
          ] })
        ] })
      ] }),
      activeTab === "versions" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background rounded-lg border p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold mb-6", children: "Version History" }),
        contentVersions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground text-center py-8", children: "No version history available. Start by making some changes to your content." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: [...contentVersions].reverse().map((version) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border border-border rounded-lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "font-medium", children: [
              "Version ",
              version.version
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: new Date(version.created_at).toLocaleString() })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded text-xs ${version.is_published ? "bg-green-100 text-green-700" : "bg-gray-100 text-gray-700"}`, children: version.is_published ? "Published" : "Draft" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => revertToVersion(version),
                className: "button-secondary text-sm",
                children: "Revert"
              }
            )
          ] })
        ] }, version.id)) })
      ] }),
      activeTab === "settings" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background rounded-lg border p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold mb-6", children: "Site Settings" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium mb-3", children: "Security" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-3 border border-border rounded", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Admin Authentication" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-600 font-medium", children: " Enabled" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-3 border border-border rounded", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Content Editor Protection" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-600 font-medium", children: " Active" })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium mb-3", children: "Content" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-3 border border-border rounded", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Auto-save" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-600 font-medium", children: " Enabled" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-3 border border-border rounded", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Version Control" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-600 font-medium", children: " Active" })
              ] })
            ] })
          ] })
        ] })
      ] }),
      activeTab === "waitlist" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background rounded-lg border p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb  -6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold", children: "Waitlist Signups" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "button-secondary",
                onClick: loadWaitlist,
                children: "Refresh"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "button",
                onClick: () => {
                  const csv = ["Email,Name,Source,Created At", ...waitlist2.map((w) => `${w.email},${w.name || ""},${w.source || ""},${new Date(w.created_at).toISOString()}`)].join("\n");
                  const blob = new Blob([csv], { type: "text/csv" });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement("a");
                  a.href = url;
                  a.download = `waitlist-${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.csv`;
                  a.click();
                  URL.revokeObjectURL(url);
                },
                children: "Export CSV"
              }
            )
          ] })
        ] }),
        waitlistLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-12 text-muted-foreground", children: "Loading..." }) : waitlist2.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-12 text-muted-foreground", children: "No waitlist signups yet." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "min-w-full text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "text-left border-b", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "py-2 pr-4", children: "Email" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "py-2 pr-4", children: "Name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "py-2 pr-4", children: "Source" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "py-2 pr-4", children: "Created" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: waitlist2.map((w) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "border-b last:border-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "py-2 pr-4", children: w.email }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "py-2 pr-4", children: w.name || "-" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "py-2 pr-4", children: w.source || "website" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "py-2 pr-4", children: new Date(w.created_at).toLocaleString() })
          ] }, w.id)) })
        ] }) })
      ] }),
      activeTab === "analytics" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background rounded-lg border p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold mb-6", children: "Site Analytics" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-muted/30 p-6 rounded-lg text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold text-primary", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg font-semibold mt-2", children: "Secure" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Admin protected" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-muted/30 p-6 rounded-lg text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold text-primary", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg font-semibold mt-2", children: "Live" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Site operational" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-muted/30 p-6 rounded-lg text-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold text-primary", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg font-semibold mt-2", children: "Fast" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Optimized delivery" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-8 p-4 bg-blue-50 border border-blue-200 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-blue-800", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Note:" }),
          " Detailed analytics integration with services like Google Analytics can be added in future updates."
        ] }) })
      ] }),
      activeTab === "designsystem" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-background rounded-lg border p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-semibold", children: "Design System" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground text-sm", children: "Internal reference for tokens and components." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DesignSystem, {})
      ] })
    ] }),
    showContentEditor && /* @__PURE__ */ jsxRuntimeExports.jsx(ContentEditor, { onContentUpdate: (content) => {
      setCurrentContent(content);
      setShowContentEditor(false);
    } })
  ] });
};
const AdminDashboardWithErrorBoundary = () => /* @__PURE__ */ jsxRuntimeExports.jsx(AdminErrorBoundary, { fallback: () => /* @__PURE__ */ jsxRuntimeExports.jsx(AdminFallback, {}), children: /* @__PURE__ */ jsxRuntimeExports.jsx(AdminDashboard, {}) });
const logoBundledUrl = "/assets/bkit_logo_f-LZ03yWIr.png";
const Header = () => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
  const { isAuthenticated, isAdmin } = useAuth();
  const { content } = usePublishedContent();
  const [location2] = useLocation();
  const [hasMounted, setHasMounted] = reactExports.useState(false);
  const [isScrolled, setIsScrolled] = reactExports.useState(false);
  const [isLogoBroken, setIsLogoBroken] = reactExports.useState(false);
  const [logoSrc, setLogoSrc] = reactExports.useState(logoBundledUrl);
  const handleLogoError = () => {
    if (logoSrc === logoBundledUrl) {
      setLogoSrc("/bkit_logo_f.png");
      return;
    }
    if (logoSrc === "/bkit_logo_f.png") {
      setLogoSrc("/bkit_logo_1.png");
      return;
    }
    if (logoSrc === "/bkit_logo_1.png") {
      setLogoSrc("/bkit_logo.png");
      return;
    }
    if (logoSrc === "/bkit_logo.png") {
      setLogoSrc("/logo.svg");
      return;
    }
    setIsLogoBroken(true);
  };
  reactExports.useEffect(() => {
    setHasMounted(true);
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 4);
    };
    handleScroll();
    window.addEventListener("scroll", handleScroll, { passive: true });
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);
  const isHomeRoute2 = location2 === "/";
  const slug = (location2 || "/").replace(/^\/+/, "").split("/")[0] || "";
  const isAdminEditor = location2.startsWith("/admin") || location2.startsWith("/editor");
  const isProductFromContent = !!((content == null ? void 0 : content.products) && slug && content.products[slug]);
  const isProductPathFallback = !!(slug && !["", "admin", "editor", "design-system", "test", "database"].includes(slug));
  const isProductLike = isProductFromContent || isProductPathFallback;
  const topClass = hasMounted && isAuthenticated && isAdmin ? isScrolled ? "top-10" : "top-14" : (isHomeRoute2 || isProductLike && !isAdminEditor) && !isScrolled ? "top-0" : isScrolled ? "top-0" : "top-4";
  const isTopTransparent = (isHomeRoute2 || isProductLike && !isAdminEditor) && !isScrolled;
  const positionClass = !hasMounted ? "absolute" : isTopTransparent ? "absolute" : "fixed";
  const shouldShowHeader = ((_b = (_a = content.settings) == null ? void 0 : _a.visibility) == null ? void 0 : _b.header) !== false;
  if (!shouldShowHeader) {
    return null;
  }
  const navItems = Array.isArray((_c = content.header) == null ? void 0 : _c.navigation) ? (_d = content.header) == null ? void 0 : _d.navigation : [];
  const hasDocsLink = navItems.some((item) => {
    const asLink = item;
    return asLink.label && asLink.label.toLowerCase() === "docs" || asLink.href && asLink.href.toLowerCase() === "/docs";
  });
  const navItemsWithDocs = hasDocsLink ? navItems : [...navItems, { label: "Docs", href: "/docs", type: "link" }];
  const resolveExternal = (item) => {
    if (typeof item.isExternal === "boolean") return item.isExternal;
    return item.type === "external";
  };
  const linkRel = (nofollow, external) => {
    const parts = [];
    if (external) parts.push("noopener", "noreferrer");
    if (nofollow) parts.push("nofollow");
    return parts.length ? parts.join(" ") : void 0;
  };
  const bgClass = !hasMounted ? "bg-transparent" : isScrolled ? "bg-background/80 backdrop-blur border-b border-border" : "bg-transparent";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: `${bgClass} ${positionClass} w-full ${topClass} z-50 transition-all duration-300`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 h-16 flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "a",
        {
          href: hasMounted && isAuthenticated && isAdmin ? "/admin" : "/",
          "aria-label": hasMounted && isAuthenticated && isAdmin ? "Go to Admin Dashboard" : "Go to Home",
          title: hasMounted && isAuthenticated && isAdmin ? "Go to Admin Dashboard" : "Go to Home",
          className: "flex items-center focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/50 rounded-sm",
          children: [
            !isLogoBroken && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: logoSrc,
                alt: "",
                "aria-hidden": "true",
                width: 32,
                height: 32,
                className: "w-8 h-8 mr-2 drop-shadow-sm",
                onError: handleLogoError
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-xl text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-blue-500", children: ((_e = content.header) == null ? void 0 : _e.logoText) || "BiblioKit" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "hidden md:flex items-center space-x-6", children: [
        navItemsWithDocs.map((item, index) => {
          if (item.type === "dropdown") {
            const dd = item;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative group", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "text-sm font-medium hover:text-primary transition-colors flex items-center", children: [
                dd.label,
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-4 h-4 ml-1", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-0 mt-1 w-56 bg-white border border-gray-200 rounded-md shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-2", children: (dd.children || []).map((child, ci) => {
                const href2 = child.href || "#";
                const normalizedHref2 = href2.startsWith("#") ? `/${href2}` : href2;
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "a",
                  {
                    href: normalizedHref2,
                    target: child.isExternal ? "_blank" : void 0,
                    rel: linkRel(child.nofollow, !!child.isExternal),
                    className: "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-50 hover:text-primary transition-colors",
                    children: child.label
                  },
                  `dd-item-${index}-${ci}`
                );
              }) }) })
            ] }, `dd-${index}`);
          }
          const li = item;
          const isExternal = resolveExternal(li);
          const isButton = li.isButton || li.type === "button";
          const href = li.href || "#";
          const normalizedHref = href.startsWith("#") ? `/${href}` : href;
          if (isButton) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: normalizedHref,
                target: isExternal ? "_blank" : void 0,
                rel: linkRel(li.nofollow, isExternal),
                "aria-label": li.label,
                children: li.label
              }
            ) }, `nav-${index}`);
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: normalizedHref,
              target: isExternal ? "_blank" : void 0,
              rel: linkRel(li.nofollow, isExternal),
              className: "text-sm font-medium hover:text-primary transition-colors",
              children: li.label
            },
            `nav-${index}`
          );
        }),
        hasMounted && isAuthenticated && isAdmin && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: "/editor",
            className: "text-sm font-medium text-primary hover:underline",
            "aria-label": "Open Content Editor",
            children: "Content Editor"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "md:hidden p-2 rounded-md hover:bg-gray-100", onClick: () => {
          const mobileMenu = document.getElementById("mobile-menu");
          mobileMenu == null ? void 0 : mobileMenu.classList.toggle("hidden");
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 6h16M4 12h16M4 18h16" }) }) }),
        ((_f = content.header) == null ? void 0 : _f.showSignIn) !== false && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            asChild: true,
            size: "sm",
            variant: "outline",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: (((_g = content.header) == null ? void 0 : _g.signInHref) || ((_h = content.header) == null ? void 0 : _h.signInLink) || "#").startsWith("#") ? `/${((_i = content.header) == null ? void 0 : _i.signInHref) || ((_j = content.header) == null ? void 0 : _j.signInLink) || "#"}` : ((_k = content.header) == null ? void 0 : _k.signInHref) || ((_l = content.header) == null ? void 0 : _l.signInLink) || "#",
                "aria-label": ((_m = content.header) == null ? void 0 : _m.signInText) || "Sign In",
                children: ((_n = content.header) == null ? void 0 : _n.signInText) || "Sign In"
              }
            )
          }
        ),
        ((_o = content.header) == null ? void 0 : _o.showGetStarted) !== false && /* @__PURE__ */ jsxRuntimeExports.jsx(
          MagnetizeButton,
          {
            size: "sm",
            href: (((_p = content.header) == null ? void 0 : _p.getStartedHref) || ((_q = content.header) == null ? void 0 : _q.getStartedLink) || "#").startsWith("#") ? `/${((_r = content.header) == null ? void 0 : _r.getStartedHref) || ((_s = content.header) == null ? void 0 : _s.getStartedLink) || "#"}` : ((_t = content.header) == null ? void 0 : _t.getStartedHref) || ((_u = content.header) == null ? void 0 : _u.getStartedLink) || "#",
            "aria-label": ((_v = content.header) == null ? void 0 : _v.getStartedText) || "Get Started",
            title: ((_w = content.header) == null ? void 0 : _w.getStartedText) || "Get Started",
            children: ((_x = content.header) == null ? void 0 : _x.getStartedText) || "Get Started"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        id: "mobile-menu",
        className: `hidden md:hidden ${isScrolled ? "bg-background/80 backdrop-blur border-t border-border" : "bg-transparent"} transition-colors duration-300`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 py-2 space-y-2", children: navItems.map((item, index) => {
          if (item.type === "dropdown") {
            const dd = item;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "py-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-medium text-gray-600 mb-2", children: dd.label }),
              (dd.children || []).map((child, ci) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: child.href,
                  target: child.isExternal ? "_blank" : void 0,
                  rel: linkRel(child.nofollow, !!child.isExternal),
                  className: "block py-2 pl-4 text-sm text-gray-700 hover:text-primary transition-colors",
                  children: child.label
                },
                `m-dd-item-${index}-${ci}`
              ))
            ] }, `m-dd-${index}`);
          }
          const li = item;
          const isExternal = resolveExternal(li);
          const isButton = li.isButton || li.type === "button";
          const href = li.href || "#";
          const normalizedHref = href.startsWith("#") ? `/${href}` : href;
          if (isButton) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "sm", className: "w-full text-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: normalizedHref,
                target: isExternal ? "_blank" : void 0,
                rel: linkRel(li.nofollow, isExternal),
                "aria-label": li.label,
                children: li.label
              }
            ) }, `m-nav-${index}`);
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: normalizedHref,
              target: isExternal ? "_blank" : void 0,
              rel: linkRel(li.nofollow, isExternal),
              className: "block py-2 text-sm font-medium hover:text-primary transition-colors",
              children: li.label
            },
            `m-nav-${index}`
          );
        }) })
      }
    )
  ] });
};
const AdminHeader = () => {
  const { isAuthenticated, isAdmin, email, logout } = useAuth();
  const [, setLocation] = useLocation();
  const [pathInput, setPathInput] = reactExports.useState("");
  const [hasMounted, setHasMounted] = reactExports.useState(false);
  reactExports.useEffect(() => setHasMounted(true), []);
  if (!hasMounted || !isAuthenticated || !isAdmin) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed top-0 left-0 right-0 bg-amber-100 border-b border-amber-200 text-amber-800 px-4 py-2 z-40", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto flex items-center justify-between text-sm", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: " Admin Mode" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-amber-600", children: [
        "Logged in as: ",
        email
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          href: "/admin",
          className: "bg-amber-200 hover:bg-amber-300 text-amber-800 px-3 py-1 rounded text-xs font-medium transition-colors",
          children: " Admin Dashboard"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          href: "/",
          className: "bg-amber-200 hover:bg-amber-300 text-amber-800 px-3 py-1 rounded text-xs font-medium transition-colors",
          children: " Home"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          href: "/editor",
          className: "bg-amber-600 hover:bg-amber-700 text-white px-3 py-1 rounded text-xs font-medium transition-colors",
          children: " Content Editor"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          href: "/admin#designsystem",
          className: "bg-amber-200 hover:bg-amber-300 text-amber-800 px-3 py-1 rounded text-xs font-medium transition-colors",
          children: " Design System"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden md:flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "admin-path-input", className: "sr-only", children: "Navigate to path" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            id: "admin-path-input",
            type: "text",
            inputMode: "text",
            className: "px-2 py-1 rounded border border-amber-300 bg-white/80 placeholder-amber-500 text-amber-900 text-xs w-56 focus:outline-none focus:ring-2 focus:ring-amber-400",
            placeholder: "/path (press Enter)",
            value: pathInput,
            onChange: (e) => setPathInput(e.target.value),
            onKeyDown: (e) => {
              if (e.key === "Enter" && pathInput.trim().length > 0) {
                const next = pathInput.startsWith("/") ? pathInput : `/${pathInput}`;
                setLocation(next);
                setPathInput("");
              }
            },
            "aria-label": "Navigate to arbitrary path"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => {
              if (pathInput.trim().length > 0) {
                const next = pathInput.startsWith("/") ? pathInput : `/${pathInput}`;
                setLocation(next);
                setPathInput("");
              }
            },
            className: "bg-amber-200 hover:bg-amber-300 text-amber-800 px-2 py-1 rounded text-xs font-medium transition-colors",
            "aria-label": "Go to entered path",
            children: "Go"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: logout,
          className: "bg-amber-200 hover:bg-amber-300 text-amber-800 px-3 py-1 rounded text-xs font-medium transition-colors",
          children: "Logout"
        }
      )
    ] })
  ] }) });
};
const Footer = () => {
  var _a, _b;
  const { content } = usePublishedContent();
  const { contact: contact2, footer: footer2, header: header2 } = content;
  const { isAuthenticated, isAdmin } = useAuth();
  const shouldShowFooter = ((_b = (_a = content.settings) == null ? void 0 : _a.visibility) == null ? void 0 : _b.footer) !== false;
  if (!shouldShowFooter) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("footer", { className: "bg-muted/50 border-t border-border", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-12", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid md:grid-cols-4 gap-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: isAuthenticated && isAdmin ? "/admin" : "/",
            "aria-label": isAuthenticated && isAdmin ? "Go to Admin Dashboard" : "Go to Home",
            title: isAuthenticated && isAdmin ? "Go to Admin Dashboard" : "Go to Home",
            className: "inline-block font-bold text-lg text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-blue-500 mb-4 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/50 rounded-sm",
            children: (header2 == null ? void 0 : header2.logoText) || "BiblioKit"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: (footer2 == null ? void 0 : footer2.description) || "Professional SaaS software and Figma plugins with secure API management." })
      ] }),
      ((footer2 == null ? void 0 : footer2.sections) || []).map((section, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold mb-4", children: section.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-2 text-sm text-muted-foreground", children: (section.links || []).map((link, linkIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: (() => {
          const href = link.href || "#";
          const normalizedHref = href.startsWith("#") ? `/${href}` : href;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: normalizedHref,
              className: "hover:text-foreground transition-colors",
              target: link.href.startsWith("http") ? "_blank" : void 0,
              rel: link.href.startsWith("http") ? "noopener noreferrer" : void 0,
              children: link.label
            }
          );
        })() }, linkIndex)) })
      ] }, index)),
      !((footer2 == null ? void 0 : footer2.sections) || []).some((s2) => s2.title === "Product" && (s2.links || []).some((l2) => (l2.label || "").toLowerCase().includes("doc"))) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold mb-4", children: "Product" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-2 text-sm text-muted-foreground", children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/docs", className: "hover:text-foreground transition-colors", children: "Documentation" }) }) })
      ] }),
      isAuthenticated && isAdmin && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold mb-4", children: "Admin" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-2 text-sm text-muted-foreground", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/editor", className: "hover:text-foreground transition-colors", children: "Content Editor" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/admin", className: "hover:text-foreground transition-colors", children: "Admin Dashboard" }) })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-t border-border mt-8 pt-8 text-center text-sm text-muted-foreground", children: (() => {
      const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      const brand = (header2 == null ? void 0 : header2.logoText) || "BiblioKit";
      const raw = footer2 == null ? void 0 : footer2.copyright_text;
      const computed = raw ? raw.includes("{year}") || raw.includes("{brand}") ? raw.replaceAll("{year}", String(currentYear)).replaceAll("{brand}", brand) : raw.replace(/20\d{2}/, String(currentYear)) : ` ${currentYear} ${brand}. All rights reserved.`;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: computed });
    })() })
  ] }) });
};
const ROUTE_PATHS = {
  HOME: "/",
  ADMIN: "/admin",
  EDITOR: "/editor",
  EDITOR_SLASH: "/editor/",
  DOCS: "/docs",
  PRODUCT_SLUG: "/:productSlug"
};
const isAdminRoute = (location2) => {
  return location2 === ROUTE_PATHS.ADMIN;
};
const isEditorRoute = (location2) => {
  return location2 === ROUTE_PATHS.EDITOR || location2.startsWith("/editor/");
};
const isHomeRoute = (location2) => {
  return location2 === ROUTE_PATHS.HOME;
};
const shouldHideHeader = (location2) => {
  return isAdminRoute(location2) || isEditorRoute(location2);
};
const shouldHideFooter = (location2) => {
  return isAdminRoute(location2) || isEditorRoute(location2);
};
const shouldHideContentEditor = (location2) => {
  return isAdminRoute(location2) || isEditorRoute(location2);
};
const AppLayout = ({ children }) => {
  const [location2] = useLocation();
  const showHeader = !shouldHideHeader(location2);
  const showFooter = !shouldHideFooter(location2);
  const showContentEditor = !shouldHideContentEditor(location2);
  const isTransparentRoute = calculateTransparentRoute(location2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen flex flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AdminHeader, {}),
    showHeader && /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: `flex-1 ${isTransparentRoute ? "pt-0" : "pt-16"}`, children }),
    showFooter && /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, {}),
    showContentEditor && /* @__PURE__ */ jsxRuntimeExports.jsx(ContentEditor, {})
  ] });
};
const calculateTransparentRoute = (location2) => {
  const isAdmin = isAdminRoute(location2);
  const isEditor = isEditorRoute(location2);
  const isHome = isHomeRoute(location2);
  const systemRoutes = ["admin", "editor", "design-system", "test", "database", "docs"];
  const slug = (location2 || "/").replace(/^\/+/, "").split("/")[0] || "";
  const isAdminEditor = location2.startsWith("/admin") || location2.startsWith("/editor");
  const isProductPage = !!(slug && !systemRoutes.includes(slug));
  return !isAdmin && !isEditor && (isHome || isProductPage && !isAdminEditor);
};
const AdminOnlyMessage = ({ title, message, redirectUrl }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-16 text-center", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold mb-4", children: title }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground mb-6", children: message }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: redirectUrl, children: "Go to Admin Login" }) })
] });
const AdminGuard = ({
  children,
  fallbackTitle = "Admins Only",
  fallbackMessage = "You must be an authenticated admin to access the editor.",
  redirectUrl = ROUTE_PATHS.ADMIN
}) => {
  const { isAuthenticated, isAdmin } = useAuth();
  if (isAuthenticated && isAdmin) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    AdminOnlyMessage,
    {
      title: fallbackTitle,
      message: fallbackMessage,
      redirectUrl
    }
  );
};
const ContentEditorPage = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold mb-4", children: "Content Editor" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground mb-6", children: "Make live edits to content sections and products." })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(ContentEditor, { initialOpen: true })
] });
const CTASection = ({
  title = "Ready to get started?",
  description = "Join thousands of users who trust our platform.",
  primaryButton = "Get Started",
  secondaryButton = "Learn More",
  primaryButtonLink,
  secondaryButtonLink,
  visible = true,
  className = ""
}) => {
  if (!visible) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: `py-20 px-4 bg-muted/30 ${className}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-3xl mx-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold mb-4", children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-muted-foreground mb-8", children: description }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row gap-4 justify-center", children: [
      primaryButtonLink ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          href: primaryButtonLink,
          target: primaryButtonLink.startsWith("http") ? "_blank" : "_self",
          rel: primaryButtonLink.startsWith("http") ? "noopener noreferrer" : void 0,
          children: primaryButton
        }
      ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "lg", children: primaryButton }),
      secondaryButtonLink ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "lg", variant: "outline", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          href: secondaryButtonLink,
          target: secondaryButtonLink.startsWith("http") ? "_blank" : "_self",
          rel: secondaryButtonLink.startsWith("http") ? "noopener noreferrer" : void 0,
          children: secondaryButton
        }
      ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { size: "lg", variant: "outline", children: secondaryButton })
    ] })
  ] }) }) });
};
const ContentBasedCTASection = ({ content }) => {
  var _a, _b;
  const shouldShowCTA = ((_b = (_a = content.settings) == null ? void 0 : _a.visibility) == null ? void 0 : _b.cta) !== false;
  if (!shouldShowCTA || !content.cta) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    CTASection,
    {
      title: content.cta.title,
      description: content.cta.description,
      primaryButton: content.cta.primaryButton,
      secondaryButton: content.cta.secondaryButton,
      primaryButtonLink: content.cta.primaryButtonLink,
      secondaryButtonLink: content.cta.secondaryButtonLink,
      visible: shouldShowCTA
    }
  );
};
const useHashScroll = () => {
  const [location2] = typeof window !== "undefined" ? useLocation() : ["/", () => {
  }];
  reactExports.useEffect(() => {
    if (typeof window === "undefined") return;
    let isCancelled = false;
    const tryScrollToHash = (attempt = 0) => {
      if (isCancelled) return;
      const { hash } = window.location;
      if (!hash) return;
      const id2 = decodeURIComponent(hash.slice(1));
      if (!id2) return;
      const target = document.getElementById(id2);
      if (target) {
        target.scrollIntoView({ behavior: "smooth", block: "start" });
        return;
      }
      if (attempt < 10) {
        window.setTimeout(() => tryScrollToHash(attempt + 1), 100);
      }
    };
    const onHashChange = () => {
      window.requestAnimationFrame(() => tryScrollToHash());
    };
    window.requestAnimationFrame(() => tryScrollToHash());
    window.addEventListener("hashchange", onHashChange);
    return () => {
      isCancelled = true;
      window.removeEventListener("hashchange", onHashChange);
    };
  }, [location2]);
};
const useScrollTopOnHome = () => {
  const [location2] = typeof window !== "undefined" ? useLocation() : ["/", () => {
  }];
  const scrollTopNow = () => {
    if (typeof window === "undefined") return;
    try {
      window.scrollTo(0, 0);
    } catch {
    }
    try {
      document.documentElement.scrollTop = 0;
    } catch {
    }
    try {
      document.body.scrollTop = 0;
    } catch {
    }
  };
  reactExports.useEffect(() => {
    if (typeof window === "undefined") return;
    const { pathname, hash } = window.location;
    if (pathname === "/" && !hash) {
      scrollTopNow();
      requestAnimationFrame(scrollTopNow);
      window.setTimeout(scrollTopNow, 50);
    }
  }, []);
  reactExports.useEffect(() => {
    if (typeof window === "undefined") return;
    const { pathname, hash } = window.location;
    if (pathname === "/" && !hash) {
      scrollTopNow();
      requestAnimationFrame(scrollTopNow);
      window.setTimeout(scrollTopNow, 50);
    }
  }, [location2]);
  reactExports.useEffect(() => {
    if (typeof window === "undefined") return;
    const handler = (e) => {
      try {
        const { pathname, hash } = window.location;
        if (pathname === "/" && !hash) {
          scrollTopNow();
          requestAnimationFrame(scrollTopNow);
          window.setTimeout(scrollTopNow, 50);
        }
      } catch {
      }
    };
    window.addEventListener("pageshow", handler);
    return () => window.removeEventListener("pageshow", handler);
  }, []);
};
const HomePage = () => {
  const { content, loading, error, source } = usePublishedContent();
  useSEO(content);
  if (error && !content) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-16 text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold text-red-600 mb-4", children: "Content Error" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: error })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Hero, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Features, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Pricing, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ContentBasedCTASection, { content }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Waitlist, {})
  ] });
};
const AppContent = () => {
  useScrollTopOnHome();
  useHashScroll();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AppLayout, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Switch, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ROUTE_PATHS.HOME, component: HomePage }),
    false,
    false,
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ROUTE_PATHS.DOCS, component: Docs }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ROUTE_PATHS.ADMIN, component: AdminDashboardWithErrorBoundary }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ROUTE_PATHS.EDITOR, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AdminGuard, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentEditorPage, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ROUTE_PATHS.EDITOR_SLASH, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AdminGuard, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentEditorPage, {}) }) }),
    false,
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ROUTE_PATHS.PRODUCT_SLUG, children: (params) => (params == null ? void 0 : params.productSlug) ? /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicProductPage, { slug: params.productSlug }) : null }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-16 text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-bold mb-4", children: "404 - Page Not Found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground mb-8", children: "The page you're looking for doesn't exist." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { asChild: true, size: "lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/", children: "Go Home" }) })
    ] }) })
  ] }) });
};
const App = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppContent, {}) });
};
async function fetchContentData(url) {
  try {
    const urlObj = new URL(url);
    const path = urlObj.pathname;
    const apiUrl = `${urlObj.origin}/.netlify/functions/content-management?action=current`;
    const response = await fetch(apiUrl, {
      cache: "no-store",
      headers: {
        "Cache-Control": "no-cache",
        "Pragma": "no-cache"
      }
    });
    if (response.ok) {
      const result = await response.json();
      if (result.success && result.data && result.data.content_data) {
        return result.data.content_data;
      }
    }
  } catch (error) {
    console.error("SSR: Failed to fetch content data:", error);
  }
  return createEmptyContent();
}
function renderToString(url, contentData) {
  const previousSSRContent = globalThis.__SSR_CONTENT__;
  globalThis.__SSR_CONTENT__ = contentData;
  const pathname = new URL(url).pathname;
  const makeStaticHook = (path) => () => [path, () => {
  }];
  try {
    const html = ReactDOMServer.renderToString(
      /* @__PURE__ */ jsxRuntimeExports.jsx(Router, { hook: makeStaticHook(pathname), children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
    );
    return html;
  } finally {
    if (typeof previousSSRContent === "undefined") {
      delete globalThis.__SSR_CONTENT__;
    } else {
      globalThis.__SSR_CONTENT__ = previousSSRContent;
    }
  }
}
function generateMetadata(url, contentData) {
  const urlObj = new URL(url);
  const path = urlObj.pathname;
  const baseUrl = `${urlObj.protocol}//${urlObj.host}`;
  const metadata = generateMetadata$1(path, contentData, baseUrl);
  return {
    title: metadata.title,
    description: metadata.description,
    metaTags: generateMetaTags(metadata),
    structuredData: generateStructuredData(metadata)
  };
}
export {
  fetchContentData,
  generateMetadata,
  renderToString
};
//# sourceMappingURL=entry-server.js.map
